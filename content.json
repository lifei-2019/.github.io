[{"title":"react-项目（4）基于redux的通知中心","date":"2020-04-28T14:47:56.000Z","path":"react14/","text":"我的项目源码地址 redux1npm i redux react-redux redux-thunk -S 参考之前我的文章 创建store.js reducers/notifications和reducers/index.js 在根目录index.js中添加Provider组件 store={store} 在views/Notifications/index.js中引入connect，console看一下this.props里有没有dispatch，编写mapState函数，编写connect(mapState)，修改form的dataSource actions=&gt;完善reducers=&gt;完善view界面里的标为已读的功能 在过程中发现下拉菜单的dot属性不能及时更新，发现是因为之前把下拉菜单写成menu数组，如果想实时更新的话需要把他改成函数即可，可以理解为构造了一个组件。 完善loading 登录页UI的实现这里主要采用Card+Form的布局，在设置less的时候遇到transform: translate3d(-50%,-50%,0)设置后页面显示模糊，原因是计算的结果并非整数的像素点，解决方法参见csdn上的一篇文章。 redux实现登陆页逻辑 在rap2里mock模拟数据，并在requests里新建对应的axios请求 在reducers里新建users： 写initState：id,displayyName,avatar,role,isLoading(如果有token就改为true，但是token本身要存在storage里) 写函数 123456export default(state=initState,action)=&gt;&#123; switch(action.type)&#123; default: return state &#125;&#125; 整合到reducers/index.js里 修改index.js里以前遗留的问题：需要权限登录才能访问/admin，修改Route里的render，用component={App}代替，具体的权限跳转转到App组件里设置 修改App.js：引入connect 1234const mapSate=state=&gt;(&#123; isLogin:this.props.isLogin&#125;)@connect(mapState) ​ 修改return里的 12345this.props.isLogin?里面的内容:&lt;Redirect to=&quot;/login&quot; /&gt; 添加actions里面的状态：LOGIN、START_LOGIN、LOGIN_SUCCESS、LOGIN_FAILED 新建actions/user.js 123456789101112131415161718192021222324252627282930import actionTypes from &apos;./actionTypes&apos;import &#123;loginRequest&#125; from &apos;../requests&apos;const startLogin=()=&gt;&#123; return&#123; type:actionTypes.START_LOGIN &#125;&#125;const loginSuccess=()=&gt;&#123; return&#123; type:actionTypes.LOGIN_SUCCESS &#125;&#125;const loginFailed=()=&gt;&#123; return&#123; type:actionTypes.LOGIN_FAILED &#125;&#125;export default login =(userInfo)=&gt;&#123; return dispatch=&gt;&#123; dispatch(startLogin()) loginRequest(userInfo) .then(resp=&gt;&#123; console.log(resp) &#125;) &#125;&#125; 只有同步的东西才能定义actionTypes 修改login/index.js界面 写mapState函数，使用connect函数联结 引入action/user里的login方法 修改onFinish函数，在onFinish里引用login函数 修改actions/user.js loginSuccess要加参数，login函数的完善 做完之后可以去reducers/user里console一下action看是否显示LOGIN_SUCCESS 修改reducers/user switch语句分别对应三种情况：开始登陆，登陆成功，登陆失败 修改Login/index.js Redirect，在render时判断isLogin的状态，true则redirect到admin界面，false则仍返回登录界面 细节部分：在input、checkout组件可以设置disabled={this.props.isLoading}，在button组件里可以设置loading属性，即在提交时表单会进入短暂loading状态，更为真实 Storage持久化存储1.在actions/user.js里 在login里对获取到的数据进行存储loaclstorage/sessionstorage 在loginFailed里清除存储的authToken 2.在reducers/user里，重新定义isLogin的值 1const isLogin = Boolean(window.localStorage.setItem(&apos;authToken&apos;)) || Boolean(window.sessionStorage.setItem(&apos;authToken&apos;)) 3.frame组件里 mapstate函数里多返回avatar和displayName 在合适的地方加上{this.props.avatar}等等 4.发现上面步骤的头像和名字尚未显示，因为在actions里面只传递了authToken，要加上 123window.localStorage.setItem(&apos;userInfo&apos;,JSON.stringify(userInfo))window.localStorage.removeItem(&apos;userInfo&apos;) 退出登录1.actions/user 写logout函数 2.frame 在onDropdownMenuClick函数里加logout 3.reducers 修改loginFailed函数","updated":"2020-05-05T12:44:15.301Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-项目（3）编辑页面+编辑器+echarts+UI通知中心","date":"2020-04-22T15:24:33.000Z","path":"react13/","text":"我的项目源码地址 编辑页面的跳转ArticleList里 1this.props.history.push(`/admin/article/edit/$&#123;record.id&#125;`) 注意此处在react里要用到@withRouter装饰器否则取不到this.props.history Frame里 由于上述路径和之前的Frame里规定的不同，所以左侧编辑栏中选中会消失，此时可以善用split和join函数 123456const selectedKeyArr = this.props.location.pathname.split(&apos;/&apos;) selectedKeyArr.length=3 selectedKeys=&#123;[selectedKeyArr.join(&apos;/&apos;)]&#125; 编辑器这里使用wangeditor，也可以用editormd 1npm i wangeditor -S wangEditor3使用手册 里面有结合react、vue等等的Demo 表单antd4.0官网 在表单方面，4.0和3.0区别暂时发现以下： 取消了Form.create() 对Form.Item内部Input、Button等等组件的设置改为在Form.Item上 本着实用的原则建议大家还是学习新版本，多读源码。 随机颜色的生成方法参考简书上的一篇文章 Material-UI 当下流行的 React UI 框架 网页上图表的技术1.canvas 位图 （不能无限放大） 2.svg 矢量图 （可以无限放大） 3.三维 webgl echarts highcharts（收费） 数据可视化 d3 dataV（收费） 游戏 白鹭引擎egret 更早的 antv、p5、raphael、vml等等 这里用echarts 1npm i echarts -S 右上角UIDropDown组件 下拉框 Avatar组件 头像 Badge组件 消息提示多少条 display:flex 关于flex的一些资料","updated":"2020-05-02T13:42:47.438Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-项目（2）Frame组件+mock数据+表格的基本渲染、分页、删除以及一些细节","date":"2020-04-16T12:34:57.000Z","path":"react12/","text":"我的项目源码地址 微软bing搜索 引入icon由于antd4中移除了之前的&lt;Icon /&gt;的方法，可以改为下面两种方法 1.antd4和iconfont的结合使用 2.采用antd的兼容包（但不太推荐，最好用新版本） 123import &#123; Icon &#125; from &apos;@ant-design/compatible&apos;;&lt;Icon type=&#123;item.icon&#125;/&gt; 表格使用官网教程 使用RAP2模拟数据RAP2官网 时间戳 new Date().getTime()获取现在 new Date(1999999999999).getFullYear()转换成年份 Postman 模拟接口，把刚刚RAP中的地址粘贴到Postman软件里进行post。 Ajax参考前面我的文章 npm i axios -S JS时间格式化npm i moment -S 123window.moment=momentmoment()moment(这里写时间戳).format(&apos;YYYY年MM月DD日 hh:mm:ss&apos;) 导出Excelnpm i xlsx -S 官网github示例在上面找自己需要的 这里我用的是react的示例 在线画流程图 ProcessOn 举例：如果画一个删除文章的功能 和visio功能相似，但是好在可以在线编辑 Tooltip在文字上方显示 12&lt;Tooltip title=&#123;amount&gt;200 ? &apos;超过200&apos; : &apos;没超过200&apos;&#125;&gt;&lt;/Tooltip&gt;","updated":"2020-04-23T07:38:45.566Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-项目（1）配置环境+基本页面及外层路由+内层路由","date":"2020-04-12T14:46:12.000Z","path":"react11/","text":"我的项目源码地址 配置项目开发环境 基于cra添加react-app-rewired 和customize-cranpm i react-app-rewired customize-cra -D 配置config-overrides.js 配置lessnpm i less less-loader -D 配置config-overrides.js 配置Antdnpm i antd -S npm i babel-plugin-import -D 配置lessVar.js 个性化操作参见Ant Design官网 装饰器模式查看customize-cra 需要在config-overrides里添加addDecoratorsLegacy方法 npm i @babel/plugin-proposal-decorators -D 此处遇到问题，应该是ES7中装饰器语法的问题，查阅资料后发现可以在项目根目录下添加jsconfig.js，代码如下 123456&#123; \"compilerOptions\": &#123; \"experimentalDecorators\": true, \"allowJs\": true &#125;&#125; 在App.js里面尝试一下 1234567891011121314const testHOC = (WrappedComponent) =&gt;&#123; return class HOCComponent extends Component&#123; render() &#123; return( &lt;&gt; &lt;WrappedComponent /&gt; &lt;div&gt;这是高阶组件里的信息&lt;/div&gt; &lt;/&gt; ) &#125; &#125;&#125;@testHOC 每一步配置完最好写段代码测试一下** 【在vscode中ctrl+shift+L对相同字符同时进行操作】 基本页面及外层路由基本界面分为：-Login -404 -admin ​ -dashboard ​ -article ​ -List ​ -edit ​ -settings 外层路由：这里主要指 在routes里分为mainRouter(login和404)和adminRouter(其余一些功能) 在src/index.js里： 当路径是/admin时，返回App组件 mainRouter的遍历，返回mainRouter路由名对应的组件 对/和其余路径的重定向 内层路由的配置以及路由的懒加载1.结合前面的教程配置react-router ​ 这里主要是对/admin后面的路径进行细的划分 ，思路和之前的外层路由类似，看个人喜好进行配置 2.参考react-loadable进行配置路由的懒加载 ​ npm i react-loadable -S 3.编写一个Loading组件便于测试 运行后发现在控制台会warning 参考@前端瓶子君在csdn上的文章 可以运行一个自动重命名它们的 codemod 脚本 npx react-codemod rename-unsafe-lifecycles","updated":"2020-04-13T14:59:49.631Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（8）redux-router","date":"2020-04-10T13:56:23.000Z","path":"react10/","text":"源码在我的github地址react-tuts-06 react-router官网 npm i react-router-dom -S &lt;Router /&gt; 必须在最外层，只能写一次，写了之后下面的每一层都可以用。 &lt;Route /&gt; 可以通过component方法来渲染component={组件名}，也可以用render方法render={(routeprops)=&gt; return{&lt;组件名 {…routeprops} 其他参数 &gt;}，render可以传递参数，但是component不行。并且这两个是互斥的。 &lt;Link /&gt; 1.通过query。 2.可以通过动态路由来传参 /path/:param=&gt;params 3.to里面用state进行隐式传参 其中第三种 可以埋点 发送数据常用的方法： 1.ajax 2.img 用图片带上一些参数后端就可以获取到 12const img = newImage()img.src=&quot;https://www.domainname.com/button-01.gif?x=1&amp;y=2&quot; 3.sendBeacon ​ 兼容性差但是成功率高，ie不行，但是移动端可以用 &lt;Redirect /&gt; 自动跳转界面 &lt;withRouter /&gt; 只有使用组件包裹的才能用routeRouter的api，不然要用withRouter进行export","updated":"2020-04-17T03:44:02.596Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（7）react-redux和异步action","date":"2020-04-09T14:00:23.000Z","path":"react9/","text":"源码在我的github地址react-tuts-05 在线写js代码 提供免费的在线REST API React-redux流程 npm i react-redux –save 创建store，createStore是redux提供的一个用于创建store的方法；引入合并后的reducer；createStore的第一个参数必须输一个reducer，如果是多个，要在reducers目录下先试用combineReudcer进行合并之后再导出。 在实际的项目中，由于只有单一的store，但是状态会有很多分类，所以我们需要划分reducer，但是createStore的参数只接收一个reducer，所以，redux比较聪明的提供了一个用于合并多个reducer的方法。 导出后在外部就可以通过store.getState().cart来获取cartReducer里面的state 为了避免actionType重复，一般会把actionType放在一个文件里统一进行管理，也可以避免写错actionType。 创建购物车的reducer，reducer的固定写法是两个参数，第一个state并且有初始值，第二个是action。根据不同的action.type，做不同的处理，每次返回一个新的state，返回的类型一样。一定要有default，当actionType不对的时候，不作任何处理，返回上一次的default。 action有两种写法：第一种写成一个对象，是一个标准的action，但是传递不了参数。实际情况常用是使用actionCreator，它是一个方法返回一个对象，这个对象才是真正的action。 Provider是react-redux提供的一个组件，一般直接把这个组件放在应用程序的最顶层，这个组件必须有一个store属性，这个store属性的值就是创建的store。只要在最外层包裹了这个Provider，那么所有后代组件都可以使用Redux.connect作连接。 connect方法执行之后是一个高阶组件，导入actionCreators；connect方法有四个参数，常用的就是前面两个。第一个参数是mapStateToProps，作用是从store注入到当前组建的props上 第二个参数可以使mapDispatchToProps，这个得主要作用是把action生成的方法注入到当前组件的props 但是第二个参数可以直接传递一个对象，这里的对象就是actionCreators，只要传入了actionCreators，在组件内部通过this.props.actionCreator来调用，这样的话，在调用之后，actionCreator会自动帮你把她内部的action dispatch出去。 PS：此处还可以用装饰器模式。 异步action普通 actionCreator =&gt;自动dispatch(actionCreator()) =&gt; reducer =&gt;store =&gt; view 异步 actionCreator =&gt;middleware处理生成新的action =&gt; 手动dispatch(action) =&gt; reducer =&gt;store npm install –save redux-thunk 修改store.js 1234export default createStore( rootReducer, applyMiddleware(thunk) ) 修改action具体的组件 12345export const decrementAsync =id =&gt;dispatch =&gt;&#123; setTimeout(()=&gt;&#123; dispatch(decrement(id)) &#125;,2000)&#125; 关于middleware 标准的redux工作模型这里借用blog的发布流程来理解建立一个react-redux的过程。个人理解： store.js=&gt;容器组件和展示组件=&gt;reducers=&gt;actions=&gt;完善reducers=&gt;编写根目录下index.js 在过程中发现下拉菜单的dot属性不能及时更新，发现是因为之前把下拉菜单写成menu数组，如果想实时更新的话需要把他改成函数。","updated":"2020-05-01T04:13:34.301Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（6）状态管理以及redux","date":"2020-04-04T13:56:23.000Z","path":"react8/","text":"概念源码在我的github地址react-tuts-04 Redux把Flux与函数式编程结合在一起 redux官网 如果UI层很简单，就不用Redux 需要Redux的项目： 不同身份的用户有不同的使用方式（用户和管理员） 多个用户之间可以协作 与服务器大量交互，或者使用了WebSocket View要从多个来源获取数据 从组件层面考虑： 某个组件状态需要共享 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态 一般来说流程是这样的： 用户触发页面上的某种操作，通过 dispatch 发送一个 action。 Redux 接收到这个 action 后通过 reducer 函数获取到下一个状态。 将新状态更新进 store，store 更新后通知页面重新渲染。 从这个流程中不难看出，Redux 的核心就是一个 发布-订阅 模式。一旦 store 发生了变化就会通知所有的订阅者，view 接收到通知之后会进行重新渲染。 自制Redux因此我们可以自己实践一下 新建redux-principle.html，！+Tab新建网页，添加buttom按钮，静态网页界面。 获取界面上的数字，设置countState；同时编写changeState(state,action)函数，其中state由createStore(changeState)创建，createStore会return三个值getState, dispatch,subscribe，getState是为了返回当前state的状态，（第一次的话就是初始化时候是null）dispatch是为了获changeState执行后state的值，subscribe是为了增加监听器里的数据。 dispatch 和 action 是息息相关的，只有通过 dispatch 才能发送 action。而发送 action 之后才会执行 subscribe 监听到的那些方法。所以 dispatch 做的事情就是将 action 传给 reducer 函数，将执行后的结果设置为新的 store，然后执行 listeners 中的方法。 编写renderCount()，通过每个store.getState()获取state，再渲染数字的数值。执行renderCount()，如果有多个 action 同时发送，这样很难说清楚最后的 store 到底是什么样的，所以需要加锁。在 Redux 中 dispatch 执行后的返回值也是当前的 action，所以还需要store.subscribe(renderCount)。 源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;自制redux&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button onclick=\"store.dispatch(&#123;type:'JIAN',n:2&#125;)\"&gt;-&lt;/button&gt; &lt;span id=\"countDisplay\"&gt;10&lt;/span&gt; &lt;button onclick=\"store.dispatch(&#123;type:'JIA',n:3&#125;)\"&gt;+&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const countDisplay = document.querySelector('#countDisplay') const countState = &#123; count:5 &#125; const changeState = (state,action) =&gt;&#123; if(!state)&#123; return countState &#125; switch(action.type) &#123; case 'JIAN': return&#123; ...state, count: state.count - action.n &#125; case 'JIA': return&#123; ...state, count: state.count + action.n &#125; default: return state &#125; &#125; const createStore = (changeState) =&gt; &#123; let state = null const getState = () =&gt; state const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const dispatch= (action) =&gt; &#123; state = changeState(state,action) listeners.forEach(listener =&gt;listener()) &#125; dispatch(&#123;&#125;) return&#123; getState, dispatch, subscribe &#125; &#125; const store = createStore(changeState) const renderCount = () =&gt;&#123; countDisplay.innerHTML= store.getState().count &#125; renderCount() store.subscribe(renderCount) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用Redux组件 npm i redux -S 建立reducers文件夹，用combineReducers统一导出reducers里的组件； 每个组件首先要定义一个初始的状态，然后export default｛state,action｝，包括default以及各种情况。 把状态导入store，把store引入组件 创建action，把actionType定义好，统一导出actions里的组件； 一般是一个方法，这样在视图里调用时候可以写参数，在哪里用action直接在components的组件里引用store.dispatch(方法名)。 如果想修改数据时候同时修改视图层，那么需要在reducers里完善步骤2里的各种情况。 如果步骤5里设置完没有响应，那可能是没有设置监听器subscribe PS：无副作用修改原数组 12345678var obj = &#123;x:1,y:2,z=2&#125;//方法一var obj1=Object.assign(&#123;&#125;,obj,&#123;z:4,a:5&#125;)//方法二var obj2=&#123;...obj,z:44,a:55&#125;//方法三var arr=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;arr2=arr.slice()","updated":"2020-04-09T14:04:47.912Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（5）HOC、装饰器模式","date":"2020-03-31T15:03:37.000Z","path":"react7/","text":"vue生态更官方化，react更加社区化 源码在我的github地址react-tuts-03 HOC高阶组件Higher-Order Component 举例： 12345678910var add = (x) =&gt; &#123; return (y) =&gt; &#123; return x+y &#125;&#125;用的时候add(1)(2)//柯里化 装饰器让cra支持@装饰器写法 1.不管你是要配置什么，最好的方式是使用react-app-rewired这个包来对cra创建的项目进行轻微的配置调整 npm install react-app-rewired –save-dev 2.安装好之后，把package.json里的scripts里的react-scripts换成react-app-rewired 3.在根目录下创建一个config-overrides.js 1234module.exports= (config) =&gt; &#123; //如果没有使用customize-cra，在这个里面可以对config进行配置 return config&#125; 4.当然如果想要方便，可以先安装customize-cra，然后修改config-overrides.js npm install customize-cra –save-dev npm i @babel/plugin-personal-decorators -D 12345const &#123;override, addDecoratorsLegacy&#125; = require('customize-cra')module.exports = override( addDecoratorsLegacy()) 项目目录 src/Another.js12345678910111213141516import React, &#123; Component &#125; from 'react'import withCopyright from './withCopyright'@withCopyrightclass Another extends Component &#123; render() &#123; return ( &lt;div&gt; Another &#123;this.props.name&#125; &lt;/div&gt; ) &#125;&#125;export default Another src/App.js12345678910111213141516import React, &#123; Component &#125; from 'react'import withCopyright from './withCopyright'import Another from './Another' class App extends Component &#123; render() &#123; return ( &lt;div&gt; App &lt;Another name='组件' /&gt; &lt;/div&gt; ) &#125;&#125;export default withCopyright(App) src/index.js12345678import React from 'react'import &#123; render &#125; from 'react-dom'import App from './App'render( &lt;App /&gt;, document.querySelector('#root')) withCopyright.js12345678910111213141516import React,&#123;Component&#125; from 'react'const withCopyright = (YourComponent) =&gt; &#123; return class withCopyright extends Component &#123; render()&#123; return( &lt;&gt; &lt;YourComponent &#123;...this.props&#125;/&gt; &lt;div&gt;&amp;copy; 2020 &amp;emsp;raphael&amp;nbsp;哈哈哈&lt;/div&gt; &lt;/&gt; ) &#125; &#125;&#125;export default withCopyright config-overrides.js12345const &#123;override, addDecoratorsLegacy&#125; = require('customize-cra')module.exports = override( addDecoratorsLegacy())","updated":"2020-04-06T15:11:09.428Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（4）hooks和context","date":"2020-03-31T15:03:37.000Z","path":"react6/","text":"源码在我的github地址react-tuts-02 React HooksReact Hooks是react 16.8新增的一项功能。可以在不编写class的情况下使用state。 两个常见的api，useState和useEffect，需要先引入 useState是一个方法，方法参数是默认值，结果是一个数组，数组的第一个就是state，第二个相当于setState（不一样的地方在于参数，这里的参数是一个新值即可），解构出来数组中的两个值。 useEffect的参数是一个回调，不管是组件挂载还是更新，都会触发这个回调方法，类似于componentDidMount和componentDidUpdate的结合 1234567891011121314151617181920212223242526272829import React ,&#123;useState, useEffect&#125; from 'react'import &#123; render &#125; from 'react-dom'const Counter = () =&gt; &#123; const [count,setCount] = useState(0) //console.log(useState(10)) // 可以使用多次 // const [title,setTitle] = useState('abc') //console.log(title) useEffect(() =&gt; &#123; console.log('渲染了') document.title=`当前的数量为$&#123;count&#125;` &#125;) return( &lt;div&gt; &lt;p&gt;当前的数量为&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123;setCount(count - 1)&#125;&#125;&gt;-&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; &#123;setCount(count + 1)&#125;&#125;&gt;+&lt;/button&gt; &lt;/div&gt; )&#125;render( &lt;Counter /&gt;, document.querySelector('#root')) context具体介绍 createContext是react提供的一个用于跨组件传值的方法，这个方法的结果是一个对象，里面有两个组件Provider和Consumer。 Provider用于提供状态 Consumer用于接受状态， 项目目录 src/components/Count1/index.js123456789101112131415161718import React, &#123; Component &#125; from 'react'import &#123; CounterConsumer &#125; from '../../counterStore'//定义一个Count1组件export default class Count1 extends Component&#123; render()&#123; return( //使用CounterConsumer来接受count， &lt;CounterConsumer&gt; &#123; //注意！！！Consumer的children必须是一个方法，这个方法有一个参数，这个参数就是Provider的value (&#123;count&#125;)=&gt;&#123; return &lt;span&gt;&#123;count&#125;&lt;/span&gt; &#125; &#125; &lt;/CounterConsumer&gt; )&#125; &#125; src/components/CountBtn/index.js123456789101112131415import React, &#123; Component &#125; from 'react'import &#123; CounterConsumer &#125; from '../../counterStore'export default class CountBtn extends Component&#123; render() &#123; return &lt;CounterConsumer&gt; &#123; (&#123;onincrementCount, ondecrementCount&#125;)=&gt;&#123; const handler = this.props.type === 'increment' ? onincrementCount : ondecrementCount return &lt;button onClick=&#123;handler&#125;&gt;&#123;this.props.children&#125;&lt;/button&gt; &#125; &#125; &lt;/CounterConsumer&gt; &#125; &#125; src/components/Counter/index.js1234567891011121314151617181920212223import React, &#123;useState, useEffect &#125; from &apos;react&apos;export default function Counter() &#123; const [count,setCount] = useState(0) //console.log(useState(10)) // 可以使用多次 // const [title,setTitle] = useState(&apos;abc&apos;) //console.log(title) useEffect(() =&gt; &#123; console.log(&apos;渲染了&apos;) document.title=`当前的数量为$&#123;count&#125;` &#125;) return( &lt;div&gt; &lt;p&gt;当前的数量为&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123;setCount(count - 1)&#125;&#125;&gt;-&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; &#123;setCount(count + 1)&#125;&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ) &#125; src/components/index.js123export &#123; default as Counter &#125; from './Counter'export &#123; default as Count1 &#125; from './Count1'export &#123; default as CountBtn &#125; from './CountBtn' src/App.js12345678910111213141516171819import React, &#123; Component &#125; from &apos;react&apos;import&#123; CountBtn, Count1, Counter &#125; from &apos;./components&apos;export default class App extends Component&#123; render () &#123; return( &lt;&gt; &lt;Counter /&gt; &lt;br&gt;&lt;/br&gt; &lt;CountBtn type=&quot;decrement&quot;&gt;-&lt;/CountBtn&gt; &lt;Count1 /&gt; &lt;CountBtn type=&quot;increment&quot;&gt;+&lt;/CountBtn&gt; &lt;/&gt; )&#125;&#125; src/counterStore.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React,&#123;Component,createContext&#125; from &apos;react&apos;//console.log(createContext())const&#123; Provider, Consumer: CounterConsumer //结构出来重新赋值给一个CounterConsumer的组件 &#125; = createContext() //封装一个基本的Provider，因为直接使用Provider不方便管理状态class CounterProvider extends Component&#123; constructor()&#123; super() //这里的状态就是共享的，任何CounterProvider的后代组件，都可以通过CounterProvider来接受这个值 this.state=&#123; count: 100 &#125; &#125; //这里的方法也会继续通过Provider共享下去 incrementCount = ()=&gt;&#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; decrementCount = ()=&gt;&#123; this.setState(&#123; count: this.state.count -1 &#125;) &#125; render()&#123; return( //使用Provider这个组件，它必须要有一个value，value里可以传递任何的数据，一般还是传递一个比较合理。 &lt;Provider value=&#123;&#123; count: this.state.count, //这两个括号意义不同，可以简单的理解为： //外面的花括号是说：我这里面写的是js语句 //内部的花括号是说：我里面的不是要显示的文字，而是变量，我要把变量的值解析放在这 onincrementCount:this.incrementCount, ondecrementCount:this.decrementCount &#125;&#125; &gt; &#123;this.props.children&#125; &lt;/Provider&gt; ) &#125; &#125; export &#123; CounterProvider, CounterConsumer &#125; src/index.js123456789101112131415import React from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;import&#123; CounterProvider &#125; from &apos;./counterStore&apos;import App from &apos;./App&apos; render( &lt;CounterProvider&gt; &lt;App /&gt; &lt;/CounterProvider&gt;, document.querySelector(&apos;#root&apos;))","updated":"2020-04-06T15:10:45.492Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（3）生命周期和ajax","date":"2020-03-28T06:34:26.000Z","path":"react5/","text":"生命周期 生命周期图谱 挂载当组件实例被创建并插入DOM中，生命周期调用顺序如下** construstor() 只执行一次。初始化，在super之后构建 static getDerivedStateFromProps() render() 负责渲染，即合成虚拟DOM componentDidMount() 获取真实DOM比如ajax 更新当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下： static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 卸载当组件从 DOM 中移除时会调用如下方法： componentWillUnmount() 错误处理（不常用，一般用console.log）当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法： static getDerivedStateFromError() componentDidCatch() `是ES6新增的模版字符串“hello” + str + “world !” ``hello ${str} world ! 减少更新次数方法一：把Component改成PureComponent，但这种只做了第一层，方法二是更深层的。 方法二：第一个判断123shouldComponentUpdate(nextProps,nextState)&#123; return (nextProps.isCompleted !== this.props.isCompleted)||(nextProps.xxx != this.props.xxx)&#125; 第二个判断老版本的坑：constructor里面通过props来初始化一个state，在props修改之后，这个state不会再次更新。需要借助于componentWillReceiveProps来做一次修正 新版本：123456789101112constructor()&#123; super() this.state = &#123; completedText: &apos;&apos; &#125; &#125; static getDerivedStateFromProps(props)&#123; return&#123; completedText: props.isCompleted ? &apos;wancheng&apos;:&apos;weiwancheng&apos; &#125; &#125; Ajaxjson官网 前后端接口 npm install axios -S 新建 src/services/apis.js12345export default&#123; baseURL: 'https://jsonplaceholder.typicode.com', //获取todos的接口 todos: '/todos'&#125; 新建src/services/index.js12345678910111213import axios from 'axios'import apis from './apis'const ajax = axios.create(&#123; baseURL: apis.baseURL&#125;)//在这里还回去做一些全局的拦截器处理export const getTodos = ()=&gt;&#123; return ajax.get(apis.todos)&#125; 在App.js中引入1import &#123; getTodos &#125; from './services' 同时 12345678910111213141516171819202122232425262728293031323334353637constructor() &#123; super() this.state = &#123; title: &apos;待办事情&apos;, desc:&apos;有点多&apos;, article: &apos;&lt;div&gt;123456 &lt;i&gt;654321&lt;/i&gt;&lt;/div&gt;&apos;, todos:[], isLoading: true &#125; &#125; getData = () =&gt; &#123; getTodos() .then(resp =&gt; &#123; //console.log(resp) if (resp.status === 200) &#123; this.setState(&#123; todos: resp.data &#125;) //setTimeout(() =&gt; &#123;这里具体操作&#125;,5000) &#125;else &#123; //处理错误 &#125; &#125;) .catch(err =&gt;&#123; console.log(err) &#125;) .finally(() =&gt; &#123; this.setState(&#123; isLoading: false &#125;) &#125;) &#125; componentDidMount ()&#123; this.getData() &#125;","updated":"2020-03-29T09:48:30.535Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（2）项目目录以及组件","date":"2020-03-24T14:41:16.000Z","path":"react4/","text":"源码在我的github地址react-tuts TodoHeader1.在App.js中设置值传到组件，props向下传递的方法，注意要用花括号。 2.在TodoHeader/index.js中，模版渲染语法 （类组件前面要加this.props 函数用props） 3.prop-types的使用 npm install –save prop-types 判定数据类型 TodoList在TodoList/index.js中 1.通过PropTypes验证todos组件中各个部分的类型 2.用两种方法写出（注意要设置key值） Like（点赞功能）1.设置state里面islike的属性 2.创建handleClick方法（这里用到setState，是异步的，在其内部还可以用到prevState表示点击之前的state的状态） 3.emoji网站 Input输入框1.未输入时默认state的InputValue为空 2.handleInputChange输入时同步显示在输入框中 3.handelAddClick：点击添加按钮时，调用App.js里的addTOdo函数，同时清空输入框 4.添加回车事件，通过keyup（keycode 13 = Enter） 5.添加完成之后获取焦点，用createRef 添加checkbox1.在App.js中新建函数onCompletedChanged函数，并且在里面标注 2.在TodoList里面的index.js里添加onCompletedChange={this.props.onCompletedChange} 3.在TodoItem.js里面添加handelCheckboxChange函数，它是onChange的方法 4.新增知识点const noop = ()=&gt; {} 各个文件具体代码src/App.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import React, &#123; Component, Fragment &#125; from 'react'import&#123; TodoHeader, TodoInput, TodoList, Like&#125; from './components'export default class App extends Component &#123; // state = &#123; // title: '待办事情' // &#125; //不知道props还是state就用props constructor() &#123; super() this.state = &#123; title: '待办事情', desc:'有点多', article: '&lt;div&gt;123456 &lt;i&gt;654321&lt;/i&gt;&lt;/div&gt;', todos: [ &#123; id: 1, title: '看视屏', assignee: 'Leo', isCompleted: false &#125;, &#123; id: 2, title: '实践', assignee: 'Xiao', isCompleted: true &#125;] &#125; &#125; addTodo = (todoTitle) =&gt; &#123; //这样写不对，TODOTitle不是一个数组 // this.setState(&#123; // todos: this.state.todos.push(&#123; // id: Math.random, // title: todoTitle, // isCompleted: false // &#125;) // &#125;) // 这个代码是对的 // this.setState(&#123; // todos: this.state.todos.concat(&#123; // id: Math.random(), // title: todoTitle, // isCompleted: false // &#125;) // &#125;) // const newTodos = this.state.todos.slice() const newTodos = [...this.state.todos] newTodos.push(&#123; id: Math.random(), title: todoTitle, isCompleted: false &#125;) this.setState(&#123; todos: newTodos &#125;) &#125; onCompletedChange = (id) =&gt;&#123; this.setState((prevState) =&gt;&#123; return&#123; todos: prevState.todos.map(tod =&gt;&#123; if(tod.id === id)&#123; tod.isCompleted = !tod.isCompleted &#125; return tod &#125;) &#125; &#125;) &#125; render() &#123; return ( &lt;Fragment&gt; &#123;&lt;div dangerouslySetInnerHTML=&#123;&#123;__html: this.state.article&#125;&#125; /&gt;&#125; &#123;this.state.todos[0].isCompleted ? '完成' : '未完成'&#125; &#123; this.state.todos.map(todo =&gt;&#123; return &lt;div key=&#123;todo.id&#125;&gt;&#123;todo.title&#125;&lt;/div&gt; &#125;) &#125; &lt;TodoHeader desc=&#123;this.state.desc&#125; x=&#123;1&#125; y=&#123;2&#125;&gt; &lt;i&gt;待办事项列表&lt;/i&gt; &lt;br&gt;&lt;/br&gt; &#123;this.state.title&#125; &lt;/TodoHeader&gt; &lt;TodoInput addTodo=&#123;this.addTodo&#125; /&gt; &lt;TodoList todos=&#123;this.state.todos&#125; onCompletedChange=&#123;this.onCompletedChange&#125; /&gt; &lt;Like /&gt; &lt;/Fragment&gt; // &lt;&gt; // &lt;TodoHeader /&gt; // &lt;TodoInput /&gt; // &lt;TodoList /&gt; // &lt;/&gt; //两种方法都可以 ) &#125;&#125; src/index.js123456789import React from 'react'import &#123; render &#125; from 'react-dom'import App from './App'render( &lt;App /&gt;, document.querySelector('#root')) src/components/index.js12345678910111213141516//负责导出所有的组件，下面两种方法都可以// import TodoHeader from './TodoHeader'// import TodoInput from './TodoInput'// import TodoList from './TodoList'// export &#123;// TodoHeader,// TodoInput,// TodoList// &#125;export&#123; default as TodoHeader&#125; from './TodoHeader'export&#123; default as TodoInput&#125; from './TodoInput'export&#123; default as TodoList&#125; from './TodoList'export&#123; default as Like&#125; from './Like' src/components/Like/index.js123456789101112131415161718192021222324252627282930313233343536373839404142import React, &#123; Component &#125; from 'react'export default class Like extends Component &#123; constructor()&#123; super() this.state = &#123; isliked: false &#125; &#125; handleLikedClick = () =&gt;&#123; //使用这种方式在react里是不允许的，可以修改数据，但界面不会重新渲染 //this.state.isLiked = !this.state.isLiked //要修改数据，就要使用setState方法，setState方法有两种情况 //第一个参数又有两种情况，第一种情况是一个对象 // this.setState(&#123; // isliked: !this.state.isliked // &#125;) //第二种情况是一个方法 this.setState((prevState,props)=&gt;&#123; console.log('setState内部的状态',this.state.isliked) return&#123; isliked: !prevState.isliked &#125; &#125;,() =&gt;&#123; //由于setState是异步的，如果要获取到最新的state，应该在这个回调里获取 console.log(this.state.isliked) &#125;) console.log('setState外部的状态',this.state.isliked) &#125; render() &#123; return ( &lt;div&gt; &lt;span onClick=&#123;this.handleLikedClick&#125;&gt; &#123; this.state.isliked ? '取消❤️' : '喜欢🖤' &#125; &lt;/span&gt; &lt;/div&gt; ) &#125;&#125; src/components/TodoHeader/index.js123456789101112131415161718192021222324252627import React from 'react'import PropTypes from 'prop-types'export default function TodoHeader(props) &#123; //console.log(props) return ( &lt;&gt; &lt;h1&gt; &#123;props.children&#125; &lt;/h1&gt; &lt;h3&gt; &#123;props.desc&#125; &lt;/h3&gt; &lt;p&gt;&#123;props.x+props.y&#125;&lt;/p&gt; &lt;/&gt; )&#125;TodoHeader.propTypes = &#123; desc: PropTypes.string.isRequired, x: PropTypes.number.isRequired, //是否是数据以及是否必要 y: PropTypes.number&#125;TodoHeader.defaultProps = &#123; desc: '明天会更好'&#125; src/components/TodoInput/index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//react里面通过ref来获取组件或者dom元素，要使用ref之前必须先调用React.createRef创建一个refimport React, &#123; Component, createRef &#125; from 'react'import PropTypes from 'prop-types'//类组件前面要加this.props 函数用propsexport default class TodoInput extends Component &#123; static propTypes = &#123; btnText: PropTypes.string &#125; static defaultProps = &#123; btnText: '添加TODO' &#125; constructor()&#123; super() this.state = &#123; inputValue: '' &#125; //this.handelAddClickCopy = this.handelAddClick.bind(this,124) //在constructor里来创建Ref this.inputDom = createRef() &#125; handleInputChange = (e) =&gt; &#123; this.setState(&#123; inputValue: e.currentTarget.value &#125;) &#125; handleKeyUp = (e) =&gt;&#123; if(e.keyCode ===13)&#123; this.handelAddClick() &#125; &#125; handelAddClick = () =&gt; &#123; //console.log(this.state) //实际的项目中，这里还需要区队this.state.inputValue做验证，如果验证通过在执行 if(this.state.inputValue === '')&#123; return &#125; this.props.addTodo(this.state.inputValue) this.setState(&#123; inputValue: '' &#125;, () =&gt; &#123; this.inputDom.current.focus() &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange&#125; onKeyUp=&#123;this.handleKeyUp&#125; ref=&#123;this.inputDom&#125; /&gt; &lt;button onClick=&#123;this.handelAddClick&#125;&gt;&#123;this.props.btnText&#125;&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; src/components/TodoList/index.js1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react'import TodoItem from './TodoItem'import PropTypes from 'prop-types'export default class TodoList extends Component &#123; static propTypes = &#123; todos:PropTypes.arrayOf(PropTypes.shape(&#123; id: PropTypes.number.isRequired, title: PropTypes.string.isRequired, isCompleted: PropTypes.bool.isRequired &#125;)).isRequired, onCompletedChange: PropTypes.func &#125; render() &#123; console.log(this.props) return ( &lt;ul&gt; &#123; this.props.todos.map(todo =&gt; &#123; return( // &lt;TodoItem // key=&#123;todo.id&#125; // id=&#123;todo.id&#125; // title=&#123;todo.title&#125; // isCompleted=&#123;todo.isCompleted&#125; // /&gt; &lt;TodoItem onCompletedChange=&#123;this.props.onCompletedChange&#125; key=&#123;todo.id&#125; &#123;...todo&#125; &gt;&lt;/TodoItem&gt; ) &#125;) &#125; &lt;/ul&gt; ) &#125;&#125; src/components/TodoList/TodoItem.js123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from 'react'const noop = ()=&gt; &#123;&#125;export default class TodoItem extends Component &#123; handelCheckboxChange = () =&gt;&#123; const &#123; onCompletedChange = noop, id &#125; = this.props onCompletedChange(id) &#125; render() &#123; const &#123; isCompleted, title &#125; = this.props //下面的this.props.isCompleted可以改成isCompleted return ( &lt;li&gt; &lt;input type=\"checkbox\" checked=&#123;isCompleted&#125; onChange=&#123;this.handelCheckboxChange&#125; /&gt; &lt;span&gt;&#123;title&#125;&#123;this.props.isCompleted ? '完成' : '未完成'&#125;&lt;/span&gt; &lt;/li&gt; ) &#125;&#125;","updated":"2020-04-06T15:09:40.241Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（1）使用cra","date":"2020-03-12T16:49:11.000Z","path":"react3/","text":"https://reactjs.org react官网 react不是一个框架，而是一个库！【详细可以看我之前的文章】 版本16后架构由diff变为fiber 特点：虚拟DOM、组件化、jsx 使用cra在新的文件夹下直接 npx create-react-app react-tuts npm run eject可以查看库 （推荐使用vscode，可以安装ES7 React插件，写起来会更加方便） 因为是初学建议把src下的删除，自己一点一点新建文件学习。 新建index.js 方法一 1234567891011121314151617181920212223242526272829303132333435import React from &apos;react&apos;import ReactDOM from &apos;react-dom&apos;//const app=&lt;h1&gt;Welcome React&lt;/h1&gt;// const createApp = (props) =&gt; &#123;// return (// &lt;div&gt;// &#123;/* 只要在jsx里插入js的代码，就加一层花括号即可，注释也是js，所以这里的注释加了一层花括号 */&#125;// &lt;h1&gt;welcome &#123;props.title&#125;&lt;/h1&gt;// &lt;p&gt;优秀的&#123;props.title&#125;&lt;/p&gt;// &lt;/div&gt;// )// &#125;// const app = createApp(&#123;// title: &apos;React 16.8&apos;// &#125;)//创建组建的第一种方式，使用箭头函数，但是这个名字要大写。下面render里面直接写app,就行const App = (props) =&gt; &#123; return ( &lt;div&gt; &#123;/* 只要在jsx里插入js的代码，就加一层花括号即可，注释也是js，所以这里的注释加了一层花括号 */&#125; &lt;h1&gt;welcome &#123;props.title&#125;&lt;/h1&gt; &lt;p&gt;优秀的&#123;props.title&#125;&lt;/p&gt; &lt;/div&gt; )&#125;ReactDOM.render( &lt;App title=&quot;2020&quot; /&gt;, document.querySelector(&apos;#root&apos;)) 方法二 12345678910111213141516171819202122232425262728import React from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;//定义组建的第二种方式，使用类继承React.Componentclass App extends React.Component&#123; render () &#123; console.log(this.props) return ( &lt;div&gt; &lt;h1&gt;类组件继承&lt;/h1&gt; &lt;p&gt;&#123;this.props.desc&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;//类组件渲染的原理// const app = new App(&#123;// desc: &apos;类组件是继承React.Component&apos;// &#125;).render//render是react dom提供的方法，通常只会用一次render( &lt;App desc=&quot;类组件是继承React.Component&quot; /&gt;, document.querySelector(&apos;#root&apos;)) 方法三（jsx原理） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import React,&#123; Component &#125; from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;// 表示一个虚拟DOM树的方式// const appVDom = &#123;// tag: &apos;div&apos;,// attrs: &#123;// className: &apos;app&apos;,// id: &apos;appRoot&apos;// &#125;,// children: [// &#123;// tag: &apos;h1&apos;,// attrs:&#123;// className: &apos;title&apos;// &#125;,// children: [// &apos;JSX原理&apos;// ]// &#125;,&#123;// tag: &apos;p&apos;,// attrs: null,// children: [// &apos;类组件是继承React.Component的&apos;// ]// &#125;// ]// &#125;// 所以react在真正的渲染的时候会把之前的代码编译成这样运行，这里的代码就是合法的js代码class App extends React.Component&#123; render () &#123; return ( //React.createElement是一个方法，用于创建元素，可以有很多的参数，但前两个是固定的 //第一个可以理解为标签名 //第二个可以理解为标签的属性 //剩下的，就继续写更多的子元素 React.createElement( &apos;div&apos;, &#123; className: &apos;app&apos;, id: &apos;appRoot&apos; &#125;, React.createElement( &apos;h1&apos;, &#123; className: &apos;title&apos; &#125;, &apos;jsx原理&apos; ), React.createElement( &apos;p&apos;, null, &apos;类组件是继承React.Component的&apos; ) ) ) &#125;&#125;render( &lt;App desc=&quot;类组件是继承React.Component&quot; /&gt;, document.querySelector(&apos;#root&apos;)) 组件中的样式 https://www.npmjs.com/package/classnames 参考官网 https://www.npmjs.com/package/styled-components 参考官网 npm i classnames -S npm i styled-components -S 123456789101112131415161718192021222324252627import React, &#123; Component &#125; from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;import classNames from &apos;classnames&apos;import styled from &apos;styled-components&apos;import &apos;./index.css&apos;const Title = styled.h1` color: #F00`class App extends Component&#123; render () &#123; const style = &#123; color: &apos;#F00&apos; &#125; return ( &lt;div&gt; &lt;h1&gt;元素中的样式&lt;/h1&gt; &lt;ol&gt; &lt;li style=&#123;style&#125;&gt;使用style内联&lt;/li&gt; &lt;li className=&quot;has-text-red&quot;&gt;使用class的方式，但是在react里class要写成className&lt;/li&gt; &lt;li className=&#123;classNames(&apos;a&apos;,&#123;&apos;b&apos;:true,&apos;c&apos;:false&#125;)&#125;&gt;要动态添加不同的className就可以使用第三方的包叫classNames,比如这个li上只有ab没有c&lt;/li&gt; &lt;Title&gt;style-components的使用&lt;/Title&gt; &lt;/ol&gt; &lt;/div&gt; ) &#125;&#125;","updated":"2020-03-29T13:32:03.938Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://lifei-2019.github.io/tags/webpack/"}]},{"title":"react-webpack基本配置（2）","date":"2020-03-07T14:45:27.000Z","path":"react2/","text":"css预处理和autoprefixernpm i less-loader less –save-dev 打包.less npm i postcss-loader autoprefixer -D 为了打包的css加前缀 webpack.config.js里module部分修改为 12345678910111213141516171819202122232425262728module: &#123; rules: [ &#123; test:/\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader' //后写的先执行,postcssloader一定要写在后面 ], exclude: /node_modules/ &#125;, &#123; test:/\\.less$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader' , &#123; loader:'less-loader', options:&#123; &#125; &#125; //和上面对比两种写法 ], exclude: /node_modules/ &#125;, ],&#125;, 创建postcss.config.js给css加前缀 123456789module.exports = &#123; plugins:[ require('autoprefixer') ]&#125; 在package.json里加入 123&quot;browserslist&quot;: [ &quot;cover 99.5%&quot;] 处理图片资源新建src/assets，放一张照片gundum.jpg。直接编译发现出错 npm i file-loader –save-dev npm install url-loader –save-dev url-loader包涵file-loader 在module的rules里添加 12345678910111213&#123; test: /\\.(png|jpe?g|gif)$/i, use: [ &#123; loader: &apos;url-loader&apos;, options: &#123; limit: 512, //小于512则放到css里，大于512以图片 name: &apos;images/[name].[ext]&apos;, publicPath: &apos;/&apos; &#125;, &#125;, ], &#125; 处理静态资源-copynpm install copy-webpack-plugin –save-dev 在webpack.config.js里的plugins里添加 1234567new CopyPlugin([ &#123; from: path.resolve(process.cwd(),&apos;src/static/&apos;), to: path.resolve(process.cwd(),&apos;dist/static/&apos;) &#125;, ]), 添加babelnpm install -D babel-loader @babel/core @babel/preset-env 在module的rules里添加 123456789101112&#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [ &apos;@babel/preset-env&apos; ] &#125; &#125;&#125; 此处要挖一个node的坑 可以建立一个test.js 1234export const add = (x,y) =&gt; &#123; console.log(x + y) console.log(`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`) //这里一定要用tab上面的反引号。&#125; 并且在index.js中引用test.js里的add 12import &#123;add&#125; from &apos;./test&apos;add(1,2) 测试完成后，复制一份webpack.config.js，分为dev和prod版本，同时修改package.json里的scripts里的路径。 这样做的目的是因为在dev版本里不需要css等静态资源的压缩。","updated":"2020-03-07T14:51:08.524Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://lifei-2019.github.io/tags/webpack/"}]},{"title":"react-webpack基本环境配置（1）","date":"2020-03-06T02:29:31.000Z","path":"react1/","text":"看官网源码很重要！！！！ www.npmjs.com npm官网 www.webpackjs.com webpack官网 入口 出口 loader 插件 npm i webpack webpack-cli -D npm i –save-dev css-loader npm i –save-dev webpack-dev-server npm i style-loader -D npm i -save-dev mini-css-extract-plugin 申请的CSS自动提取 package.json 修改scripts里 12345&quot;dev&quot;: &quot;webpack-dev-server --mode development --config scripts/webpack.config.js&quot;,&quot;build&quot;: &quot;webpack --mode production --config scripts/webpack.config.js&quot;,(dev保留代码) 默认入口是src下的index.js 这个很重要 因为如果不是index的话就会listing directory 修改webpack.config.js里的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const path = require(&apos;path&apos;)const HtmlWebPackPlugin = require(&apos;html-webpack-plugin&apos;)const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;) //创建一个插件的实例对象const htmlPlugin = new HtmlWebPackPlugin(&#123; template: &apos;public/admin.html&apos;, title: &apos;webpack&apos;, filename: &apos;index.html&apos;&#125;)// const minicssPlugin = new MiniCssExtractPlugin(&#123;// filename: &apos;static/css/[name].[chunkHash:8].css&apos;,// &#125;)两种形式module.exports = &#123; entry: &#123; index: &apos;./src/index.js&apos; &#125;, output: &#123; path: path.resolve(process.cwd(),&quot;dist&quot;), filename: &apos;static/js/[name].[hash:8].js&apos; //可以用chunkHash同一次操作每个文件都不一样 &#125;, plugins: [ htmlPlugin, new MiniCssExtractPlugin(&#123; filename: &apos;static/css/[name].[hash:8].css&apos;, &#125;) ], module: &#123; rules: [ &#123; test:/\\.css$/, use: [ MiniCssExtractPlugin.loader, &apos;css-loader&apos; //后写的先执行 ], exclude: /node_modules/ &#125;, ], &#125;, devServer: &#123; publicPath: &quot;/&quot;, progress: true, //contentBase: &quot;./dist&quot;, //服务启动在哪一个文件夹下 open: true, // 启动服务时，自动打开浏览器 port: 3000, // 端口号 hot: true, // devServer开启Hot Module Replacement的功能 与chunkhash冲突所以原先在此关闭 hotOnly: false, // 即便HMP的功能没有生效，浏览器也不能自动刷新 compress: true &#125;&#125; 运行npm run build或者npm run dev","updated":"2020-03-07T14:51:18.086Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://lifei-2019.github.io/tags/webpack/"}]},{"title":"webpack-03","date":"2020-03-03T10:28:31.000Z","path":"webpack-03/","text":"webpack-dev-server错误法则： ​ 前往项目根目录删除node_modules文件夹，然后在项目根目录路径下的终端运行”npm install”等待安装完之后，再次运行“npm run dev”，有些人的是马上就可以了，然而往往还会有人（譬如我）仍然报类似的错误，这个时候你只需要再次重复相同的操作即可，“一次不成再删再安装”！！！","updated":"2020-03-06T08:57:54.837Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"webpack","slug":"webpack","permalink":"https://lifei-2019.github.io/tags/webpack/"}]},{"title":"webpack-01","date":"2020-03-01T02:28:16.000Z","path":"webpack-01/","text":"看官网源码很重要！！！！ www.npmjs.com npm官网 www.webpackjs.com webpack官网 入口 出口 loader 插件 npm i webpack webpack-cli -D npm i –save-dev css-loader npm i –save-dev webpack-dev-server npm i style-loader -D npm i -save-dev mini-css-extract-plugin 申请的CSS自动提取 package.json 修改scripts里 12345&quot;dev&quot;: &quot;webpack-dev-server --mode development --config scripts/webpack.config.js&quot;,&quot;build&quot;: &quot;webpack --mode production --config scripts/webpack.config.js&quot;,(dev保留代码) 默认入口是src下的index.js 这个很重要 因为如果不是index的话就会listing directory 修改webpack.config.js里的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const path = require(&apos;path&apos;)const HtmlWebPackPlugin = require(&apos;html-webpack-plugin&apos;)const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;) //创建一个插件的实例对象const htmlPlugin = new HtmlWebPackPlugin(&#123; template: &apos;public/admin.html&apos;, title: &apos;webpack&apos;, filename: &apos;index.html&apos;&#125;)// const minicssPlugin = new MiniCssExtractPlugin(&#123;// filename: &apos;static/css/[name].[chunkHash:8].css&apos;,// &#125;)两种形式module.exports = &#123; entry: &#123; index: &apos;./src/index.js&apos; &#125;, output: &#123; path: path.resolve(process.cwd(),&quot;dist&quot;), filename: &apos;static/js/[name].[hash:8].js&apos; //可以用chunkHash同一次操作每个文件都不一样 &#125;, plugins: [ htmlPlugin, new MiniCssExtractPlugin(&#123; filename: &apos;static/css/[name].[hash:8].css&apos;, &#125;) ], module: &#123; rules: [ &#123; test:/\\.css$/, use: [ MiniCssExtractPlugin.loader, &apos;css-loader&apos; //后写的先执行 ], exclude: /node_modules/ &#125;, ], &#125;, devServer: &#123; publicPath: &quot;/&quot;, progress: true, //contentBase: &quot;./dist&quot;, //服务启动在哪一个文件夹下 open: true, // 启动服务时，自动打开浏览器 port: 3000, // 端口号 hot: true, // devServer开启Hot Module Replacement的功能 与chunkhash冲突所以原先在此关闭 hotOnly: false, // 即便HMP的功能没有生效，浏览器也不能自动刷新 compress: true &#125;&#125; 运行npm run build或者npm run dev","updated":"2020-03-06T08:57:43.800Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"webpack","slug":"webpack","permalink":"https://lifei-2019.github.io/tags/webpack/"}]},{"title":"国境以南","date":"2020-01-06T01:51:56.000Z","path":"国境以南/","text":"","updated":"2020-01-06T01:51:56.330Z","link":"","tags":[]},{"title":"沉默的大多数","date":"2020-01-06T01:51:31.000Z","path":"沉默的大多数/","text":"","updated":"2020-01-06T01:51:31.454Z","link":"","tags":[]},{"title":"剑桥倚天屠龙史","date":"2020-01-06T01:43:39.000Z","path":"剑桥倚天屠龙史/","text":"经历了漫长的复习周，终于有时间把之前读的书做一份书评。 先说说这本《剑桥倚天屠龙史》，源自知乎大佬推荐，其实记忆里对原著的印象已经不是很深，只记得张无忌以一己之力力克六大门派守护光明顶，然后与balabala过上了幸福的生活hhhh 这本书很合胃口的原因也正因为其各种“恶趣味”，例如将明教权利人士分为“降临派”和“拯救派”、少林的“面壁者”渡厄、渡难（此处借鉴三体）、《神圣的雕之罗曼史》（神雕侠侣）等等，可以说阅历越丰富越能get到作者的点。【此处对作者新垣平致以崇高的敬意，历史沉淀深厚，思维逻辑严谨，佩服！】 作者在考量故事时，侧重的更多是理性的政治利益和集体中对于夺权的心机，相较于原著更符合人之常情与利益争夺。好似美剧《纸牌屋》中党鞭弗兰克利用对于众议院和参议院中权利的制衡，一步步当上总统。权力是人类社会发展必然的产物，人人平等并非不可能实现，只是说在当下社会中，如《1984》里所言，位居统治阶级想的事情与位居solider想的可以说是天差地别，人类可考究的六千年历史中从独权到共和（权？），集体中的争权与争宠，已然融入到人的骨髓中，个人改变社会的欲望所对抗的不仅仅是统治阶级，也不仅是人民，而是几千年的统治经验。随着读书阅历的增长，我甚至有些佩服在中华民国诞生时生活的人们，突然告诉一个人你从小接受的教育都是错误的，是奴性的，就好似告诉你见到人行礼是错的，无论你愿不愿意都要改，也更佩服孙中山先生在改变奴性的同时给人们灌入了新的“奴性”，《走向共和》里有一幕令我印象十分深刻，在经历袁世凯复辟后，孙中山怒不可遏当下就要修改入党宣言：第一条便是要忠于他，此时好友李大钊顿时翻脸：共和象征着平等自由，如果一定要忠于您的话，您与专制有什么区别？两人说罢大打出手，最终不欢而散。其实从根本上说，两人都没错，李大钊更多的是一种读书人的思想，比较理想化，换作旧社会信息交流不那么发达时或许可以完全控制人的思想，可惜当时虽没有网络，已然有了电话，可以走出国门看世界，想要个个忠于理想，以身作则践行信仰实则难事（更不用说如今）；而孙先生也是迫不得已，自小接受的教育让他感到愤怒与震惊，一个人怎么能违背自己的信仰呢？一定是在传道时没有说的清楚明白，殊不知千人前面。","updated":"2020-03-12T08:59:59.245Z","link":"","tags":[{"name":"读书","slug":"读书","permalink":"https://lifei-2019.github.io/tags/读书/"}]},{"title":"react-04","date":"2019-12-09T12:11:09.000Z","path":"react-04/","text":"7.在项目中使用React1.运行cnpm i react react-dom -S安装包* react: 专门用于创作组件和虚拟DOM，同时组件的生命周期都在这个包里 * react-dom：专门进行DOM操作，最主要的应用场景，就是ReactDOM.render()2.在index.html里，创建容器：1&lt;div id=\"app\"&gt;&lt;app&gt;&lt;/div&gt; 3.导入包：12import React from 'react' //创建组件、虚拟DOM元素，生命周期import ReactDOM from 'react-dom' //把创建好的组件和虚拟DOM放到页面上展示 4.创建虚拟DOM元素123456789//2.创建虚拟DOM元素//参数1： 创建的元素的类型，字符串，表示元素的名称//参数2： 是一个对象或null，表示当前这个DOM元素的属性//参数3： 子节点（包括其他虚拟DOM获取文本子节点）//参数n： 其他子节点// &lt;h1 id=\"myh1\" title=\"this is h1\"&gt;&lt;/h1&gt;//const myh1 = React.cloneElement('h1',null,'这是一个大大的h1')const myh1 = React.createElement('h1',&#123;id: 'myh1',title: 'this is h1'&#125;,'这是一个大大的h1') 5.渲染：1ReactDOM.render(myh1,document.getElementById('app')) 配置webpack可以看 传送门 8.JSX语法 符合xml规范的JS语法；（语法格式上来说，要比HTML严谨） 1.启用jsx语法 安装bable插件 运行 cnpm i @babel/core babel-loader babel-plugin-transform-runtime @babel/runtime -D 运行cnpm i @babel/preset-env -D (语法) 安装能够识别转换jsx语法的包babel-preset-react （JSX变成能识别的react） 运行cnpm i @babel/preset-react -D 添加.babelrc配置文件 1234567891011&#123; &quot;presets&quot;:[ //语法 &quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot; ], &quot;plugins&quot;:[ //插件 &quot;@babel/plugin-transform-runtime&quot;, &quot;@babel/plugin-proposal-class-properties&quot; ] &#125; 2.JSX语法本质：并不是直接把jsx渲染到页面上，而是在内部转换成createElement形式再渲染的。 3.jsx中混合写入js表达式：要把js代码写在{}中 4.注释 推荐使用｛/* 这是注释 */｝ 5.为元素添加class类名： 需要用className来替代class；htmlFor替换label的for属性 6.在JSX创建DOM时，所有的节点，必须有唯一的根元素进行包裹 7.在JSX语法中，标签必须成对出现，如果是单标签要自闭和（比如&lt;hr/&gt;分割线） 编译过程&lt;就把它当作HTML编译，碰到{}就当作普通JS代码。 Tips： 用([+-/开头的上一段结尾要加分号。 React中需要把key添加给 forEach或map或for循环直接控制的元素 9.React中创建组件方法一 使用构造数。如果需要接受外界传递的数据，需要在狗在函数的参数列表中使用props来接收；必须要向外return一个合法的JSX创建的虚拟DOM； 创建组件： 1234function Hello()&#123; //return null return &lt;div&gt;Hello zujian&lt;/div&gt;&#125; 为组件传递数据 123456789101112//使用组件并未组件传递props数据&lt;Hello name=&#123;dog.name&#125; age=&#123;dog.age&#125; gender=&#123;dog.gender&#125;&gt;&lt;/Hello&gt;//在构造函数中，使用props形参，接收外界传来的数据function Hello(props)&#123; //如果在一个组件中return一个null，则表示此组件是空的，什么都不会渲染 //return null console.log(props) //props.name = 'zs' //组件中的props都是只读的，不能被重新赋值。 return &lt;div&gt;zheshige hello &lt;/div&gt;&#125; 方法二","updated":"2019-12-10T02:56:19.275Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"【踩坑】babel二三事","date":"2019-12-02T02:17:39.000Z","path":"babel/","text":"babel再次教会除了python有很多是更新后不和上一代兼容的。 写在前言：随着越来越多的人投身互联网行业，“老师”层出不穷，没有对前辈不尊敬的意思，只是每个人遇到的情况不同，很多时候更需要自己去读控制台的错误信息，而不是单纯的复制下来去百度。 昨晚在学习babel的时候，因为视屏是在去年录制的，过了一年很多配置更新了，于是参照b站视屏下面的带佬的教程，也有很多人表示方法很好用 可是到了我这里就成了 反复重装了@babel/core、@babel/preset-env、@babel/runtime、@babel/plugin-transform-runtime、@babel/preset-react，又开始报错babel-loader版本不对，应该对应@babel/core7，弄了一晚上没弄出来，@生生如弈的教程在用loader7替换8的时候babel-core的6和7同时存在也会发生冲突。 扯远了，回到正题，学习任何一个框架、语言、库，最好的方法都是先去啃它的官方文档。传送门-&gt; 建议都安装最新的版本。（哪怕和视屏教程不符，毕竟现在技术更新换代，真的很快） 简单的说，昨晚一晚上的错误在于 升级到babel7后，所有的babel-core都变成了@babel/core形式 如果硬要像上述截图中一定要使用babel-loader7不安装最新的话，那安装的所有插件都要用-形式的。 下面是我最终的配置 学前端千万不要怕麻烦！","updated":"2019-12-02T02:17:39.916Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"babel","slug":"babel","permalink":"https://lifei-2019.github.io/tags/babel/"}]},{"title":"devDependencies和dependencies的区别","date":"2019-11-30T01:45:41.000Z","path":"vscode-02/","text":"devDependencies辅助开发，用于本地环境开发。没有项目照样运行，有了更好。 12比如安装浏览器同步测试工具Browsersync它可以让浏览器实时、快速响应您的文件更改（html、js、css、sass、less等）并自动刷新页面。更重要的是 Browsersync可以同时在PC、平板、手机等设备下进项调试。这个工具是为了方便我们浏览调试的，所以有了更好没有也不影响项目的运行. dependencies核心依赖，用于用户发布环境。少了项目没法正常运行，必须要有。 npm install -D到devDependencies npm install –save到dependencies","updated":"2019-12-02T02:18:06.308Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"vscode","slug":"vscode","permalink":"https://lifei-2019.github.io/tags/vscode/"}]},{"title":"react-03","date":"2019-11-28T01:39:42.000Z","path":"react-03/","text":"DOM树的概念：一个网页呈现的过程： 1、浏览器请求服务器获取页码HTML代码 2、浏览器要先在内存中，解析DOM结构，并在浏览器内存中，渲染一棵DOM树 3、浏览器把DOM树呈现到页面上 如何实现页面按需更新？获取内存中的新旧两个DOM，进行对比，获得需要被按需更新的DOM元素 但是浏览器没有直接提供获取DOM树的API，因此无法拿到浏览器内存中的DOM树； 这需要我们手动模拟DOM树 1234&lt;div id=\"mydiv\" title=\"加油\" data-index=\"0\"&gt; 春风十里不如你 &lt;p&gt;哈哈哈&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718var div = &#123; tagName:'div' attrs:&#123; id:'mydiv', title:'努力', data-index='0' &#125;, childrens:[ '春风十里不如你', &#123; tagName:'p', attrs:&#123;&#125;, childrens:[ “哈哈哈” ] &#125; ]&#125; 虚拟DOM：框架中的概念。用JS对象的形式来模拟页面上的DOM嵌套关系，为了实现页面元素的高效更新。 diff算法 treediff：新旧两颗DOM树逐层对比 component：在进行treediff时，每一层中，组件级别的对比 如果对比前后组件类型相同，则暂时认为此组件不需要被更新； 如果对比前后组件类型不同，则需要移除旧组件，创建新组建，并追加到页面上； element diff：组件类型相同，则需要进行元素级别的对比 创建基本的webpack4.X项目1.新建文件夹，运行npm init -y初始化 2.在根目录创建src源代码目录和dist产品目录 3.在src创建index.html 4.使用npm安装 webpackcnpm i webpack webpack-cli -D * 如果用cnpm需要用`npm i cnpm -g` 此处是在项目里安装webpack，我个人觉得可以全局安装webpack毕竟很常用。 5.注意：webpack 4.x提供了约定大于配置的概念；目的是为了尽量减少配置文件的体积 * 默认约定了： * 打包的入口是：`src` -&gt;`index.js` * 打包的输出文件是：`dist` -&gt;`main.js`，可以在webpack.config.js里修改entry * 4.x中新增了mode选项（必写），可选的值为：development和production6.为了每次更新后不用重新打包，提高效率，用cnpm i webpack-dev-server -D，在package.json里添加&quot;dev&quot;: &quot;webpack-dev-server&quot;，在此打包时可以直接在控制台输入npm run dev 同时可以在地址栏输入http://localhost:8080/可以看到 ES6中的特性 chrome支持哪些，则Node.js就支持哪些。Babel支持所有。 自己踩得大坑： package.json文件的格式问题。 检查属性名称喝属性值是否都用 “”括起来； 还有最后一个依赖的末尾不需要加 “，”；以及冒号问题。 “dev”: “webpack-dev-server –open firefox（通过火狐浏览器打开） –port 3000（修改端口号） –hot –progress（过程） –compress（网络压缩） –host 127.0.0.1（域名）” 内存比磁盘存储更快，webpack-server存在内存里不显示在目录上，所以要引用的时候路径要改成”\\main.js” cnpm i html-webpack-plugin -D","updated":"2019-11-28T01:41:21.070Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"前端开发环境搭建vscode+node.js","date":"2019-11-25T04:54:21.000Z","path":"vscode-01/","text":"1.安装及环境变量配置 vscode 请到官网下载对应版本 node.js 请到官网下载对应版本 目前安装好像都自动配置环境变量，但是我尝试下载包的时候发现路径不对 发现还需要在cmd里进行如下配置 12&gt;npm config set prefix “E:\\nodejs\\node_global”&gt;npm config set cache “E:\\nodejs\\node_cache” 然后打开安装目录的node_modules\\npm\\npmrc 打开之后进行如下配置 新建NODE_PATH 1D:\\nodejs\\node_modules 在系统Path变量里添加 1D:\\nodejs\\node_modules 配置完成后可以通过安装一个集成几个翻译平台的命令行工具作测试： 注意此处的路径，这个路径是设置的全局保存的路径，如果路径不对，则是上述的npmrc没有生效。 看下效果： 2.YARN包管理器 如果说npm是皇家正统，那么yarn就是爵士大将军！yarn基于node，并且速度更快，能自动缓存你下载过的包，让你在离线、重复下载时不需要通过去网上拉取文件，直接在本地就可以安装你需要的包！并且，yarn分离的各个包的安装过程，合理排队，不产生高频请求，单个包安装失败并不影响其他包的安装，有效的重试机制等！ yarn有多个类别的包提供安装 官网下载 或者使用npm安装： 12345D:\\nodejs&gt;npm install -g yarnD:\\nodejs\\node_global\\yarnpkg -&gt; D:\\nodejs\\node_global\\node_modules\\yarn\\bin\\yarn.jsD:\\nodejs\\node_global\\yarn -&gt; D:\\nodejs\\node_global\\node_modules\\yarn\\bin\\yarn.js+ yarn@1.19.2added 1 package in 1.112s yarn的教程参照官网 3.VSCode插件之前出过 Sublime的使用教程，有兴趣的可以康康。 言归正传，开始介绍VSCode的插件。 1.Chinese（Simplified） language语言插件，vscode默认语言英语，需要安装其他语言插件；如果安装重启vscode没哟起效，在 locale.json 中添加 “locale”: “zh-cn”，即可载入中文（简体）语言包。要修改 locale.json，你可以同时按下 Ctrl+Shift+P 打开命令面板，之后输入 “config” 筛选可用命令列表，最后选择配置语言命令。 2.Auto Rename Tag 标签自动重命名（当然如果你使用的是pug语法可以忽略） 3.代码美化工具 Beautify该插件支持js、josn、css、sass和html的代码美化 css快速预览与修改工具 CSS Peek,支持css的快速跳转 如果你对思考怎么写一个css的名称很苦恼的话还可以装个IntelliSense for CSS class names in HTML插件 4.图标库 Material Icon Theme 对当前流星雨烟和后缀名进行单独匹配好看又丰富的图标 view in Browser 静态网页可以支持直接在默认浏览器预览 5.基于技术栈的插件 关于Vue、React的 vue-beautify、Vue VSCode Snippets、Vue Peek，ES7 React/Redux/GraphQL/React-Native snippets、React Native Tools等，涵盖代码美化、Vue代码补全、组件跳转预览等功能，同时你也可以安装一些UI库的代码提示补全，如vscode-element-helper、Ant Design Snippets不过这些插件并没有兼容html的语法，如果你使用了类似pug这样的语法，那么久会有很多功能受到限制！ 关于css Beautify css/sass/scss/less、language-stylus、Sass、Sass Lint、Sass Lint等根据需要选择。 关于html 非常推荐使用Pug的语法，不需要成对标签，特点明确，格式要求严格，可以让代码非常规范而且易读性很高！推荐插件，Pug (Jade) snippets。 Pug的语法简单易学，没有了尖尖角角看起来也很整洁！ 文档 关于js Quokka.js支持js文件内的部分代码直接计算并返回计算结果 JavaScript (ES6) code snippets支持最新的ES6语法，支持很多代码快捷公式。 6.代码管理插件 GitLens - Gitsupercharged、Git History 支持快速预览提交历史： 支持版本查看： 支持当前行修改记录查看： 支持修改差距对比： 安装git后自动支持一键化代码提交操作： 推荐安装 Markdown All in One插件，支持所有markdown语法，同时支持快捷键操作进行修改！ 7.Setting Sync(强推)安装后ctrl+shift+P输入Sync，选择How to configure打开网页帮助 1.登录github，在设置里开启Github Token和Github GIST ID，绑定后可以上传当前VSCode 2.重新设置同步功能参见简书Aweber用户的文章 8.vscode-icons显示文件夹图标 4.VSCode设置Ctrl + Shift + P 打开vscode命令行控制台，输入setting，可以选择进入设置(UI)界面和setting.json setting.json只会显示你更改的设置！而UI界面你得慢慢的去找！ vscode 支持安装其他软件的快捷键命令：Sublime Text（Sublime Text Keymap and Settings Importer）等，不一一列举，输入 keymap即可搜索到所有的快捷键替换插件： 最近临近考试周，先凑活着用，考完继续！","updated":"2020-03-25T03:55:25.741Z","link":"","tags":[{"name":"tools","slug":"tools","permalink":"https://lifei-2019.github.io/tags/tools/"}]},{"title":"1984|我们将会在黑暗中相见","date":"2019-11-17T12:12:24.000Z","path":"1984/","text":"《1984》给我带来的深刻意义在于他对人类社会整体意识形态的描述，1948年的乔治奥威尔所写下不是发生在1984年的预言，时至今日， 老大哥仍然在各个角落看着我们。网络警察、思想控制、学xi强国、微博上因为美色泻露国家秘密罪而被蒸发。永远都有一小撮妄图颠覆我伟大民族的坏分子。永远都是被暴徒煽动的人民群众。永远都是痛哭着扑向党啊母亲怀抱幡然悔悟的羊羔们。（以前读到这种文字我会觉得这只是愤青的煽动之词罢了，不曾想到自己也会写下这些“胡言乱语“。罪过。每个人的路各不相同，但是交流是无罪的。） 书的封面只有一句话“自由是说二加二等于四的自由。如果这是允许的，其他的一切都随之而来。” 初读第一遍时有些疑惑，二加二等于四，在我们现阶段的教育里可以算上是公理，是不需要证明的，然而读到第三部分时：“如果我想，我甚至可以让水滴悬空，什么是事实？映射到脑海里你相信的是事实”； 古人云：以史为鉴，可以知兴替。中华民族近代史被侵略的历史告诉我们，我们的土地可能被侵略，我们的人民可能被奴役，我们的文化可能被遮盖，但是爱国精神不止，你可以剥夺我的自由，剥夺我去追求美好，但是有些东西你剥夺不了，比如我爱一个人、爱一个国家的心，然而《1984》好像一记响亮的巴掌把我打醒，当温斯顿被戴上装满他最怕的老鼠的头套后，他嘶吼着“做什么都可以，让它们去咬查莉娅”成了压垮读者心里的最后一棵稻草。 再次见到查莉娅时，老大哥没有监视这场会面，或许说，不需要监视，说过的话已经在他们的心中划开一道口子，流血不止。 除此之外，此处的“史”是历史学家所说的历史，是唐朝贞观之治后又一个太平盛世的“史”，但是《1984》里作者用冷冰冰的文字发表了他的观点“谁控制了过去，谁就控制了未来；谁控制了现在，谁就控制了过去”（感谢github不会被百度seo）在下不过一届皮民，舞台留给各位自己脑补。 书中还有贯穿始终的一句话： “战争即是和平” “自由即是奴役” “无知即是力量” 第一句话与之前的《战争之王》中的情节相似， 电影结尾，尤里被正义的杰克抓住后，只是冷静的讲了一番话，告诉他自己的存在是一个必须，即使是那些看上去很正义的人也需要他的工作。因为这件事，总要有人去做。【看了别人的书评还有另一种解释： 不断塑造外敌来转化内部矛盾。】 第二句话可以用《动物庄园》里的一句话来解释： 激烈的批评被消灭了，他们再来消灭温和的批评，等到温和的批评都没有的时候，他们就消灭那些保持独立不赞美的人了，到最后，如果鼓掌不起劲，都会被消灭。 自由其实只是一种希望，一个指引我们一直向更美好的生活奋斗的目标。正因为它一直不能完全实现，所以它能一直吸引我们前进。从这点来看，我们是被自由奴役了，当然，这种奴役的身份也是大家都欣喜担当的。 第三句话：无知则易教化，民顺则邦兴。 这本书没在中国被禁，确实应了查建英说的，党的身段比她哥哥想象的灵活多了，老大哥绝不总板着脸，他偶尔流露出的慈爱眼光我们望一眼就会痛哭流涕，这关怀像求雨得逞一样让我们对天愈加崇拜和无法抗拒，忘记对自由的渴望曾经带来同样强烈的情绪反应。所以恐怕感动是不够的，什么时候，就会有一颗子弹秘而不宣地射中我们充满光明幻想的后脑勺。所以，或者吧。要么变成一个吃喝拉撒性欲充足的动物，要么就像豆瓣网友说的那样，多一个人看Orwell，多一份自由的保障，多一个为我们无从选择的命运而痛苦的人。“她很清楚的知道自己在遭遇什么——同我一样清楚的知道——在严寒中跪在贫民窟后院的脏石块上捅一条发臭的排水管，是一种多么不幸的命运”。所以，不论未来或者将来将怎么样，至少我们能够清楚地知道自己在遭遇什么，我们的命运带领我们而去的并不都是我们的未来。 最后感谢民族团结、国家独立，能让我们有机会用汉语交流，哪怕只是“新话”，能够与人沟通是一件多么美好的事。 下一本想看《狂热分子》，也想看《魔山》，算了还是好好弄期末考试好了。","updated":"2019-11-25T02:06:56.825Z","link":"","tags":[{"name":"读书","slug":"读书","permalink":"https://lifei-2019.github.io/tags/读书/"}]},{"title":"github-api（v3）","date":"2019-11-12T02:54:54.000Z","path":"github-api/","text":"分享几个常用的github-api。 1.查询项目最新提交信息 以我的github项目为例，api完整链接如下。 https://api.github.com/repos/lifei-2019/react-demos/commits?per_page=10&amp;sha=master 可选参数 per_page 查询条数 sha 查询分支 想要查询你自己的项目，只需将lifei-2019替换成你要查询的用户id，react-demos替换成你要查询的该用户的项目即可。 2.查询用户基本信息依旧是以我的github账户为例，可查看用户的详细信息，返回信息如下json。 https://api.github.com/users/lifei-2019 123456789101112131415161718192021222324252627282930313233&#123; &quot;login&quot;: &quot;lifei-2019&quot;, &quot;id&quot;: 54241633, &quot;node_id&quot;: &quot;MDQ6VXNlcjU0MjQxNjMz&quot;, &quot;avatar_url&quot;: &quot;https://avatars1.githubusercontent.com/u/54241633?v=4&quot;, &quot;gravatar_id&quot;: &quot;&quot;, &quot;url&quot;: &quot;https://api.github.com/users/lifei-2019&quot;, &quot;html_url&quot;: &quot;https://github.com/lifei-2019&quot;, &quot;followers_url&quot;: &quot;https://api.github.com/users/lifei-2019/followers&quot;, &quot;following_url&quot;: &quot;https://api.github.com/users/lifei-2019/following&#123;/other_user&#125;&quot;, &quot;gists_url&quot;: &quot;https://api.github.com/users/lifei-2019/gists&#123;/gist_id&#125;&quot;, &quot;starred_url&quot;: &quot;https://api.github.com/users/lifei-2019/starred&#123;/owner&#125;&#123;/repo&#125;&quot;, &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/lifei-2019/subscriptions&quot;, &quot;organizations_url&quot;: &quot;https://api.github.com/users/lifei-2019/orgs&quot;, &quot;repos_url&quot;: &quot;https://api.github.com/users/lifei-2019/repos&quot;, &quot;events_url&quot;: &quot;https://api.github.com/users/lifei-2019/events&#123;/privacy&#125;&quot;, &quot;received_events_url&quot;: &quot;https://api.github.com/users/lifei-2019/received_events&quot;, &quot;type&quot;: &quot;User&quot;, &quot;site_admin&quot;: false, &quot;name&quot;: &quot;LF&quot;, &quot;company&quot;: null, &quot;blog&quot;: &quot;https://lifei-2019.github.io/&quot;, &quot;location&quot;: null, &quot;email&quot;: null, &quot;hireable&quot;: null, &quot;bio&quot;: &quot;不带评论的观察是人类智力的最高形式&quot;, &quot;public_repos&quot;: 12, &quot;public_gists&quot;: 0, &quot;followers&quot;: 2, &quot;following&quot;: 2, &quot;created_at&quot;: &quot;2019-08-18T14:23:37Z&quot;, &quot;updated_at&quot;: &quot;2019-11-08T06:00:44Z&quot;&#125; 3.获取用户followers列表https://api.github.com/users/lifei-2019/followers 想查看其他用户的只需将lifei-2019替换成你需要查看的用户id即可。 4.获取用户following列表https://api.github.com/users/lifei-2019/following 想查看其他用户的只需将lifei-2019替换成你需要查看的用户id即可。 5.获取用户stared项目列表https://api.github.com/users/lifei-2019/starred 想查看其他用户的只需将lifei-2019替换成你需要查看的用户id即可。 6.列出观察者返回一个数组，包含每一个对该项目watch的用户列表。 1.语法GET /repos/:owner/:repo/subscribers 完整api为https://api.github.com拼接上文档中给出的url。 2.关键参数:owner 替换为项目作者 :repo 替换为项目名称 3.demohttps://api.github.com/repos/lifei-2019/react-demos/subscribers 7.其他SolomonXie的文章","updated":"2019-11-12T04:39:05.588Z","link":"","tags":[{"name":"github","slug":"github","permalink":"https://lifei-2019.github.io/tags/github/"}]},{"title":"hexo 常见问题汇总","date":"2019-11-12T02:53:21.000Z","path":"hexo4/","text":"泄露（Escape）内容Hexo 使用 Nunjucks 来解析文章（旧版本使用 Swig，两者语法类似），内容若包含 `{{ }}` 或 `{% %}` 可能导致解析错误，您可以用 raw 标签包裹来避免潜在问题发生。 1&#123;% raw %&#125;Hello &#123;&#123; sensitive &#125;&#125;&#123;% endraw %&#125; 更多可查看hexo文档","updated":"2019-11-12T04:39:42.904Z","link":"","tags":[{"name":"hexo","slug":"hexo","permalink":"https://lifei-2019.github.io/tags/hexo/"}]},{"title":"react_this","date":"2019-11-11T11:37:28.000Z","path":"react-this/","text":"函数的this指向是在进入执行上下文的时候才确定的，它并不是静态绑定的。 12345678910var x = 1;var obj = &#123; x: 2, getValue: function() &#123; return this.x &#125;&#125;var fn = obj.getValuefn() // 1obj.getValue() // 2 但是使用bind,可以返回一个新的函数，当这个函数调用的时候this指向的是传入值，例如把上一段代码稍加修改。 12var fn = obj.getValue.bind(obj)fn() // 2 在react中这样写，是为了让子组件在调用这个函数的时候this是指向父组件的。","updated":"2019-11-11T13:35:59.284Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react_constructor()、super()、super(props)","date":"2019-11-11T11:20:02.000Z","path":"react-constructor函数/","text":"使用es6的class定义react组件时，经常会看到下面的代码： 1234constructor(props) &#123; super(props); ...&#125; 通常会有两个疑问： 必须要调用super()吗？ super()与super(props)有什么不同? 一、第一个问题先说结论： 只要存在constructor就要调用super() 但是，不是每个react组件都需要constructor，比如下面的代码是可以正常运行的： 1234567class App extends React.Component &#123; render() &#123; return ( &lt;h1&gt;&#123;this.props.text&#125;&lt;/h1&gt; ); &#125;&#125; 很多时候需要在constructor中访问this： 123constructor() &#123; console.log(this); --- Syntax error: 'this' is not allowed before super()&#125; 这是因为当没有调用super()时，this还没有被初始化，所以不能使用；那如果我不使用this呢？ 123constructor() &#123;--- Syntax error: missing super() call in constructor&#125; es6会在语法层面强制你调用super()，所以得到的结论就是：只要存在constructor就必须调用super() 二、第二个问题第一个问题已经回答了什么时候调用super()，那什么时候必须要调用super(props)呢？先说结论： 当需要在constructor中访问this.props的情况下 从上面的代码可以看出，即使没有constructor，依然可以在render中使用this.props，这是因为react在初始化class后，会将props自动设置到this中，所以在任何地方都可以直接访问this.props，除了一个地方：constructor 1234constructor(props) &#123; super(); console.log(this.props); --- undefined&#125; 所以当你需要在constructor中访问this.props时，才需要设置super(props) 转自简书带佬","updated":"2019-11-12T04:57:03.496Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react_02","date":"2019-11-11T10:47:05.000Z","path":"react-02/","text":"7.获取DOM代码根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff 。 组件 MyComponent 的子节点有一个文本输入框，用于用户输入，这时就必须获取真实的DOM节点，虚拟DOM是拿不到用户输入的数据的为了做到这一点，文本输入框必须有一个ref属性，然后this.ref.[refName]就会返回这个真实的DOM节点。 由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。 代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。 12345678910111213141516171819202122232425262728293031323334&lt;div id=\"example\"&gt;&lt;/div&gt;&lt;script type=\"text/babel\"&gt; class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.myTextInput = React.createRef(); this.handleMouseOver = this.handleMouseOver.bind(this) //我这里改成了当鼠标移到元素上和从鼠标上移开，ryf老师是点击元素 this.handleMouseOut = this.handleMouseOut.bind(this) &#125; handleMouseOver() &#123; this.myTextInput.current.focus(); &#125; handleMouseOut()&#123; this.myTextInput.current.blur(); &#125; //上面相当于js部分 //下面相当于虚拟的html render() &#123; return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;this.myTextInput&#125; /&gt; &lt;input type=\"button\" value=\"Focus the text input\" onMouseOver=&#123;this.handleMouseOver&#125; onMouseOut=&#123;this.handleMouseOut&#125; /&gt; &lt;/div&gt; ); &#125; &#125; //通过下面的render由虚拟的变成网页能够显示的html界面 ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById('example') ); 关于constructor()函数可以看我的另一篇文章 关于为什么要用this可以看我的另一篇文章 React 组件支持很多事件，除了 Click 事件以外，还有 KeyDown 、Copy、Scroll 等，完整的事件清单请查看官方文档。 8.this.state 状态改变渲染页面 上面代码是一个LikeButton组件，构造器函数定义 state 状态，这是一个对象，可以通过this.state属性读取，当用户点击组件时，状态改变，this.setState() 方法就修改状态值，每次修改以后，自动调用this.render方法，再次渲染组件。 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。 一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 class LikeButton extends React.Component { // 构造器创建 state constructor(props) { super(props) this.state = {liked: false} // p标签上的 方法 this.handleClick = this.handleClick.bind(this) } handleClick(event) { // state 下的 liked 状态改变 this.setState({ liked: !this.state.liked }); } render() { var text = this.state.liked ? &apos;like&apos; : &apos;haven\\&apos;t liked&apos;; return ( &lt;p onClick={this.handleClick}&gt; You {text} this. Click to toggle. &lt;/p&gt; ); } } ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById(&apos;example&apos;) ); 9.表格this.state描述组件的状态，并通过用户交互进行变异，以及this.props描述组件的属性，并且是稳定的和不可变的。 除此之外，value表单组件的属性(如、和)不受任何用户输入的影响。如果要访问或更新响应用户输入的值，可以使用onChange事件。 class Input extends React.Component { constructor(props) { super(props) this.state = {value: &apos;Hello!&apos;} this.handleChange = this.handleChange.bind(this) } handleChange(event) { this.setState({value: event.target.value}); } render() { var value = this.state.value; return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt; &lt;p&gt;{value}&lt;/p&gt; &lt;/div&gt; ); } } ReactDOM.render( &lt;Input/&gt;, document.getElementById(&apos;example&apos;) ); 10.组件的生命周期组件的生命周期分为三个状态： Mounting: 一插入真实的DOM Updating: 正在被重新渲染 Unmounting: 以移除真实 DOM React为每一个状态都提供了两种处理函数，will函数在进入状态之前调用，did函数在进入状态之后调用，三种状态共计五种处理函数。 componentWillMount() 组件挂载之前调用，render()之前调用 componentDidMount() DOM渲染完成后调用，可以用于加载后台数据 componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) 组件更新时触发该方法，初始渲染不调用 componentWillUnmount() 组件被销毁之前一般用于清理工作（定时器timer、网络请求、订阅事件） 此外，React 还提供两种特殊状态的处理函数。 1. componentWillReceiveProps(object nextProps) ：已加载组件收到新的参数时调用 2. shouldComponentUpdate(object nextProps, object nextState) ：组件判断是否重新渲染时调用 1234567891011121314151617181920212223242526272829303132class Hello extends React.Component &#123;constructor(props) &#123; super(props) this.state = &#123;opacity: 1.0&#125;;&#125;// 已插入真实 DOM 函数在进入状态之后调用componentDidMount() &#123; this.timer = setInterval(function () &#123; var opacity = this.state.opacity; // 将状态机的变量赋值给 opacity opacity -= .05; //以0.05为单位递减 if (opacity &lt; 0.1) &#123; opacity = 1.0; //重置opacity&#125;this.setState(&#123; opacity: opacity //重新赋值给opacity&#125;); &#125;.bind(this), 100); //定时器对应上面的setInterval&#125; render() &#123; return ( &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt; Hello &#123;this.props.name&#125; &lt;/div&gt; );&#125;&#125;ReactDOM.render( &lt;Hello name=&quot;world&quot;/&gt;, document.getElementById(&apos;example&apos;)); 如果不使用bind()而直接调用 setInterval 中定义的匿名函数，函数内部的 this 是指向 window 对象的。匿名函数内部显然需要 this 指向当前组件，才能读取state属性/调用setState()方法，所以使用bind()为匿名函数绑定当前执行环境的 this，即当前组件。 为组件添加外部css样式时，类名应该写成className而不是class;添加内部样式时，应该是 style={{opacity: this.state.opacity}}{% end%} 而不是{% raw %} style=\"opacity:{this.state.opacity};\"{% endraw %} 。 bind() this 11.Ajax 如何从服务器或API提供程序获取组件的数据？的事件处理程序中使用ajax获取数据。componentDidMount…当服务器响应到达时，使用this.setState()以触发UI的重新呈现。 class UserGist extends React.Component { constructor(props) { super(props) this.state = { username: &apos;&apos;, lastGistUrl: &apos;&apos; }; } componentDidMount() { $.get(this.props.source, function(result) { var lastGist = result[0]; this.setState({ username: lastGist.owner.login, lastGistUrl: lastGist.html_url }); }.bind(this)); } render() { return ( &lt;div&gt; {this.state.username}&apos;s last gist is &lt;a href={this.state.lastGistUrl}&gt;here&lt;/a&gt;. &lt;/div&gt; ); } } ReactDOM.render( &lt;UserGist source=&quot;https://api.github.com/users/lifei-2019/starred&quot; /&gt;, //看最后看的代码段 document.getElementById(&apos;example&apos;) );github的常用接口api","updated":"2019-11-12T02:44:24.596Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"ClustrMaps|支持生成访客地图的统计工具","date":"2019-11-11T10:27:32.000Z","path":"hexo3/","text":"如上图所示， ClustrMaps 是一个基于网站流量统计与数据分析的站点，其特色是可以按照你的网站访问者国家来分别计数，关键它还能生成一个标有你的访问者地理位置的世界地图，支持嵌入到网站上展示。","updated":"2019-11-11T10:42:00.715Z","link":"","tags":[{"name":"hexo","slug":"hexo","permalink":"https://lifei-2019.github.io/tags/hexo/"}]},{"title":"react_01","date":"2019-11-09T13:12:36.000Z","path":"react-01/","text":"本文主要看阮一峰老师的博客：react入门示例教程 亲测教程中的部分功能在react16后失效（除了python还有不向下兼容的….），欢迎交流，希望大家少走些弯路。 自己学习过程中做的react实例 一、react网页源码1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../build/react.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/browser.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"example\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; // ** Our code goes here! ** &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1️⃣body可加入script标签，但type属性为text/babel，因为react是JSX，html和css都可以写在js里。 2️⃣用了三个库：react.js、react-dom.js、Browser.js，react.js核心库，react-dom提供DOM(文档对象类型Document Object Moodel)相关，Browser是把JSX转为JS（但消耗时间）。 1$ babel src --out-dir build 把src目录里的js进行转码后放在build目录。 二、ReactDOM.render()把模版转为HTML，插入DOM结点。（关于DOM可先看Java Script DOM编程艺术，讲的很基础） 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example')); ReactDOM.render(参数一, 参数二) 参数一：被渲染的标签 参数二：被插入的父元素 三、JSX语法123456789101112var names = ['Alice', 'Emily', 'Kate'];ReactDOM.render( &lt;div&gt; &#123; names.map(function (name) &#123; \\\\ map函数：遍历数组 ，此处会显示三行 return &lt;div&gt;Hello, &#123;name&#125;!&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById('example')); 在参数一中，{}中可以键入javascript代码，可以用来遍历数组，对象等；在其中可以使用return来返回标签。 JSX 的基本语法规则： 遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析； 遇到代码块（以 { 开头），就用 JavaScript 规则解析。 数组直接写在{}中就能遍历： 12345678910var arr = [&lt;h1&gt;Hello world&lt;/h1&gt;,&lt;h2&gt;React is awesome&lt;/h2&gt;,];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('example') \\\\找到id为example的元素节点); 四、组件React允许用React.createClass方法自己封装组件，然后像插入普通HTML元素节点一样在网页中插入。 12345678910var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;HelloMessage name=\"John\" /&gt;, document.getElementById('example')); 此时，HelloMessage就是一个组件类。 123456789var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt; Hello &#123;this.props.name&#125; &lt;/h1&gt;&lt;p&gt; some text &lt;/p&gt;; &#125;&#125;); 上述代码是错的，因为return了两个元素节点h1和p 组件类的第一个字母必须大写 组件类只能包含一个顶层标签 组件类必须有 / 结尾 所有组件类都必须有自己的 render 方法，用于输出组件 五、this.props.childrenthis.props.children：表示组件的所有子节点。（关于props） 把NotesList下的所有子节点渲染到 ol li中 12345678910111213141516171819202122232425262728&lt;div id=\"example\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; class NotesList extends React.Component &#123; render() &#123; return ( &lt;ol&gt; //有序序列表 &#123; React.Children.map (this.props.children , function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ol&gt; ); &#125; &#125; // this.props.children 表示组件上的子节点 ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;45645&lt;/span&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.getElementById('example') ); &lt;/script&gt; 上面的NoteList组件有三个span子节点 this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。 React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。更多的 React.Children 的方法，请参考官方文档。 6、PropTypes组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求 指定组件中的属性类型 如下代码验证组件实例属性是否符合要求 123456789var MyTitle = React.createClass(&#123; propTypes: &#123; title: React.PropTypes.string.isRequired, &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125;&#125;); 如下代码设置组件属性的默认值 12345678910111213141516var MyTitle = React.createClass(&#123; getDefaultProps : function () &#123; return &#123; title : 'Hello World' &#125;; &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;MyTitle /&gt;, document.body); React版本16以后不再支持createclass以及其内部的getDefaultProps！要改用下面的.component以及defaultProps方法！ 123456789101112131415161718&lt;div id=\"example\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var data = 123; class MyTitle extends React.Component &#123; static propTypes = &#123; title: PropTypes.string.isRequired, // title的文本节点必须是字符串 &#125;， render() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125; &#125; ReactDOM.render( &lt;MyTitle title=&#123;data&#125; /&gt; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;, document.getElementById('example') ); &lt;/script&gt; 在浏览器中按F12看到开发者工具里因为默认title值是数字而报错。 加油。","updated":"2019-11-11T10:45:05.051Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"负能量","date":"2019-11-09T09:00:52.000Z","path":"down/","text":"人生就像玻璃窗上的苍蝇，前途一片光明，却找不到出路。","updated":"2019-11-12T04:56:52.954Z","link":"","tags":[]},{"title":"hexo中插入bilibili视频","date":"2019-11-09T08:38:27.000Z","path":"hexo2/","text":"1.原理使用iframe标签，更改其中src的aid和cid， 使其对应要插入的视频，即可在文章内插入bilibili视频 2.获取cid​ aid即为视频的av号，cid有两种获取方式，一是通过bilibili分享按钮直接可以看到嵌入代码，将代码内的cid复制即可（推荐），二是通过网页源代码查看（之前没有注意到到还能直接从分享按钮里看）。 这里简单介绍一下通过网页源代码看的方法： 右键，查看网页源代码（不能F12，F12看不到cid） ctrl+f 搜索cid，即可找到对应的cid。 3.插入方法使用tinymce编辑器，选择编辑html原代码，插入以下代码即可 12&lt;iframe src=\"//player.bilibili.com/player.html?aid=对应aid&amp;amp;cid=对应cid&amp;amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"95%\" height=\"450\"&gt;&lt;/iframe&gt; 4.示例示例使用《我的英雄学院》。所谓英雄，就是无论何时都能打破困境之人，希望每个人能成为自己的英雄！","updated":"2019-11-09T10:10:26.844Z","link":"","tags":[{"name":"hexo","slug":"hexo","permalink":"https://lifei-2019.github.io/tags/hexo/"}]},{"title":"前端概念","date":"2019-11-08T06:38:15.000Z","path":"前端概念/","text":"昨天看了知乎@陈龙的一篇文章，对前端有了一个系统化的认识。 首先，必须分清六个基本概念：Library，Toolkit，Framework，Design，Boilerplate，Scaffolding。在很多人（包括我）脑子里都只有框架这一个概念，啥都是框架。 Library就是库，而且分为两类。 一类是方法库，用来实现特定需求的一组API集合。最常见的就是jQuery，它是一系列操作DOM和AJAX的API组成的方法库。除了jQuery，还有早期的Prototype，Dojo，Mootools，后面这三个在当时也被称为三大前端工具库。 操作Data的有UnderScore和Lodash，操作Event的有现在流行的RxJS，他们都是Library，在需要的时候，正确调用他们提供的方法就可以。 一类是UI组件库，满足特定业务需要的高可复用的常见UI组件集合。例如Ant Design of React/Ant Design of Angular(NG-ZORRO)，Element UI，LayUI，EasyUI。早期的Yahoo UI，Extjs，jQuery UI。 Bootstrap是一个Toolkit(工具箱)，给你提供创建现代响应式页面所需要的工具，包含一套完整的响应式CSS类库，字体，同时还有一套很完整的UI组件。只是这些组件原生是用jQuery写的，不适用于现在主流的前端。所以产生了很多衍生UI库，例如Angular实现的ng-bootstrap和ngx-bootstrap，React实现的react-bootstrap，Vue实现的bootstrap-vue。 Framework是框架，用来构建一个应用的主体结构。然后你在这个主体结构上添砖加瓦，实现自己的需求。Web服务器端的框架基本实现的都是MVC设计模式，你在Model、View、Controller层分别去添加代码。Web前端，Angular(以及它的前身Angularjs)实现的都是MVP模式，是Model、View、Presenter三层。老一辈的其他前端框架，例如Backbone、Ember，实现的是所谓MVVM。 当前所谓的前端三大框架，只有Angular算作严格意义上的Framework，而且是一个Opinionated Framework，其他两个不算。 Vue官网首页最大的字说： The ProgressiveJavaScript Framework 但是，在Guide页面说： Vue (pronounced /vjuː/, like view) is a progressive framework for building user interfaces.The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. 所以，Vue(法文View的意思)本质上是一个解决View层的Library React官网就没这么遮遮掩掩了，首页最大的字： A JavaScript library for building user interfaces 所以，Vue和React都是关注于View这一层的Library。也正因如此，用React或Vue搭建项目就还需要一系列其他周边库做补充支持。例如React本身没有实现路由导航，就需要react-router。等等，还有很多，俗称全家桶。 Design是设计语言。当说到xxx Design的时候，前端应该经常听到Material Design和Ant Design，分别是Google和阿里的推出的两种前端UI设计语言。 设计语言(或者说设计风格)，是指导UI设计需要遵循的一些约束。这些约束包括：色彩、布局、层次、交互反馈等等。就像我们说建筑，有哥特式的、中国古典式的、希腊式的。买衣服，我们知道韩版、英伦风格、波斯米亚风格。 Design和具体实现是松耦合的，没有直接必然关联。规范只规定这种设计语言的风格是什么样子的，从来不指定具体实现，谁都可以实现。就是Specification和Implementation的关系。就好像中国古典建筑，古时候多用木材，现在用钢筋混凝土一样可以建造出同样的风格。就好像程序员喜欢的格子衫(一种风格)，可以用法兰绒的，也可以棉麻的。 Material Design起初是指导Andoid界面的，但是也存在很多Web UI的实现，例如基于Bootstrap开源的有Bootstrap Material。 Ant Design也是一样。只是最开始只有React的实现Ant Design of React。阿里团队后期发布了Angular的实现Ant Design of Angular(NG-ZORRO)。 Boilerplate是模板、样板的意思。一般程序员很少了解这个概念，而是Library和Framework知道的多一些。上面说过了，当你用React开发的时候，React本身不能满足全部需求，就需要周边辅助的项目。如何把这些全家桶用最佳实践(Best Practice)的方式组合在一起？就需要有人给一个样板，Ant Design Pro就产生了。所以Ant Design是设计语言、Ant Design of React是遵循这门设计语言并且用React实现的UI组件库，Ant Design Pro就是模板。 Scaffolding是脚手架工具。前端的脚手架工具一般都是用cli提供的，cli是(Command Line Interface的缩写)，不是Client的前三个字母。例如ng-cli, create-react-app, vue cli，以及用Yeoman(YO)做出来的许多generator。 脚手架这个词看似陌生，但其实大家都见过。就是建筑工地大楼施工时候外面那一层钢管搭建的架子，还有很多绿色的网起到保护作用。Scaffolding的作用就是辅助你快速搭建项目。但是Scaffolding不是最终成果物的一部分！ 不管用了jQuery也好，用了Vue也好，用了Bootstrap也好，这些东西的代码都会成为你最终编译成果的一部分，而Scaffolding不会。所以大楼建成以后，外面的脚手架是要被拆掉的，不会和大楼一起交付给业主！","updated":"2019-11-09T09:06:56.695Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"}]},{"title":"Stay hungry,Stay foolish.【持续更新】","date":"2019-11-05T01:10:39.000Z","path":"sentences/","text":"《致橡树》我如果爱你——绝不象攀援的凌霄花，借你的高枝炫耀自己；我如果爱你——绝不学痴情的鸟儿，为绿荫重复单调的歌曲；也不止象泉源，常年送来清凉的慰藉；也不止象险峰，增加你的高度，衬托你的威仪。甚至日光。甚至春雨。不，这些都还不够！ 我必须是你近旁的一株木棉，作为树的形象和你站在一起。根，紧握在地下，叶，相触在云里。每一阵风过，我们都互相致意，但没有人，听懂我们的言语。你有你的铜枝铁干，象刀，象剑，也象戟；我有我红硕的花朵，象沉重的叹息，又象英勇的火炬。我们分担寒潮、风雷、霹雳；我们共享雾霭、流岚、虹霓。仿佛永远分离，却又终身相依。这才是伟大的爱情，坚贞就在这里：爱——不仅爱你伟岸的身躯，也爱你坚持的位置，足下的土地。 《春风十里不如你》美国著名摇滚诗人鲍勃·迪伦曾经说过一句话，这个世界上只有两种人，一种是还幸存的，一种是已迷失的，我们的身体虽然被囚禁在这里，可是我们的灵魂永远不会迷失。同学们，请不要再想家了，让我们继续发扬摇滚精神，那些无法将我们消灭的，会使我们变得更加强大 学习时的痛苦是暂时的 未学到的痛苦是终生的。 《海边的卡夫卡》我告诉我喜欢你，并不是一定要和你在一 起，只是希望今后的你，在遭遇人生低谷的时候，不要灰心，至少曾经有人被你的魅力所吸引，曾经是，以后也会是。 《挪威的森林》不要同情自己，同情自己是卑劣懦夫干的勾当。 每个人都有属于自己的一片森林，也许我们从来不曾去过，但它一直在那里，总会在那里。迷失的人迷失了，相逢的人会再相逢。 哪里会有人喜欢孤独，不过是不喜欢失望罢了。 死并非生的对立面，而作为生的一部分永存。 少年时我们追求激情，成熟后却迷恋平庸，在我们寻找，伤害，背离之后，还能一如既往的相信爱情，这是一种勇气。 如果你掉进了黑暗里，你能做的，不过是静心等待，直到你的双眼适应黑暗。 最最喜欢你，像喜欢春天的熊一样。春天的原野里，你一个人正走着，对面走来一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说到：‘你好，小姐，和我一块打滚玩好么？’接着，你就和小熊抱在一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一大天。你说棒不棒？” 喜欢到全世界森林里的老虎都融化成黄油。 我喜欢你，如同全世界的细雨落在全世界的草坪上 不要因为寂寞随便牵手，然后依赖上，人自由自在多好，纵使漂泊，那种经历也好过牢狱般的生活，所以我刻意不让自己对网络太依赖，对失去的人也保持淡然的态度，数千个擦肩而过中，你给谁机会谁就和你有缘分，纵没有甲，也会有乙。 绅士就是：所作的，不是自己想做之事，而是自己应做之事。 饼干罐不是装有各种各样的饼干，喜欢的和不大喜欢的都在里面吗？如果先一个劲儿挑你喜欢的吃，那么剩下的就全是不大喜欢的。每次遇到麻烦我就总这样想：先把这个应付过去，往下就好办了。人生就是饼干罐 People are strange when you are a stranger. 这所大学里的男男女女差不多都是江湖骗子，都怕自己不学无术的真面目被人看穿，惶惶不可终日。于是都看同样的书，喷涂同样的话，都听约翰·科尔特伦，看帕索里尼的电影，还觉得津津有味。 日常生活中有什么用处到谈不上多少，不过我想，与其说具体有什么用处，莫如说它是一种训练，训练我们更加系统的把握事物，就像乌鸦往树洞里贮藏玻璃片一样。 1984人类社会长久以来一直可以分为3个阶层的人，上等人，中等人，下等人。上等人统治社会，中等人管理社会，下等人被控制。上等人推崇的思想无不是稳定，安于受苦，随遇而安。而中等人为了推翻上等人的统治，往往喊出自由、民主的口号，博取下等人的同情。 谁控制了过去，谁就控制了未来；谁控制了现在，谁就控制了过去 “战争即是和平” “自由即是奴役” “无知即是力量” 其他白月光和朱砂痣。从张爱玲的比喻中我想到林徽因和陆小曼，对于徐志摩而言，能够和他在精神层面交流互通的也就是林徽因吧？而在红尘中行走，风流成绝色的陆小曼，是不是更带给他新鲜生动的感觉呢？而这两种往往是不可兼得，只能取其一而已。总有一个要退出，巧的是，在渡边和徐志摩的人生剪影中，留下的都是朱砂痣。 “在德国，起初他们追杀共产主义者，我没有说话──因为我不是共产主义者；接著他们追杀犹太人，我没有说话──因为我不是犹太人； 后来他们追杀工会成员，我没有说话──因为我不是工会成员； 此后他们追杀天主教徒，我没有说话── 因为我是新教教徒；最后他们奔我而来，却再也没有人站起来为我说话了。”这是美国波士顿犹太人屠杀纪念碑上铭刻着的一首短诗，作者是一位叫马丁·尼莫拉(Martin Niemoller)的德国新教牧师。","updated":"2019-11-17T13:30:42.698Z","link":"","tags":[{"name":"读书","slug":"读书","permalink":"https://lifei-2019.github.io/tags/读书/"}]},{"title":"挪威的森林","date":"2019-11-04T08:40:50.000Z","path":"挪威的森林/","text":"连着一周看完《挪威的森林》，心里有许多话想说，但又无从说起。 相比于《海边的卡夫卡》，《挪威的森林》里的故事少了些隐喻，却给我留下了更深的印象，压抑感从最初的“献给许许多多的祭日”开始贯穿全文，读书的魅力莫过于此，人生苦短，22岁的我没有直面死亡的经历，然而书中村上村树用文字叙述了成长或者说活下去必须付出的代价，直击内心深处； 木月死了、直子死了、初美死了、直子的姐姐死了、绿子的父亲死了，用书中的话来说“死并非生的对立面，而作为生的一部分永存”，死会给生者留下只有通过死才能够学到的东西，然而任何哲理都不可能治愈失去所爱之人造成的悲伤，生的人最终只能靠自己从悲哀中解脱出来并砥砺前行。 阅读量的匮乏，加上只读了一遍，实在很难写出很好的书评，这次就站在巨人的肩膀上吧，这篇书评是个人认为比较有深度的，希望自己以后也能写出这样的文章。 以下内容均为转载 日本的许多作家在小说里会表达“徒劳”的主题。 川端康成写的是对抗人生虚无主义本质的徒劳，三岛由纪夫写的是解决人物认识与行为的二律背反的徒劳，大江健三郎写的是试图满足无法被满足的人性欲望的徒劳。 村上春树在《挪威的森林》里写的，是寻求人与人之间相互理解的徒劳。 1 渡边对直子毫无保留的爱，全身心的付出，甚至让她在二十岁那天体会到了前所未有的欲望和高潮，可是，他仍然无法进入她的内心。 直子始终如一地爱着木月，木月死了，她的心就封闭了，不愿意任何人进去她的里面，无论是精神还是身体。她彻底锁住了自己。这把锁，没有人能打开，也屏蔽了理解的机会。 渡边一直不愿意放弃直子。他本身并不是一个顽强的人，但他试图变得顽强；他本身并不算是个很成熟的人，但他为了直子而用力成长。但这一切的努力，都被阻隔在“理解”的鸿沟之外。 虽然直子知道，”死了的人就一直死了，可我们以后还要活下去”，但她仍执着于死去的木月；直子知道她需要“肩膀放松，身体变轻”，但她没有办法做到，因为只要一放松就会土崩瓦解。 自身的“知”和“行”之间尚且存在着巨大的距离，又谈何与他人的理解呢？他人的安慰、体贴、认同，又能对自己产生多大的影响呢？ 这是《挪威的森林》所表达的意义之一——“人，人生，在本质上是孤独的”，相互理解，是“宿命式”的不可能。 2村上春树在很多场合提过他最爱的三个作家：雷蒙德·钱德勒、菲茨杰拉德、雷蒙德·卡佛。 不少人读雷蒙德·卡佛，都感觉云里雾里，不知道卡佛写的那些所谓极简主义的枯燥文字、看似随意截取的生活片断，到底表达了什么。 我读过卡佛的《大教堂》和《当我们谈论爱情时我们在谈论什么》，在我看来，卡佛勾勒的是每个人生命中都可能出现的一种荒凉的、令人感到空落落的大片大片的苍白。这种苍白来不仅来自于无趣的生活，也来自于人与人之间沟通的困境。 《当我们谈论爱情时我们在谈论什么》 在卡佛的作品里，人们在沟通和表达上的缺陷随处可见。我们在阅读时感觉到书中人物的前言不搭后语，或是对话的支离破碎，其实都是真实生活的精确反应——人其实在很多时候都不能明确地表达自己。 当沟通的起点——自己想要表达的内容——都出现问题时，更不用提沟通的其它环节——对方是否能听清、是否愿意听、听了是否能听懂了。 在读《挪威的森林》时，能感觉到村上春树对卡佛的致敬。 渡边和直子无法相互理解，永泽和初美无法相互理解，玲子和外界无法相互理解，即使是敢死队，我们在阅读时大多只会对他报以嘲笑，很少能与他达成理解。 无法理解的原因，可能来自于个人的经历、理念或心态，但起主要作用的，还是沟通和表达。脱离了沟通和表达来追求理解，是纸上谈兵、一厢情愿的尝试。因此，在相互理解的徒劳里，沟通和表达的本质缺陷起到了明显的作用。 书中多次提到这种缺陷，比如说直子，“她无法在诉诸语言之前在心里把握它，惟其如此才无法诉诸语言”，比如说渡边在思考死亡问题时，“诉诸语言之后确很平凡，但当时的我并不是将其作为语言”——可以看出，这种缺陷，既在于内心对于感受的定位误差，也在于语言体系的不完善。 这种缺陷，与口才无关，和尝试的次数无关。这是由沟通和表达的属性和载体所决定的，试图解决的努力是徒劳的。但大多数人并不会意识到这样的努力是徒劳，人们在产生孤独感和疏离感时，仍会本能地寻求与他人的交流，试图以交流获得相互理解，来应对孤独。 不可否认，这种与他人交流的尝试，或多或少会起到一些作用，会让人有机会产生“被理解”的感受，但这样的理解，更偏重于表象，而无法解决根本问题。就好像是被火灼伤后，用凉水浇伤口，碰到水的那一刹那，感受是舒服的，但这种舒服是短暂的，是表面的，真正的伤口，仍然在疼。 这种徒劳的努力，同样表现在书中所描写的年轻一代对性的态度上。泡吧、一夜情，在书中是很普遍的社会现象，很显然，对于性的放纵，同样是人们试图解决孤独感的一种方式—— 既然无法相互理解，就至少让彼此的身体结合在一起吧。但这种尝试同样是失败的，渡边的感受是：“和素不相识的女孩睡觉，睡得再多也是徒劳无益。” 3在牢不可破的徒劳面前，村上春树给出了一种应对的方式： “与其勉强通过与人交往来消灭孤独，化解无奈，莫如退回来把玩孤独，把玩无奈。” 在书里，这是渡边和永泽的态度。永泽说：“我同渡边的相近之处，就在于不希望别人理解自己。这点与其他人不同，那些家伙无不蝇营苟且地设法让周围人理解自己。” 但渡边和永泽选择这种态度的成因是不同的。对渡边来说，他并非不渴望他人的理解，只是在遇到徒劳的迎头痛击时，钻回自己的壳里，喘口气让自己缓一缓。而对永泽来说，他试图以执拗的姿态彰显自己对抗孤独的勇气，用激烈的态度向徒劳发起正面挑战，即使伤害自己身边最亲最爱的人也在所不惜。 从结果来看，以否定问题本身来解决问题，并没有起到解决问题的作用。渡边仍在孤独的泥沼中气喘吁吁，永泽同样在孤寂的道路上找不到归宿。 村上春树给出的真正的答案，是绿子。 图片来自于网络 绿子的形象，类似于《雪国》里的叶子、《围城》里的唐晓芙、《罪与罚》里的索尼娅，他们是重重黑暗里的一丝光亮，是对抗徒劳和虚无的勇气来源。 绿子给渡边的感觉，和直子截然不同。绿子是立体的，是行走的、呼吸的、跳动的，她的一举一动都在让渡边感受到触动。 绿子的经历，其实并没有比直子和玲子好太多。她同样无依无靠。但在孤独里，她选择的是与她们截然不同的态度。她选择接受现实，选择追逐生活里的一个个看似微不足道的小目标，或者说得更简单些，她选择的是——活下去。 “我们是在活着，我们必须考虑的事只能是如何活下去。”——这是渡边在书的尾声处的想法。这个想法从模糊到清晰的转变，关键在于绿子。 4在《挪威的森林》里，村上春树把致敬同样献给了他的另一位偶像——菲茨杰拉德。 《了不起的盖茨比》，高居20世纪百部最佳英文小说排行榜第二名。小说和电影里，都有一个令人印象深刻的场景——盖茨比整夜整夜凝望着对岸的灯光，也就是黛西家码头的灯光。这束灯光，是整部小说的灵魂，有着丰富的隐喻和意向。 《挪威的森林》里有类似的光亮。 “我静止不动地呆呆凝视着那微小的光亮。那光亮使我联想到犹如风中残烛的灵魂的最后忽闪。我真想用两手把那光严严实实地遮住，守护它。我久久地注视着那若明若暗摇曳不定的灯光，就像盖茨比整夜整夜看守对岸的小光点一样。” 这束光亮，是渡边的寄托和追求，是他灵魂的方向，是他希望用生命为之守护的珍宝，也是他可望而不可及的遗憾。 在书中的大部分篇幅里，村上都让渡边和读者们以为，这束光亮，是渡边的最爱——直子。 直到全书的最后一句，当渡边在“哪里也不是的场所的正中央，不断地呼唤着绿子”时，我才意识到，这束光亮，是绿子。 虽然村上春树没有在书中提到这束光的颜色，但我们都知道，在《了不起的盖茨比》里，这束光，是绿色的。 图片来自于网络 绿光，绿子，或许这并不只是个巧合。 再想得更深一点，这束绿光，是幸福的终点吗？ 村上春树选择了开放式的结尾，没有给出答案。但答案是显而易见的，这束绿光并没有给盖茨比带来幸福的终点。在《了不起的盖茨比》的结尾，菲茨杰拉德写下了脍炙人口的一段话： “So we beat on, boats against the current, borne back ceaselessly into the past.” “我们继续奋力向前划，逆水行舟，不停地倒退，回到往昔。” 盖茨比相信的那盏绿灯，那个年复一年渐行渐远的令人沉醉的未来，为何努力向这个目标奋进的我们，是在“逆水行舟”，会“不停地倒退，回到往昔”呢？ 回到《挪威的森林》里来，绿子带来的这束光亮，是否也会让渡边陷入同样的境地？ 这才是这本小说最值得玩味的地方。","updated":"2019-11-04T11:50:10.739Z","link":"","tags":[{"name":"读书","slug":"读书","permalink":"https://lifei-2019.github.io/tags/读书/"}]},{"title":"亦是此间少年","date":"2019-11-01T13:01:42.000Z","path":"亦是此间少年/","text":"最开始做这个博客，一方面是因为考上计算机研究生，总得有点拿的出手的专业性的东西，另一方面自己的语文一直处于不及格的水平（让大家见笑了），就想着一点点写些东西，勤能补拙嘛 话有点扯远了，距离上次已经一周多没更新了，老实说，从开学到最近发生了不少事，家里、高中同学、舍友、教研室、图书馆遇见的种种….研究生的生活过得没有想象中那么好，但是，毕竟，那些使我们痛苦的，往往使我们进步。 研究生大体上分为两种（对于普通研究生来说），一种是老师带着看论文、做项目、打比赛的，一种是老师放任个人发展的，前者又分真正帮学生发展亦或是压榨的，其实从我个人看来，被压榨有时候也是一种幸福，代表着你有被压榨的资本（马总说的嘛，不是所有人都可以九九六的~）； 我属于后者，这或许也是我在此时有空写博客的原因吧，其实说到“放养”，我相信大多数同龄人的反应是“我要是能自己学，我花钱来上学干吗？”，这句话在整个本科阶段听了无数次，甚至越听越有道理，工作日每天早八点到晚五点，再加上周末节假日的补课，老师陪伴孩子的时间甚至比家长的时间都要多，要是不能让我学会东西，那一定是你老师的问题，大多数人往往碌碌无为平庸一生也皆因如此。（没有攻击任何人的意思，自己也长期处于此状态）只是，“放养”，真的是老师的错吗？ 其实不然，上研究生以来，遇到的牛人许多，学习氛围也很浓厚，大家都铆着一股劲，研一发论文，研二找实习，研三找工作，这是历任师兄师姐传下来的，刚开学那会，看着身边有人看老师发的论文，有人，有人参加比赛，有人跟着老师到处跑做项目，自己吧，本科就整了个著作权，Java web、linux学的都是个半吊子，要啥论文没有，要实习经历没有，要比赛经历也没有【打字的手微微颤抖 学！大数据？得学！java？得学！linux？得学！python？得学！cv？得学！不懂机器学习考什么研？得学！论文？得看！ 直到有天看到张有意思的图 当时也没注意，看的时候觉得不过又一碗鸡汤，晚上看GAN模型的时候，概率论基础实在太差，脑阔痛的时候想起来，划拉了几笔，开始神游：想到投名状里庞青云的一句话“我这一生，如履薄冰，你说，我能走到对岸吗？”，路选错了，走到对岸，等待他的，只是另一种死亡罢了。到对岸的方法有许多种，飞过去、走过去、甚至游过去，可彼岸那边是什么？中考、高考、研究生入学考试，我们都在努力，再往后，找到好工作，成家，一切都顺理成章。 可 再往后呢？ 十年？二十年？三十年？四十年？五十年？ 我从不排斥中国的教育体制，过去的二十年，人口基数摆在这里，为了公平，必须要有选拔制度的存在，我们努力的目标就是升学，只是在这二十二岁的年纪，要让一个一直在框架里成长的少年去自己书写以后的人生，他有拿黑色圆珠笔的力气，却无从下手，他的思想已经被体制“矫正“到正确的、拥挤的道路上，甚至不敢去碰水彩笔，去碰那雪白的纸面。 老实来说，到现在，自己虽然也没有像《致青春》里陈孝正盖一栋完美大楼的蓝图，但是总算由落笔的勇气。 借用最近读的《挪威的森林》里的一句话：学到的东西与其说具体有什么具体用处，莫如说它是一种训练，训练我们更加系统的把握事物；而要在某种程度上掌握系统考虑事物的方法，就要像乌鸦往树洞里贮存玻璃片一样。 感谢每个读到这里的人，愿你不辜负自己，亦是此间少年。 写于2019-11-1","updated":"2019-11-04T11:43:34.957Z","link":"","tags":[]},{"title":"新世界的大门【持续更新】","date":"2019-10-21T01:52:59.000Z","path":"treasure/","text":"自己日常搜集的一些软件和网站，希望能帮到大家。 图标下载easyicon(动漫卡通图标较多) font awesome（各大软件平台图标较多） 比特虫（制作icon图标） emoji（emoji表情下载） 热门JavaScript下载bootcsn（五花八门啥都有） 3D JS alteredqualia（有的有些猎奇） 编程相关软件Sublime Text3（编辑器 安装完插件如有神助 配置过程见我的SublimeText3插件安装） Typora（写博客，写知乎必备神器，MarkDown进阶版 配置过程见 Typora入门 ） Git Bash（同步GitHub必备） Notepad++（超轻量级编辑器 没有写代码提醒 但是用起来真的快） Navicat（连数据库的 非常好用 正版要购买） 论文相关Arxiv（学计算机的都懂） paper with code（论文附代码 机器学习的福音 配合arxiv使用更佳） Sci论文下载（Sci里找到标题来这下载 美滋滋） 谷粉学术（舍友推荐） 壁纸下载WallPaper AByss（无意间找着的，还挺好用） 编程教学廖雪峰老师的网站（看过Git和Python 都很不错） 力扣（神仙打架） 在线正则表达式 网站视频下载JiJiDown（B站视频下载！敲有用！） 优酷、爱奇艺等（有的会失效，可以试试） 二维码生成草料二维码（微信、网站等生成二维码） 在线 PS改图宝（证件照、修图应有尽有） Screen to gif因为写博客经常需要录制屏幕并制作gif图，下载后使用极佳，强推！“小而实用”，大小仅2M多（压缩后才几百K），但录制调帧导出一条龙。（网上资源一抓一大把就不放下载链接了） 会员优惠购迅雷、B站等会员优惠购（低至3元/月）（经济条件允许的话还是支持正版！） 远程控制软件 teamviewer（用过的都说好，算是远程控制电脑软件里不错的！） 各种网站 2uts和Oeasy,会玩才会学 国外视频教学网站，完全免费 （3d动画、游戏开发、视觉、音频 哪个男孩能不爱呢） 个人建的教学网站，完全免费，无广告，讲的也很良心，覆盖面很广（亲测好用，一顿爆吹就完事了！） 方方格子 Excel的综合练习，分为两个板块：Excel插件和工具箱+Excel学习教程（屯着以后学） Fugue 免费背景音乐的素材库，大部分是纯音乐，适合添加视屏背景音（等我学做视频再说哈哈哈哈） Wikihow 歪果仁建的How to ____ 网站，为各行各业解决问题（可我们有百度有知乎啊） 仿知网 模仿知网的一个平台，前期免费，收费1元/天，也可以换个邮箱注册（hai，提到论文就头疼，防止以后在外下论文） 即书keysuper 号称30秒选模版、1小时完工的ppt制作神器（咱也没用过，咱也不敢夸，咱也不敢喷）","updated":"2020-04-06T15:11:18.337Z","link":"","tags":[{"name":"新世界","slug":"新世界","permalink":"https://lifei-2019.github.io/tags/新世界/"}]},{"title":"人类群星闪耀时","date":"2019-10-17T12:36:03.000Z","path":"人类群星闪耀时/","text":"翻看全书，所有的故事大致可分为两类：第一类是从无到有，《不朽的逃亡者》、《亨德尔的复活》、《一夜天才》、《玛丽恩浴场里的哀歌》、《跨越大洋的第一句话》等等，这些故事的主人公为了探索世界，追求自己的理想，都付出了艰难的努力。这些创造文明的人经历了病痛、贫病、失恋等等痛苦，甚至有人还被全世界认为是骗子，可是他们坚韧不拔，没有背叛心中的理想与信念，最终幻化成人类星空中闪亮的一瞬。 相比创造，毁灭则容易的多，这就是全书第二类故事，比如《拜占庭的陷落》、《滑铁卢决定胜负的一瞬》、《壮丽的瞬间》、《黄金国的发现》等等，也许一秒钟的迟疑就能毁灭一个英雄、一个小时所发生的事足以毁灭千年的文明。与创造相比，毁灭简直是太容易了，容易到只需要一瞬。这些瞬间在星空中闪亮一下，就重归黑暗了。 说几个我印象比较深刻的 《不朽的逃亡者》描述的是1513年太平洋的发现。在哥伦布第一次发现美洲大陆归来后，由贪欲引发的黄金国之梦一度让许多人为之痴迷，最终落得破产的后果；努涅斯•巴尔博亚就是其中一名，但他精明在能够抓住生存的每一丝希望，在违抗西班牙国王的旨意后，他清楚地知道要么惨死在断头台上，要么为祖国占有尚未发现的海洋，逃遁到不朽的事业中去。他成功了，但是不久便死在妒忌它成就的心腹手里。 在《滑铁卢决定胜负的一瞬》里，法军元帅格鲁希因为在短短一秒钟内错判的形势，没有及时支援拿破仑，错失了良机，导致滑铁卢战役的失败。滑铁卢的失败让英雄拿破仑跌落凡尘，而毁灭英雄的正是一个庸人格鲁希。虽然格鲁希后来在每个职位上都表现出色，但他一生也不能弥补在滑铁卢所犯的错。茨威格在这篇文章里认为格鲁希是个庸人、畏首畏尾的人，作者慨叹：“命运鄙视地把畏首畏尾的人拒之门外。命运——这世上的另一位神灵，只愿意用热烈的双臂把勇敢者高高举起，送上英雄们的天堂。” 《拜占庭的陷落》里，奥斯曼帝国的苏丹穆罕默德二世攻占拜占庭，拜占庭得不到欧洲的援军帮助，但积极备战。最后仅仅因为一扇凯卡波尔塔小门没关，土耳其军队顺利进入君士坦丁堡，千年帝国拜占庭从此陷落了。城内百姓被劫掠了三天三夜，拜占庭帝国的文明也被毁灭。作者惋惜、感叹：“历史犹如人生，业已失去的瞬间，不会因为抱撼的心情而重返，仅仅一个小时所贻误的东西，用千年的时光也难以赎回。” 《亨德尔的复活》章节，亨德尔在半身瘫痪之后，以坚强的意志积极恢复身体，终于在几个月的温泉治疗之后重新站了起来，创造了奇迹。身体恢复之后，他不知疲倦的创作，至清唱剧《弥赛亚》创作完成之后，他将没睡的觉和没吃的饭都补了回来。《弥赛亚》是一部伟大的作品，亨德尔更是一位伟大的音乐家，伟大的音乐家创造伟大的乐曲，其中的过程是艰难的、忘我的，甚至是经历着病痛的折磨，克服一切的办法只有顽强的意志力。 《向上帝逃亡》，在我看来是作者通过剧本的形式，对战争进行了一番辩论，从托尔斯泰的口中说出暴力革命只会让强权变成另一个强权、压迫变成另一种压迫这样的观点。最后，托尔斯泰在人生的最后一刻摆脱了命运，从伯爵蜕变成了普通人，逝世于站长那寒酸的、不成样子的床上。 读完整本书，似乎有些理解在译序茨威格的反战思想——虽然有些战争是正义的，可它们同样都会带来毁灭。那么多伟大的人呕心沥血的创造了我们的文明，却要因为一场战争、在一瞬间被毁灭，而那些本该闪耀在我们人类星空上的人，却因为一瞬间的失误而遗失在历史的长河中。这一瞬间就成了永恒，即使用千年的时光也难以赎回。 同时，茨威格的死亡在那个时代似乎也是必然的。在遭到纳粹驱逐八年后，第二次世界大战发生后三年，1942年2月23日，他选择服毒自杀，遗书中说：“我的母语世界已经沉沦，我的精神家园，欧洲，已经自我毁灭。（the world my own language having disappeared from me and my spiritual home,Europe,having destroyed itself.）”一个人，精神故乡由于自己的祖国而分崩离析，导致自己浪迹天涯、无家可归，那还不如及时的不失尊严的结束自己的生命为好。 PS: 自己收藏的一些常识，与君共享。 哈利路亚：犹太教和基督教的欢呼语，意思赞美上帝 ==西俗：在主显节，一月六日耶稣出现的日子，得到馅中有豆的人称为豆王== 耐基 希腊神话里的胜利女神 ==萨梯儿 希腊神话里的林神：醉鬼或色鬼同义词== 六翼天使：《圣经》里最高阶天使。 巴别塔：《圣经》里未建成的通天塔 ==祖特尔在加利福利亚发现“黄金国”== 1837年电报机第一次使用 居鲁士•弗•菲尔德 跨洋通信 ==挪威阿蒙森发现南极 第二个英国斯科特== 赫克托 希腊神话特洛伊战争的英雄 安德洛马赫 赫克托的妻子，美貌钟爱丈夫 ==美国记者约翰•里德目睹十月革命，著有《震撼世界的十天》== 当强烈的个人意志与历史宿命碰撞之际，犹如耀眼的星光在夜空中闪现，那样的时刻足以照亮人类文明的天空。","updated":"2019-11-03T07:01:03.708Z","link":"","tags":[{"name":"读书","slug":"读书","permalink":"https://lifei-2019.github.io/tags/读书/"}]},{"title":"真相捕捉【含剧透】","date":"2019-10-15T02:36:33.000Z","path":"真相捕捉/","text":"在bilibili上偶然看到@蔡老板家的长工解说英剧《真相捕捉》，看了几分钟深知这部剧值得看原剧，自此一发不可收拾，两天追完了。（PS：感觉最近的英剧都不错） BBC 的这部六集迷你剧《真相捕捉》（The Capture）是一个由虚假视频引出的故事。豆瓣评分：9.1 以下内容含剧透！！！！ 剧情反转较多。概括的来说，真相捕捉说的是几个律师和英帝、美帝用一个小士兵当牺牲品，互相较量。故事的背景是美帝、英帝利用修改监控画面来逮捕恐怖分子，而几个律师认为这种行为有碍司法公正。于是律师们自导自演了一出修改监控画面，构陷一名士兵绑架，意图在案件进入司法程序后放出原本视频，证明监控是可以被修改的。希望以此来推翻美帝和英帝此前利用伪造监控进行的不公正审判。 首先谈谈剧中的AI换脸技术。早在2017年底，国外论坛就出现了通过计算机学习来更换视频中人脸的AI算法，那个时候，AI算法的使用门槛还很高，需要编译代码和高性能的显卡做信息的运算处理。 2019年8月，”ZAO”APP的出现，再次让AI换脸，火遍了大街小巷。人们只需上传一张照片，运用APP自带的AI换脸功能，就可以将短视频中的演员的脸换成自己的脸。 相比之前高门槛的AI编程算法，“ZAO”把AI换脸的视频制作运算放到了服务器上，用户不再需要高性能的手机配置，用户体验效果极其良好。 因AI换脸“出演”《射雕英雄传》的杨幂 ==换脸技术已经不再是科幻小说中的桥段，而是真实存在的事实。== 再来谈谈司法。百度百科上对于第一手材料的定义是—— 从亲身实践或调查中直接获得的材料； 第一手材料是直接的证据，是未经过任何修饰的信息 ,意思是最原始，未经改动的 ，通常也比喻最真实的信息。 未来，实时监控录像、视频录像是否可以作为第一手材料，对于司法部门来说是个巨大的槛。人们对于常识的局限性，也影响着人们的判断。 技术的爆炸发展，不仅让监控视频成为了铁证，同时也让我们步入了「后真相时代」。如果，铁证也有被篡改的一天，我们究竟还能相信什么呢？ 「后真相」一词是用来形容一种不正常的舆论生态，主要指媒体传播起到的是煽动情感、强化偏见的作用，其所产生的影响超过了客观事实对人们的影响，人们只在意情绪或主张，而不管事实和道理。 于我个人而言看完这部剧，印象最深刻的是第五集结尾处瑞秋的上司由于某些原因告诉瑞秋所有的真相后，事情的难题变为我们应该为了保护两千人而把有潜在犯罪危险的人陷害入狱还是还未犯罪的人一个清白然后向上帝祈祷他的犯罪危险只是潜在的？ 911以后《爱国者法案》被推行，“在国家遭遇威胁时，执法部门总是借机以「国家安全」为名，扩大部门权力…政府掌握任意性权力隐含巨大威胁，因为它既可以用来打击恐怖主义，也可以被用来镇压不同意见者”（王希《原则与妥协——美国宪法的精神与实践》）。 说的明白些，便是国家安全与个人权利谁更重要？ 更新于10/15 看完有些影评，发现自己思想的深度还是不够。 如果只从上述角度来看这部剧，似乎有些浅显。除了美帝、英帝的霸道行为，这部剧的另一叙事主题就是那些律师们。通过修改监控实时画面，构陷无辜者入狱来达成自己的目的。不论律师们如何弘扬自己的目的多么高尚，也无法掩盖这种行为的卑劣。 有计划性的通过特定案件来冲击现有体系，希望借此来改变社会。这部剧里的行为，美帝早在50/60年代甚至更早以前就已经不是新鲜事了。甚至联邦最高法院的大法官瑟古特·马歇尔早年就是职业干这行的，他们组成团体将热点种族案件带入各州和联邦法院，利用十四修正案挑战现有种族歧视与隔离政策。 当然不能否认这些人的“宏大目标”的正面意义，不然今天的美帝大概也没法宣传自己的“普世价值”了。 我只是很好奇，瑟古特·马歇尔这样的律师和《真相捕捉》里的这批律师有什么区别呢？从目的来看，二者都是为了宏大理想社会公正，匡正司法体系而奋斗。微观来说，二者出发点又都是被一个个个体遭遇的不公正触动。那么问题到底出在哪里呢？ 作为一个理想主义者，我有时会拷问自己，“理想”要实现付出的代价是什么？你又是否有权力让别人为了自己的理想而付出代价？答案当然是不唯一的。秦晖老师很多年前有篇文章讲我们的左派和右派都在讨论假问题，说的很在理，虽然他说的左右和大多数人理解的左右不是一回事。秦文章里有个观点，他觉得极左与极右看似极端对立，实际上只是一步之遥。我的理解里，左派右派讲的大多时候关注的是right的问题，而极左极右则扩展到了power上去。 作为个体的人，当然是没有资格要求他人为自己的理想而牺牲的，不论这个理想多么的“正确”。尊重他人的自由和自由的选择，应该算是一种常识（当然这个常识未必人人能懂）。但是有自己的理想蓝图并有power为之护航时，情况就大不相同了。 英剧里的律师当然是没有power的，但是他所追逐的理想，在实现过程里必然要依傍现有体系，并通过体系来实现自己的理想。这一过程里，如果缺乏对个体生命和自由的尊重，漠视个体的人的利益，铁定要走到自己理想的对立面上去。 所以，日常生活中当我碰到那些有宏大理想口若悬河的人，大概率是要离他们远一点的。倒不是怀疑他们实现理想的能力，只是害怕他们的理想未来里没有我。 深秋已过，凛冬将至，看个《真相捕捉》，雪上加霜吧。","updated":"2019-11-11T10:32:17.292Z","link":"","tags":[{"name":"英剧","slug":"英剧","permalink":"https://lifei-2019.github.io/tags/英剧/"}]},{"title":"python小技巧","date":"2019-10-15T00:49:07.000Z","path":"python小技巧/","text":"1. 反转字符串采用切片操作实现字符串的反转： 1234567# Reversing a string using slicingmy_string = \"ABCDE\"reversed_string = my_string[::-1]print(reversed_string)# Output# EDCBA 2. 实现首字母大写这个小技巧是让字符串中每个单词的首字母变为大写，通过方法 title() 实现： 123456my_string = \"my name is chaitanya baweja\"# using the title() function of string classnew_string = my_string.title()print(new_string)# Output# My Name Is Chaitanya Baweja 3. 查找字符串中唯一元素这个技巧是查找字符串中不重复的元素有哪些，通过集合 set 来实现： 123456789my_string = \"aavvccccddddeee\"# converting the string to a settemp_set = set(my_string)# stitching set into a string using joinnew_string = ''.join(temp_set)print(new_string) 4. 打印 n 次字符串或者列表这个技巧通过乘法即可实现打印多次的操作： 123456789n = 3 # number of repetitionsmy_string = \"abcd\"my_list = [1,2,3]print(my_string*n)# abcdabcdabcdprint(my_list*n)# [1,2,3,1,2,3,1,2,3] 这个技巧比较有趣的应用是定义一个包含 n 个重复的常数元素的列表，如下所示： 123n = 4my_list = [0]*n # [0, 0, 0, 0] 5. 列表推导式列表推导式是一种非常优雅的基于其他列表来创建新列表的方法，示例如下所示： 123456original_list = [1,2,3,4]new_list = [2*x for x inoriginal_list]print(new_list)# [2,4,6,8] 6. 交换两个变量Python 中交换两个变量的数值是非常简单的，完全不需要第三个变量作为中间值。示例如下所示： 12345a = 1b = 2a, b = b, aprint(a) # 2print(b) # 1 7. 字符串分割为一串子字符串列表采用 split() 方法可以将字符串分割为一个包含其子字符串的列表，示例如下所示： 12345678910string_1 = \"My name is Chaitanya Baweja\"string_2 = \"sample/ string 2\"# 默认分割符 ' 'print(string_1.split())# ['My', 'name', 'is', 'Chaitanya', 'Baweja']# 自定义分割符 '/'print(string_2.split('/'))# ['sample', ' string 2'] 8. 合并多个字符串为一个字符串采用 join() 方法可以将多个字符串合并为一个字符串。这相当于上一条技巧的反向操作。示例如下所示： 123456list_of_strings = ['My', 'name', 'is', 'Chaitanya', 'Baweja']# Using join with the comma separatorprint(','.join(list_of_strings))# Output# My,name,is,Chaitanya,Baweja 9. 判断字符串是否回文通过反转字符串，再和原字符串比较，可以判断是否为回文，示例如下： 1234567my_string = \"abcba\"if my_string == my_string[::-1]: print(\"palindrome\")else: print(\"not palindrome\")# Output# palindrome 10. 统计列表元素的个数有多种方式可以实现这个技巧，但我最喜欢的是采用 Counter 类。 Counter 可以统计给定列表中每个元素的个数，返回一个字典格式。示例如下，其中most_common()方法可以返回列表中数量最多的元素 1234567891011121314# finding frequency of each element in a listfrom collections import Countermy_list = ['a','a','b','b','b','c','d','d','d','d','d']count = Counter(my_list) # defining a counter objectprint(count) # Of all elements# Counter(&#123;'d': 5, 'b': 3, 'a': 2, 'c': 1&#125;)print(count['b']) # of individual element# 3print(count.most_common(1)) # most frequent element# [('d', 5)] 11. 判断两个字符串是否是字谜(Anagrams)字谜(Anagrams)是指将一个单词打乱其字母顺序，重新排列为一个新的单词。 Counter正好可以用于解决这个问题，因为如果两个字符串的 Counter 对象相等，就表示它们就是字谜，因为包含相同元素且元素数量都相同。 示例如下： 1234567from collections import Counterstr_1, str_2, str_3 = \"acbde\", \"abced\", \"abcda\"cnt_1, cnt_2, cnt_3 = Counter(str_1), Counter(str_2), Counter(str_3)if cnt_1 == cnt_2: print('1 and 2 anagram')if cnt_1 == cnt_3: print('1 and 3 anagram') 12. 采用 try-except-else 语句Python 中处理错误异常可以简单采用 try-except 语句，而再添加一个 else 语句会更加有帮助，它是在没有发生异常时，执行完 try 语句后运行的语句。 此外，如果需要运行是否发现异常的都需要执行的代码，可以采用 finally ，示例如下： 12345678910a, b = 1,0try: print(a/b) # exception raised when b is 0except ZeroDivisionError: print(\"division by zero\")else: print(\"no exceptions raised\")finally: print(\"Run this always\") 13. 采用 Enumerate 来获取索引值在迭代列表的时候，可以采用 enumerate 来得到索引值，示例如下： 12345678my_list = ['a', 'b', 'c', 'd', 'e']for index, value in enumerate(my_list): print('&#123;0&#125;: &#123;1&#125;'.format(index, value))# 0: a# 1: b# 2: c# 3: d# 4: e 注意，这里还可以指定索引开始的范围，只需要在调用 enumerate() 时候，添加一个参数，如下所示： 123my_list = ['a', 'b', 'c', 'd', 'e']for index, value in enumerate(my_list, 1): print('&#123;0&#125;: &#123;1&#125;'.format(index, value)) 14. 检查一个对象的内存使用量可以采用 sys.getsizeof() 检查，示例如下： 12345678import sysnum = 21print(sys.getsizeof(num))# In Python 2, 24# In Python 3, 28 15. 合并两个字典在 Python2 版本的时候可以采用 update() 方法实现合并字典的操作，但在 Python3.5 后的版本，可以采用新的方式实现，操作更加简单，如下所示： 12345678dict_1 = &#123;'apple': 9, 'banana': 6&#125;dict_2 = &#123;'banana': 4, 'orange': 8&#125;combined_dict = &#123;**dict_1, **dict_2&#125;print(combined_dict)# Output# &#123;'apple': 9, 'banana': 4, 'orange': 8&#125; 16. 计算代码执行时间采用 time 模块来计算一段代码的执行时间，例子如下： 1234567891011import timestart_time = time.time()# Code to check followsa, b = 1,2c = a+ b# Code to check endsend_time = time.time()time_taken_in_micro = (end_time- start_time)*(10**6)print(\" Time taken in micro_seconds: &#123;0&#125; ms\").format(time_taken_in_micro) 17. 展平元素为列表的列表有时候并确定一个列表中的深度有多深，所以你只想简单的将所有元素都放在一个列表中，实现技巧代码如下所示： 123456789101112131415from iteration_utilities import deepflatten# 列表只有一层深度的情况，采用这个函数def flatten(l): return [item for sublist in l for item in sublist]l = [[1,2,3],[3]]print(flatten(l))# [1, 2, 3, 3]# 不知道列表的深度的情况l = [[1,2,3],[4,[5],[6,7]],[8,[9,[10]]]]print(list(deepflatten(l, depth=3)))# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 如果是数组的话，可以采用 Numpy 方式。 18. 从列表中采样采用 random 模块可以对一个列表随机采样 n 个元素，示例如下所示： 1234567import randommy_list = ['a', 'b', 'c', 'd', 'e']num_samples = 2samples =random.sample(my_list,num_samples)print(samples)# [ 'a', 'e'] this will haveany 2 random values 另外，在 Python 3 中推荐采用 secrets 模块，基于密码学的目的来随机生成样本，示例如下： 12345678910import secrets # imports secure module.secure_random = secrets.SystemRandom() # creates a secure random object.my_list = ['a','b','c','d','e']num_samples = 2samples = secure_random.sample(my_list, num_samples)print(samples)# [ 'e', 'd'] this will have any 2 random values 19. 数字化下面是一个例子，将一个数字转换为一个数字列表的形式： 123456num = 123456list_of_digits = list(map(int, str(num)))print(list_of_digits)# [1, 2, 3, 4, 5, 6] 20. 检查唯一性下面的代码是用于判断一个列表的所有元素是否都是唯一没有重复的： 1234567def unique(l): if len(l)==len(set(l)): print(\"All elements are unique\") else: print(\"List has duplicates\")unique([1,2,3,4])#Allelementsareuniqueunique([1,1,2,3])# List has duplicates","updated":"2019-11-03T07:03:24.865Z","link":"","tags":[{"name":"python","slug":"python","permalink":"https://lifei-2019.github.io/tags/python/"}]},{"title":"SublimeText3插件安装","date":"2019-10-12T05:57:47.000Z","path":"SublimeText3插件安装/","text":"一、下载安装sublime Text3​ 到官网下载安装包（根据你的电脑系统下载对应的version）： ​ 下载好st3后，然后不断的点击next，然后blablabla……就可以安装好了。 二、汉化sbulime Text3（看个人需要）2.1下载汉化安装包 ​ 地址：链接: https://pan.baidu.com/s/1y0c_SJdFMea-tWWruO5YmQ 提取码: rprd 2.2安装汉化包(将汉化包拷到 Installed Packages 文件夹中) ​ 进入：D:\\Sublime Text3\\Data\\Installed Packages（根据你的安装目录去寻找Installed Packages，本文是安装在D盘），将刚刚下载的汉化包解压，得到的文件Default.sublime-package 拷贝到 Installed Packages 文件夹中，这个时候就会发现汉化成功啦！ 三、安装Package Control（重要）​ 关系到很多插件的安装，非常重要！ 3.1 通过工具栏面板 ​ ①点击工具栏的“view”-&gt;”show console”(快捷键 是”ctrl+`”)， ​ ②到https://packagecontrol.io/installation官网，将对应的代码拷贝到显示面板中，然后回车。如果安装成功，那么就显示Package Settings 和Package Control 这两个项。 sublime 3： 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) ​ 如果没有安装成功，那么建议用手动安装 3.2通过手动安装 ​ 到https://packagecontrol.io/installation官网，右边有一个“Package Control.sublime-package”，点击下载，然后将文件拷贝到 Installed Packages文件夹中 四、安装st3常用的插件​ 对于sublime text3,它之所以轻巧，是因为它设计就是为了让你按需加载，根据自己的需要，去下载对应的插件，所以才不会像其他的IDE那样笨重。（虽然我当时整了半小时【微笑） ​ 安装插件步骤是：“Preferences -&gt; Package Control”(快捷键是：shift+ctrl+p),然后执行“Package Control: Install Package”,接在就是输入你要安装的插件就可以，下面就说一下你个人常用的插件： 1、ChineseLocalizations 汉化插件 —— 可进行语言切换 2、Emmet（原名 Zen Coding） ——- 可快速编写代码 例如：输入“!”或“html:5”，然后按Tab键，就会将html5基本标签显示出来，其他还有很多快捷方式，想了解的可以去查阅一下Emmet 3、BracketHighlighter ——– 类似于代码匹配，可以匹配括号，引号等符号内的范围 4、cssrem ——- 自动将CSS的px值转rem值 在wepapp开发时,使用rem进行移动端适配的时候，非常好用，省下很多计算的时间。 5、Alignment ——- 自动对齐代码，包括PHP、CSS、JavaScript语言。使得代码看起来更整齐美观，更具可读性 默认快捷键为ctrl + alt + a,如果跟某IM截图的快捷键冲突，可在Preferences-&gt;Package Settings-&gt;Alignment-&gt;Key Bindings - User中自定义快捷键，写法参照Key Bindings - Default 6、Css Format —– css格式化 很快捷的将css的格式进行切换，Expand（标准格式化），Compact（css一行行显示），Compressed（css压缩成一行） 7、DocBlockr —— 观察函数需要的变量名和类型，并创建文档块，只要在函数的上面输入/**，按Tab就可以了 8、SublimeCodeIntel ——- 一个全功能的 Sublime Text 代码自动完成引擎 支持的语言挺多的（JavaScript, Mason, XBL, XUL, RHTML, SCSS, Python, HTML, Ruby, Python3, XML, Sass, XSLT, Django, HTML5, Perl, CSS, Twig, Less, Smarty, Node.js, Tcl, TemplateToolkit, PHP.） 9、AutoFileName ——- 自动补全文件路径 10、Autoprefixer ——- 应用css的浏览器兼容书写，自动分析你的css文件，解析出新的css文件 11、JavaScript Completions ——- js最基本的api快查片段 12、minify ——- 压缩和美化html,css,js文件 因为minify利用的是nodejs进行的，所以使用minify需要安装nodejs,同时需要全局安装如下： 1npm install -g clean-css-cli uglifycss js-beautify html-minifier uglify-js minjson svgo","updated":"2019-11-25T01:59:33.347Z","link":"","tags":[{"name":"tools","slug":"tools","permalink":"https://lifei-2019.github.io/tags/tools/"}]},{"title":"Typora入门","date":"2019-10-12T01:49:26.000Z","path":"typora/","text":"简介​ Typora删除了预览窗口，以及所有其他不必要的干扰。取而代之的是实时预览。​ Markdown的语法因不同的解析器或编辑器而异，Typora使用的是GitHub Flavored Markdown。 下载Typora下载。 常用快捷键 加粗： Ctrl/Cmd + B 标题： Ctrl/Cmd + H 插入链接： Ctrl/Cmd + K 插入代码： Ctrl/Cmd + Shift + C 行内代码： Ctrl/Cmd + Shift + K 插入图片： Ctrl/Cmd + Shift + I 无序列表： Ctrl/Cmd + Shift + L 撤销： Ctrl/Cmd + Z 一级标题：快捷键为Crtl + 1，以此类推 块元素换行符在markdown中，段落由多个空格分隔。在Typora中，只需回车即可创建新段落。 标题级别 # 一级标题， 快捷键为Crtl + 1## 二级标题，快捷键为Crtl + 2###### 六级标题，快捷键为Crtl + 6 引用文字 &gt; + 空格 + 引用文字 清单输入 *列表内容 将创建一个无序列表，该*符号可以替换为+或-。 输入1. 列表内容 将创建一个有序列表，其markdown源代码如下： 无序列表* AA* BB* CC 有序列表 AA BB CC 任务列表 - [ ] 不勾选- [x] 勾选 代码块在Typora中输入””” + 回车，并在后面选择一个语言名称即可语法高亮。 语法高亮:\\ 12&gt; &gt; def helloWorld():&gt; print &apos;hello, world&apos;&gt; \\&gt; 数学表达式输入$$，然后按“回车”键，如下：$$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\end{vmatrix}$$ $$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\end{vmatrix}$$ 表输入| 表头1 | 表头2 |并回车。即可将创建一个包含两列的表，然后就像操作Word文档一样设置表格即可，没必要知道Markdown的复杂语法，因为这些语法会由Typora自动生成。效果如下： First Header Second Header 脚注 你可以创建一个脚注，像这样^1. 你可以创建一个脚注，像这样^1. 注意：该例子脚注标识是1，脚注标识可以为字母数字下划线，但是暂不支持中文。脚注内容可为任意字符，包括中文。 分割线输入***或--- 再按回车即可绘制一条水平线，如下： YAML Front MatterTypora支持YAML Front Matter， 在文章开头输入---，然后按回车即可。 目录（TOC）输入[toc]然后回车，即可创建一个“目录”。TOC从文档中提取所有标题，其内容将自动更新。 跨度元素跨度元素即图片，网址，视频等，在Typora中输入后，会立即载入并呈现。 链接内部链接 这是一个带有标题属性的[链接](http://example.com/ “标题”).这是一个没有标题属性的链接. 效果如下： 这是一个带有标题属性的链接.这是一个没有标题属性的链接. 参考链接 这是一个[参考链接]id。[id]: http://example.com/ “标题” 这是一个参考链接。 网址Typora允许用&lt;括号括起来&gt;, 把URL作为链接插入。输入[td_940915122@qq.com](mailto:940915122@qq.com) 即 td_940915122@qq.com。Typora还会自动链接标准网址。例如：https://lifei-2019.github.io/。 图片 *单个星号*_单下划线_ 效果如下：单个星号 单下划线 加粗 *两个星号*_双下划线_ 效果如下：两个星号双下划线 代码标记标记代码使用反引号，即在英文输入法下，ESC键下面和1键左边的符号——`效果如下：使用该printf()功能。 删除线 ~删除线 效果如下： 删除线 下划线&lt;u&gt;下划线 效果如下： 下划线 表情符号:smile: ：smile ：（注意为：是英文的冒号） :smile: 下标 H~2~O H2O (需在设置中打开该功能) 上标 X^2^ X^2^ (需在设置中打开该功能) 高亮 ==高亮== ==高亮==(需在设置中打开该功能) HTML支持HTML 嵌入内容支持iframe-based嵌入代码， &lt; iframe height=’265’ scrolling=’no’ title=’Fancy Animated SVG Menu’ src=’http://codepen.io/jeangontijo/embed/OxVywj/?height=265&amp;theme-id=0&amp;default-tab=css,result&amp;embed-version=2&#39; frameborder=’no’ allowtransparency=’true’ allowfullscreen=’true’ style=’width: 100%;’&gt; 视频 &lt; video src=”xxx.mp4” /&gt; :call_me_hand:常用字体及颜色设置 :call_me_hand:修改Typora默认样式 总结： 建议打开大纲视图（快捷键ctrl + shift + 1）。 插入表格需要顶格写，不然显示不出来。 以上语法不用刻意记，在Typora中的右键菜单都有， 常用功能基本上都有快捷键。 学计算机真让人掉发。","updated":"2019-11-25T02:00:22.078Z","link":"","tags":[{"name":"-tools","slug":"tools","permalink":"https://lifei-2019.github.io/tags/tools/"}]},{"title":"hexo+github建站","date":"2019-10-10T11:18:47.000Z","path":"hexo1/","text":"前言 欢迎在文末留言，觉得有帮助的话可以请作者喝杯咖啡。 本文采用 CC BY-NC-SA 4.0 许可协议，转载请注明出处！ 博客搭建准备环境 Node.js 下载，并安装。 Git 下载，并安装。（强烈推荐廖雪峰老师教程） 安装Hexo，在命令行（即Git Bash）运行以下命令： npm install -g hexo-cli 初始化Hexo，在命令行（即Git Bash）依次运行以下命令即可： 以下，即存放Hexo初始化文件的路径， 即站点目录。 1$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，在路径下，会产生这些文件和文件夹： 12.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 注： hexo相关命令均在站点目录下，用Git Bash运行。 站点配置文件：站点目录下的_config.yml。 路径为&lt;folder&gt;\\_config.yml 主题配置文件：站点目录下的themes文件夹下的，主题文件夹下的_config.yml。 路径为&lt;folder&gt;\\themes\\&lt;主题文件夹&gt;\\_config.yml 4.启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可： hexo server 5.浏览器访问网址： http://localhost:4000/ ​ 至此，您的Hexo博客已经搭建在本地。 实施方案方案一：GithubPages 创建Github账号 创建仓库， 仓库名为：&lt;Github账号名称&gt;.github.io 将本地Hexo博客推送到GithubPages 3.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 1$ npm install hexo-deployer-git --save 3.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 1$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如C:\\Users\\Administrator\\.ssh\\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 1$ ssh -T git@github.com$ yes 3.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 1# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：上面仓库地址写ssh地址，不写http地址。 3.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 1$ hexo g$ hexo d 等待1分钟左右，浏览器访问网址： https://&lt;Github账号名称&gt;.github.io 至此，您的Hexo博客已经搭建在GithubPages, 域名为https://&lt;Github账号名称&gt;.github.io。 方案二：GithubPages + 域名在方案一的基础上，添加自定义域名（您购买的域名）。 域名解析。 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为&lt;Github账号名称&gt;.github.io； 解析线路，TTL 默认即可。 仓库设置。 2.1. 打开博客仓库设置：https://github.com/&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io/settings 2.2. 在Custom domain下，填写自定义域名，点击save。 2.3. 在站点目录的source文件夹下，创建并打开CNAME.txt，写入你的域名（如www.simon96.online），保存，并重命名为CNAME。 等待10分钟左右。 浏览器访问自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io依然可用。 方案三：GithubPages + CodingPages + 域名GithubPages 在国内较慢，百度不收录，而CodingPages 在国外较快。所以在方案二的基础上，添加CodingPages 。 创建Coding账号 创建仓库， 仓库名为：&lt;Coding账号名称&gt; 进入项目里『代码』页面，点击『一键开启静态 Pages』，稍等片刻CodingPages即可部署成功。 将本地Hexo博客推送到CodingPages 4.1. 鉴于创建GithubPages 时，已经生成过公钥。可直接复制密钥文件内容（路径形如C:\\Users\\Administrator\\.ssh\\id_rsa.pub）， 粘贴到新增公钥。 4.2. 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 1$ ssh -T git@git.coding.net$ yes 4.3. 修改_config.yml（在存放Hexo初始化文件的路径下）。文件末尾修改为： 1# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master- type: git repo: git@git.dev.tencent.com:&lt;Coding账号名称&gt;/&lt;Coding账号名称&gt;.git branch: master 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 1$ hexo g$ hexo d 域名解析 添加 CNAME 记录指向 &lt;Coding账号名称&gt;.coding.me 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为&lt;Github账号名称&gt;.coding.me； 解析线路，TTL 默认即可。 添加 两条A 记录指向 192.30.252.153和192.30.252.154 类型选择为 A； 主机记录即域名前缀，填写为@； 记录值填写为192.30.252.153和192.30.252.154； 解析线路，境外或谷歌。 在『Pages 服务』设置页（https://dev.tencent.com/u/&lt;Coding账号名称&gt;/p/&lt;Coding账号名称&gt;/git/pages/settings）中绑定自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io和https://&lt;Coding账号名称&gt;.coding.me依然可用。 主题优化选择主题Hexo默认的主题是landscape，推荐以下主题： snippet Hiero JSimple BlueLake 详见：https://github.com/search?q=hexo-theme 应用主题 下载主题 将下载好的主题文件夹，粘贴到站点目录的themes下。 更改站点配置文件_config.yml 的theme字段，为主题文件夹的名称： 1# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: &lt;主题文件夹的名称&gt; 主题优化以上主题都有比较详细的说明文档，本节主要解决主题优化的常见问题。 主题优化一般包括： 设置「RSS」 添加「标签」页面 添加「分类」页面 设置「字体」 问题：引用国外字体镜像较慢。 解决：可以改用国内的。将\\themes*\\layout_partials\\head external-fonts.swig文件中fonts.google.com改成fonts.lug.ustc.edu.cn。 设置「代码高亮主题」 侧边栏社交链接 问题：图标哪里找？ 解决：Font Awesome 开启打赏功能 问题：微信支付宝二维码不美观，规格不一。 解决：在线生成二维码 设置友情链接 腾讯公益404页面 站点建立时间 订阅微信公众号 设置「动画效果」 问题：慢，需要等待 JavaScript 脚本完全加载完毕后才会显示内容。解决：将主题配置文件_config.yml中，use_motion字段的值设为 false 来关闭动画。 设置「背景动画」 主题优化还包括： 添加背景图在 themes/*/source/css/_custom/custom.styl 中添加如下代码： 1body&#123; background:url(/images/bg.jpg); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;&#125; 修改Logo字体在 themes/*/source/css/_custom/custom.styl 中添加如下代码： 1@font-face &#123; font-family: Zitiming; src: url(&apos;/fonts/Zitiming.ttf&apos;);&#125;.site-title &#123; font-size: 40px !important; font-family: &apos;Zitiming&apos; !important;&#125; 其中字体文件在 themes/next/source/fonts 目录下，里面有个 .gitkeep 的隐藏文件，打开写入你要保留的字体文件，比如我的是就是写入 Zitiming.ttf ，具体字库自己从网上下载即可。 修改内容区域的宽度编辑主题的 source/css/_variables/custom.styl 文件，新增变量： 1// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 网站标题栏背景颜色打开 themes/*/source/css/_custom/custom.styl ,在里面写下如下代码： 1.site-meta &#123; background: $blue; //修改为自己喜欢的颜色&#125; 自定义鼠标样式打开 themes/*/source/css/_custom/custom.styl ,在里面写下如下代码： 1// 鼠标样式 * &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important &#125; :active &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important &#125; 文章加密访问打开 themes/*/layout/_partials/head.swig文件,在 ``之前插入代码： 1&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 写文章时加上password: *： 1---title: 2018date: 2018-10-25 16:10:03password: 123456--- 实现点击出现桃心效果 在/themes/*/source/js/src下新建文件click.js，接着把以下粘贴到click.js文件中。代码如下： 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\\themes\\*\\layout\\_layout.swig文件末尾添加： 1&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt; 静态资源压缩在站点目录下： 1$ npm install gulp -g 安装gulp插件： 1npm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 在 Hexo 站点下新建 gulpfile.js文件，文件内容如下： 1var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);var imagemin = require(&apos;gulp-imagemin&apos;);// 压缩css文件gulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩html文件gulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩js文件gulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src([&apos;./public/**/.js&apos;,&apos;!./public/js/**/*min.js&apos;]) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public/demo 目录内图片gulp.task(&apos;minify-images&apos;, function() &#123; gulp.src(&apos;./public/demo/**/*.*&apos;) .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest(&apos;./public/uploads&apos;));&#125;);// 默认任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;,&apos;minify-images&apos;]); 只需要每次在执行 generate 命令后执行 gulp 就可以实现对静态资源的压缩，压缩完成后执行 deploy 命令同步到服务器： 1hexo ggulphexo d 修改访问URL路径默认情况下访问URL路径为：domain/2018/10/18/关于本站,修改为 domain/About/关于本站。 编辑 Hexo 站点下的 _config.yml 文件，修改其中的 permalink字段： 1permalink: :category/:title/ 博文置顶 安装插件 $ npm uninstall hexo-generator-index –save$ npm install hexo-generator-index-pin-top –save 然后在需要置顶的文章的Front-matter中加上top即可： 1---title: 2018date: 2018-10-25 16:10:03top: 10--- 设置置顶标志 打开：/themes/*/layout/_macro/post.swig，定位到 ，插入以下代码即可： 1&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 在右上角或者左上角实现fork me on github 选择样式GitHub Ribbons, 修改图片跳转链接,将&lt;a href=&quot;https://github.com/you&quot;&gt;中的链接换为自己Github链接： 打开 themes/next/layout/_layout.swig 文件，把代码复制到&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面。 主页文章添加边框阴影效果打开 themes/*/source/css/_custom/custom.styl ,向里面加代码: 1// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 显示当前浏览进度修改themes/*/_config.yml，把 false 改为 true： 1# Back to top in sidebarb2t: true# Scroll percent label in b2t buttonscrollpercent: true 创建分类页在终端窗口下，定位到 Hexo 站点目录下，新建： 1$ cd &lt;站点目录&gt;$ hexo new page categories 加入 广告主要有两种：百度SSP和谷歌Adsense。方法类似： 注册，复制广告代码 部署到网站。 2.1. 新建 theme/*/layout/_custom/google_ad.swig，将 AdSense 上的代码粘贴进去 2.2. 头部。在 theme/*/layout/_custom/head.swig 中也粘贴一份 2.3. 每篇博客。在 theme/*/layout/post.swig 里中在希望看到的地方加上： 1&#123;% include &apos;_custom/google_ad.swig&apos; %&#125; 例如：在 &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &lt;/div&gt; 中间插入，总代码如下： 1&#123;% block content %&#125; &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &#123;&#123; post_template.render(page) &#125;&#125; &#123;% include &apos;_custom/google_ad.swig&apos; %&#125; &lt;/div&gt;&#123;% endblock %&#125; 等待审核通过。如果失败，可再次申请。 添加萌萌哒 安装插件 1npm install --save hexo-helper-live2d 复制你喜欢的模型名字： Epsilon2.1 Gantzert_Felixander haru miku ni-j nico nietzche nipsilon nito shizuku tsumiki wanko z16 hibiki koharu haruto Unitychan tororo hijiki 将以下代码添加到主题配置文件_config.yml，修改&lt;你喜欢的模型名字&gt;： 1live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-&lt;你喜欢的模型名字&gt; display: position: right width: 150 height: 300 mobile: show: true 建配置文件 4.1. 在站点目录下建文件夹live2d_models， 4.2. 再在live2d_models下建文件夹&lt;你喜欢的模型名字&gt;, 4.3. 再在&lt;你喜欢的模型名字&gt;下建json文件：&lt;你喜欢的模型名字&gt;.model.json 安装模型。在命令行（即Git Bash）运行以下命令即可： npm install –save live2d-widget-model-&lt;你喜欢的模型名字&gt; 在命令行（即Git Bash）运行以下命令， 在http://127.0.0.1:4000/查看测试结果: hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 插件配置以下插件（评论系统、数据统计与分析、内容分享服务、搜索服务）各选一个即可。 评论系统 推荐指数 优点 缺点 Valine 4 每天30000条评论，10GB的储存 作者评论无标识 来必力/livere 4 多种账号登录 评论无法导出 畅言 3 美观 必须备案域名 gitment 3 简洁 只能登陆github评论 Disqus 1 需要翻*墙 Valine1.1. 获取APP ID 和 APP Key 请先登录或注册 LeanCloud, 进入控制台后点击左下角创建应用， 进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了。 1.2. 填写APP ID 和 APP Key到主题配置文件_config.yml 1.3. 运行hexo g&amp;&amp;hexo d推送到博客。 来必力/livere2.1. 登陆 来必力 获取你的 LiveRe UID。 2.2. 填写LiveRe UID到主题配置文件_config.yml 畅言3.1.获取APP ID 和 APP Key 请先登录或注册 畅言, 点击“立即免费获取畅言”， 新建站点，点击管理，点击评论插件&gt;评论管理， 点击后台总览，然后就能看到你的APP ID和APP Key了。 3.2. 填写APP ID 和 APP Key到主题配置文件_config.yml 3.3. 运行hexo g&amp;&amp;hexo d推送到博客。 gitment4.1. 安装插件： npm i –save gitment 4.2. 申请应用 在New OAuth App为你的博客应用一个密钥: 1Application name:随便写Homepage URL:这个也可以随意写,就写你的博客地址就行Application description:描述,也可以随意写Authorization callback URL:这个必须写你的博客地址 4.3. 配置 编辑主题配置文件themes/*/_config.yml: 1# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: &#123;you github user id&#125; github_repo: 公开的git仓库,评论会作为那个项目的issue client_id: &#123;刚才申请的ClientID&#125; client_secret: &#123;刚才申请的Client Secret&#125; proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_pro Disqus编辑 主题配置文件themes/*/_config.yml， 将 disqus 下的 enable 设定为 true，同时提供您的 shortname。count 用于指定是否显示评论数量。 1disqus: enable: false shortname: count: true 数据统计与分析 推荐指数 优点 缺点 不蒜子 4 可直接将访问次数显示在您在网页上（也可不显示） 只计数 百度统计 3 收录慢 不蒜子编辑 主题配置文件 themes/*/_config.yml中的busuanzi_count的配置项即可。 当enable: true时，代表开启全局开关。 若site_uv（本站访客数）、site_pv（本站访客数）、page_pv（本文总阅读量）的值均为false时，不蒜子仅作记录而不会在页面上显示。 注意： 1不蒜子官方因七牛强制过期原有的『dn-lbstatics.qbox.me』域名（预计2018年10月初），与客服沟通数次无果，即使我提出为此付费也不行，只能更换域名到『busuanzi.ibruce.info』！ 解决办法： 找到主题调用不蒜子的swig文件。一般在”\\themes*\\layout_third-party\\analytics\\busuanzi-counter.swig” 更改域名 1把原有的：&lt;script async src=&quot;\u0001\u0001//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002&quot;&gt;&lt;/script&gt;域名改一下即可：&lt;script async src=&quot;\u0001\u0001//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002&quot;&gt;&lt;/script&gt; 百度统计 登录 百度统计，定位到站点的代码获取页面 复制统计脚本 id，如图：​ 编辑 主题配置文件themes/*/_config.yml，修改字段 google_analytics，值设置成你的统计脚本 id。 内容分享服务 推荐指数 优点 缺点 百度分享 4 稳定 不太美观 need-more-share2 4 美观 更新不及时（比如微信分享API） 百度分享编辑 主题配置文件，添加/修改字段 baidushare，值为 true即可。 1# 百度分享服务baidushare: true need-more-share2编辑 主题配置文件，添加/修改字段 needmoreshare2，值为 true即可。 1needmoreshare2: enable: true 搜索服务 推荐指数 优点 缺点 Local Search 4 配置方便 Swiftype 2 需注册 Algolia 2 需注册 Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 1search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 1# Local searchlocal_search: enable: true 错误分析如果你使用Hexo遇到同样的问题,这里有一些常见问题的解决方案。 YAML Parsing Error1JS-YAML: incomplete explicit mapping pair; a key node is missed at line 18, column 29: last_updated: Last updated: %s 参数中包含冒号，请用加引号，如Last updated: %s 1JS-YAML: bad indentation of a mapping entry at line 18, column 31: last_updated：&quot;Last updated: %s&quot; 字段后面的冒号必须为英文冒号，如：last_updated: 字段冒号后面必须跟一个空格，如：last_updated: “Last updated: %s” EMFILE Error1Error: EMFILE, too many open files 生成大量的文件时，可能遇到EMFILE错误。 可以运行以下命令来增加允许同步I / O操作的数量。 1$ ulimit -n 10000 Process Out of Memory当hexo g时，遇到以下错误： 1FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory 如下，更改hexo-cli文件的第一行，来增大nodejs堆内存.该bug已在新版本修复。 1#!/usr/bin/env node --max_old_space_size=8192 Git Deployment Problems RPC failed 1error: RPC failed; result=22, HTTP code = 403fatal: &apos;username.github.io&apos; does not appear to be a git repository 确保你有你的电脑上设置git正确或尝试使用HTTPS存储库URL。 Error: ENOENT: no such file or directory 这个需要有一定的git的知识，因为可能是由于写错了标签,类别,或文件名，导致本地和github冲突了，Git不能自动合并这一变化所以它打破了自动分支。 解决办法： 检查文章的标签和类别,确保本地和github上是相同的。 合并分支（Commit）。 清除，重构。在站点目录下，命令行（即Git Bash）运行hexo clean和hexo g 手动将站点目录下的public文件夹复制到您的桌面 从你的master分支切换到部署在本地分支。 从桌面复制public文件夹到本地分支。 合并分支到github（Commit）。 切回master分支。 Server Problems1Error: listen EADDRINUSE 你可能使用相同的端口，同时开启了两个Hexo服务器。如果需要同时开启，可以尝试修改端口设置： 1$ hexo server -p 5000 Plugin Installation Problems1npm ERR! node-waf configure build 这个错误可能发生在试图安装一个用Cc++或另一个javascript语言编写的插件。确保您已经安装了正确的编译器在您的计算机上。 Error with DTrace (Mac OS X)1&#123; [Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125; DTrace安装可能有问题，重装: 1$ npm install hexo --no-optional 详见 #1326 Iterate Data Model on Jade or SwigHexo使用仓库的数据模型。这不是一个数组,所以你可能需要将对象转换为iterable。 1&#123;% for post in site.posts.toArray() %&#125;&#123;% endfor %&#125; Data Not Updated一些数据不能更新或新生成的文件的最后一个版本完全相同。清理缓存，再试一次： 1$ hexo clean No command is executed那个不能使用除help、init和version以外的命令行（即Git Bash）时, 有可能时站点目录下的 package.json文件，缺少hexo，如下: 1&#123; &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;3.2.2&quot; &#125;&#125; Escape ContentsHexo使用Nunjucks渲染的页面. { { } }或{ % % }将解析和可能会引起麻烦， 如果要在博文中出现，必须使用三引号： 12 Hello 1​```#### ENOSPC Error (Linux)如果运行命令`$ hexo server` 返回一个错误: Error: watch ENOSPC … 1可以通过运行`$ npm dedupe`或者以下命令行（即Git Bash）： $ echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p 1来增加测试时，你可以看见的文件数量。#### EMPERM Error (Windows Subsystem for Linux)如果在Windows Subsystem for Linux，运行命令`$ hexo server` 返回这个错误: Error: watch /path/to/hexo/theme/ EMPERM 1因为目前在Windows Subsystem for Linux中，有些内容更改时，还不能实时更新到hexo服务器。所以需要重新编译，再启动服务器： $ hexo generate$ hexo server -s 1#### Template render error有时运行命令`$ hexo generate` 返回一个错误: FATAL Something’s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) 1这意味着有些认不出来单词在你的文件，并且很可能在你的新博文,或者配置文件`_config.yml`中，比如缩进错误：错误例子： plugins:hexo-generator-feedhexo-generator-sitemap&lt;!–￼66–&gt; $ hexo new [layout] 123456789101112参数说明：- [layout]可以为以下三种：| 参数名 | 功能 | 文章路径 || :----- | :---------------------- | :------------- || post | 新建博文 | source/_posts || page | 新建页面（如404，分类） | source || draft | 草稿 | source/_drafts |草稿可通过一下命令发布： $ hexo publish [layout] ``` title注意： 不是博文标题， 是博文markdown文件的名字， 也是博文链接的后缀（如https://lifei-2019.github.io/typora/中的typora） 文章模版 创建模版 在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： $ hexo new blog “simon” 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 blog.md，并根据其内容建立文章。 修改参数 以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 Front-matter就是博文最上方以 --- 分隔的那部分。 默认可以使用的Front-matter： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址","updated":"2019-11-28T02:18:05.616Z","link":"","tags":[{"name":"hexo","slug":"hexo","permalink":"https://lifei-2019.github.io/tags/hexo/"}]},{"title":"浅析《海边的卡夫卡》","date":"2019-10-10T10:50:52.000Z","path":"kafuka/","text":"大约刚好一个月看完了《海边的卡夫卡》，头一次看村上的书，海边的卡夫卡由奇数章和偶数章两个故事交替展开，并在最后交叉在一起。 奇数章以第一人称平叙田村卡夫卡君在现实世界中的闯荡与心理活动。偶数章则是以第三人称讲述因一次意外丧失全部记忆、失去理解能力的中田先生，他以空白的躯壳过着简单的生活。在两条线的交汇处，田村应验了父亲的诅咒：你迟早会杀掉你的父亲，并与你的母亲交合。田村以中田的身躯杀掉了父亲，然后中田在无意识中踏上了关闭”世界之门”的旅程。之后中田的线与田村君的内心旅程是密切关联的。中田面对的是外部世界的不堪与罪恶，田村君面对的是内心中的诱惑与负罪感。田村在受过一种类似宿命论的诅咒后，在救赎中挣扎的过程，让我深深体会到人性的不堪与美好。 ​ 在田村君以及中田君的经历中，我体会到了一种宿命论的基调，就好似一切都是先定的，人为再怎么努力也无法改变。田村的父亲曾经恶毒地诅咒他：你迟早要用你的双手杀死父亲，迟早要同你母亲交合。他为了挣脱这个诅咒，才选择自我放逐，然而最终没有摆脱这个诅咒，所有的一一应验。 ​ 这一设定很显然来源于希腊悲剧《俄狄浦斯王》。俄狄浦斯是忒拜国王拉伊俄斯与王后伊俄卡斯忒的儿子。他出生前，拉伊俄斯从阿波罗神处得知他将来会弑父娶母，于是他刚出生就被抛弃于峡谷，结果他被一个老人救起，被后任国王和王后收为养子。长大后他得知这一预言，为了避免预言发生，离开了被他认为亲生的养父养母。逃亡途中与一陌生人吵架，并动怒打死一个老年人，那老人正是他的父亲。到达目的地后，他被拥戴为王，娶了前王后为妻，此即她生母，预言到此全部应验。得知真相后，他刺瞎了自己的双眼，自我放逐。 ​ 俄狄浦斯是一个正直善良的人，可是被毁灭与宿命论困囿，无论如何挣扎反抗都是徒劳，该发生的一点一点地全部发生。这让我想到以前看过的一部电影，叫《十二猴子》，男主是来自未来的一位劳改犯人，科学家们为了阻止十年前的一场毁灭人类的瘟疫，利用时光机将其送回去，希望他能找到这场瘟疫灾难的线索，并进行有效阻止。可他回到过去后却迷恋过去的生活，行动因而受影响，导致最终失败：他在阻止瘟疫携带者进入飞机那一刻被枪杀。更具讽刺意味的是，他被枪杀的现场围满了人，其中一个小孩正是幼年的男主角。 这些宿命论的情节总是在给我们传导一种悲观的论调。它们总是在说：“人在命运面前是苍白无力的，我们无论如何挣扎，都不能改变它!” ​ 那么田村卡夫卡所受的诅咒应验了吗？答案是肯定的。卡夫卡为了避免父亲的恶毒预言出走，反而导致了父亲被杀，母亲也与他进行了交合，只是方式上有些许的不同。在小说的叙述中，是中田杀害了著名的雕塑家田村浩一，也就是卡夫卡的父亲。可奇怪的是卡夫卡在父亲被杀那天昏迷于野外，醒来后他发现自己身上沾满了鲜血，而中田本人事后却滴血未沾。 ​ 这就是村上对于“物语”的运用，只要符合小说旨意，故事的理性与常识逻辑不再重要，在小说中，一切都是可能发生的，故事旨意的优先级远高于常识逻辑。 ​ 以作者的逻辑，父亲的确实是被儿子杀死的，只是方式比较特殊。那么“迟早与母亲交合”的诅咒呢？利用“物语”的解释，应该也是应验了。佐伯（他的母亲）以少女的形象出现在墙上挂有《海边的卡夫卡》的房间内，以“睡着”的姿态与卡夫卡交合，而卡夫卡君没有任何的扭转之力。 ​ 作者为什么要这样安排，把一个心智尚未健全，世界观未成熟、涉世未生的男孩儿写得如此扭曲与不堪？他的不堪与扭曲并不来自于他自身，而是来于他父亲给予的邪恶基因以及父亲对他幼年的诅咒而产生的心理阴影。他选择的逃避之路，恰恰是他的崩坏与重建的道路。故事中他对诅咒的践行，正是他自我重塑“重新发现自我”，摆脱悬于他头上的达摩克里斯之剑的过程，只有通过这一条路，才能净化自我，终结先天留下的恶。 ​ 与其他类似作品不同的是，作者将卡夫卡的“恶”，设定为天性中的“恶”，是遗传的恶基因。他天生就是一个被损毁的人，他的父亲死后，他没有感到任何的悲伤；同他母亲交合时，他也完全可以选择就此打住叫醒母亲。可以说，尽管他如此地糟糕，作者还是给与他各种帮助，灌输以良知，潜移默化得影响，他最终得到救赎。但这种救赎的发起不是别人，正是他自己。最终他认可了自己，他的良知也宽恕了他自身。起初他只是想逃避社会，逃避自己，经历了各种遭遇，他毅然决然选择了自我救赎，重新融入社会，不再自我放逐，开始担负起属于自我的责任。至此，他走向重生，脱离俄狄浦斯王自我毁灭的魔咒。至此，卡夫卡完成了崩坏与救赎的全过程。 ​ 有些时候，命运总是不可违抗的。我们对命运的逃避，往往使我们再次落入命运的圈套。有些事情是作为人类的我们无法逃避的，但这并不代表我们面对它只能引颈待宰。逃避只能更加放大我们天性中的怯懦与消极。面对不可抗拒力，我们要迎其难而上。这是人生必不可少的经历，也可以说他是对我们的考验，这些正是我们从“崩坏”走向“救赎”的节点，正是成长中的转折处。人性往往就在这一点上得以升华，就如鲤鱼跃然跳过龙门！ ​ 不能直面自身自然是可悲的，就好比《禁闭岛》中的男主，他杀害了妻子，却不能接受现实，就患上了一种臆想症。他为了逃避现实中的自我，把自己想象为大义凛然的检察官。那里的工作人员都一同配合他“演戏”，企图让他在自己的角色中找到破绽，从而恢复正常精神，然而他内心极力不想面对自己，在死循环中度过了十余年。 ​ 每个人都带有天性中的恶，当我们每个人反省自己时。或多或少都会找到那个不堪面对的“恶我”。每个人或多或少在自身的经历中放逐过那个“恶我”。换一种定义，可以称之为“阴暗人格”。也许阴暗人格无法被消除，毕竟人是善恶相融合的产物。但面对“恶”，我们必须正视它，对于以前所犯的无意识的恶，我们要承认与反思。正如同基督教中的“原罪”思想，每个人都有罪，只是有些是显性的，有些是隐性的。我们必须发挥人性中光辉的那一面，克服阴暗的一面，自我救赎，自我重塑。基督教中的“救赎”是为了获得上帝的认同，而我们的救赎，则是努力让自我的良知接受自己。对别人的肯定，首先是自我的肯定。 ​ 田村君以孤立无援的状态离开了家门，投入到波涛汹涌的成年人世界之中，那里有企图伤害他的力量。那种力量有时候就在现实之中，有时候则来自现实之外。而与此同时，又有许多人愿意拯救或结果上拯救了他的灵魂。他被冲往世界的尽头，又以自身力量返回，返回之际他已不再是他，他已进入下一阶段。 ​ 于是我们领教了世界何等凶顽，同时又得知世界也可以变得温存和美好。","updated":"2019-11-04T12:30:42.783Z","link":"","tags":[{"name":"读书","slug":"读书","permalink":"https://lifei-2019.github.io/tags/读书/"}]},{"title":"enjoy life！enjoy coding！","date":"2019-10-10T10:33:28.000Z","path":"test/","text":"衷心感谢dalao的教导","updated":"2019-11-06T00:40:26.230Z","link":"","tags":[]},{"title":"webpack-02","date":"2019-03-02T01:40:59.000Z","path":"webpack-02/","text":"在通过vs code 运行webpack进行打包时，报错webpack : 无法加载文件 D:\\nodejs\\node_global\\webpack.ps1，因为在此系统上禁止运行脚本。解决方案： 1、以管理员身份运行vs code 2、执行：get-ExecutionPolicy，显示Restricted，表示状态是禁止的 3、执行：set-ExecutionPolicy RemoteSigned 4、这时再执行get-ExecutionPolicy，就显示RemoteSigned 此时发现再进行打包就没有问题了","updated":"2020-03-06T08:57:50.228Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"webpack","slug":"webpack","permalink":"https://lifei-2019.github.io/tags/webpack/"}]}]