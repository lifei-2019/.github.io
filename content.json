[{"title":"初学爬虫(1)","date":"2021-05-31T03:20:34.000Z","path":"crawlers1/","text":"Github项目地址 1.用自带的urllib.request123456789101112# 爬虫：通过编写程序来获取到互联网上的资源# 百度# 需求：用程序模拟浏览器，输入一个地址，从该网志中获取到资源或者内容from urllib.request import urlopenurl = \"https://baidu.com\"res=urlopen(url)with open(\"mybaidu.html\", mode=\"w\", encoding=\"utf-8\") as f: f.write(res.read().decode(\"utf-8\"))print(\"over\") 此处需要注意 mac默认utf-8 win默认gbk所以要加上encoding=”utf-8” 所以在windows下要写成 open(&quot;xxx&quot;, mode=&quot;abc&quot;, encoding=&quot;utf-8&quot;) 2.用引入的request包2.1爬取百度搜索框12345678910111213# 安装requests# pip install requestsimport requestsquery = input(\"请输入想搜索的\")url=f'http://www.baidu.com/s?wd=&#123;query&#125;'headers =&#123; \"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.36\"&#125;res=requests.get(url, headers=headers)# code为状态码，text网页源码print(res.text) 此处 字符串前加 f 指以f或F 开头的字符串，其中以 {}包含的表达式会进行值替换 字符串前加 l 表示宽字符，unicode字符（ unicode字符集是两个字节组成的。L告示编译器使用两个字节的 unicode 字符集） 如 L”我的字符串” 表示将ANSI字符串转换成unicode的字符串，就是每个字符占用两个字节。 字符串前加 r 可防止字符串转义 2.2爬取百度翻译返回值1234567891011121314151617181920212223import requestsurl =\"https://fanyi.baidu.com/sug\"s = input(\"请输入你要翻译的字符串\")dat =&#123; \"kw\":s &#125;# 发送post请求resp=requests.post(url,data=dat)# 将服务器返回的内容直接处理成json() =&gt;dictprint(resp.json())resp.close()# 另一种方法s# resp.encoding=resp.apparent_encoding# print(resp.apparent_encoding)# # 直接resp.text会出现乱码# print(resp.text.encode('utf-8').decode('unicode_escape'))# resp.close() 此处因python基础薄弱发现两个问题 res.encoding = res.apparent_encoding 解决返回字符串乱码 字符串.encode(‘utf-8’).decode(‘unicode_escape’) 已经爬好的带有\\u5430的字符串转为正常的中文显示字符串 3.数据解析3.1概述包含re解析、bs4解析和xpath解析，因为不需要整个网页的内容只需要其中一小部分。 3.2re解析Regular Expression 在线正则表达式测试网站 1234567891011121314151617. 匹配除了换行符以外的一个任意字符\\w 字母数字下划线\\s 任意的空白符\\d 数字\\n 一个换行符\\t 一个制表符^ 字符串的开始$ 字符串的结尾\\W 非字母数字下划线\\D 非数字\\S 非空白符a|b 字符a或字符b() 表示一个组[...] 字符组中的字符[^...] 除了字符组中的所有字符 123456* 重复零次或者更多次+ 重复一次或更多次? 重复零次或者一次&#123;n&#125; 重复n次&#123;n,&#125;重复n次或者更多次&#123;n,m&#125;重复n次到m次 12.* 贪婪匹配.*? 惰性匹配","updated":"2021-05-31T07:51:22.484Z","link":"","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://lifei-2019.github.io/tags/爬虫/"}]},{"title":"cybersec1","date":"2020-10-09T07:50:29.000Z","path":"cybersec1/","text":"谜团在线靶机平台 OWASP开放式Web应用程序安全项目 Juice Shop由OWASP主办的开源项目，具有大量安全漏洞的web应用程序 1、找到计分板 1.1 猜测有一个指向计分板但为被超链接的URL，知道他的存在，可以简单猜测计分板可能具有的URL。 把URL后面的search换成score-board即可查看 1.2 代码审计，因为现在页面都是渲染可能不在html里，要去js里面搜索 2.搜索框嵌入代码算是XSS攻击 3.和机器人对话拿到coupon code pEw8pfFb1k 4.进入网站的ftp服务器 点击进入文件路径如下 http://671fbc2b92594c2eb1473c9c2e44abfb.app.mituan.talentsec.cn:3000/ftp/legal.md 去掉/legal.md后即可进入ftp服务器 逻辑漏洞（区别于开发漏洞） 比如说买了一个苹果汁和-3个苹果派最后都不用付钱就可以买 5.exposed metrics url最后一部分改为metrics 6.失踪的编码 在photo-wall中看到图片猫，审查元素看到图片地址，将两个#号url先编码成%23再访问即可 /assets/public/images/uploads/😼-%23zatschi-%23whoneedsfourlegs-1572600969477.jpg （未完待续）","updated":"2020-10-09T09:45:48.261Z","link":"","tags":[{"name":"网安","slug":"网安","permalink":"https://lifei-2019.github.io/tags/网安/"}]},{"title":"力扣刷题总结","date":"2020-09-07T10:18:48.000Z","path":"interview6/","text":"本文主要是对刷题过程中遇到的一些技巧进行总结。 js中的&gt;&gt;和&gt;&gt;&gt;运算符js中的&gt;&gt;表示有符号位移，&gt;&gt;&gt;表示无符号位移，当操作一个正数的时候，两者无差别。 123410&gt;&gt;1// 510&gt;&gt;&gt;15 因为10的二进制是1010，向右移动一个就是101，十进制里代表5 但是如果是对于负数，相差就很大 1234-2&gt;&gt;1// -1-2&gt;&gt;&gt;1// 2147483647 -2在计算机中是以补码存在(补码=反码+1)，也就是11111111111111111111111111111110（32位，4个字节） 1.如果是&gt;&gt;1，表示有符号的位移，右面移去了一个0，左面补充了一个1 2.如果是&gt;&gt;&gt;1，表示无符号的位移，右面移去了一个0，左面补充了一个0（无视正数，负数，一直补充0，即把有符号数转为无符号数字），变成01111111111111111111111111111111，现在变成了一个正数（首位数0表示正，1表示负数），就是2147483647。 n | 0 和0的位或运算可以用于返回32位带符号整数。 a**ba的b平方 深拷贝arr.slice(start, end)返回一个数组的一段 可使用负值从数组的尾部选取元素。 如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。 arr.concat()连接两个或多个数组 利用JSON.stringify和JSON.parse只针对json数据这样的键值对有效 js遍历数组的方法由于数组内部属性值为引用对象，因此使用slice和concat对对象数组的拷贝，整个拷贝还是浅拷贝，拷贝之后数组各个值的指针还是指向相同的存储地址。 因此，slice和concat这两个方法，仅适用于对不包含引用对象的一维数组的深拷贝（一般数组对象现在没什么问题） 123456function deepCopy(arry1, arry2)&#123; var length = arry1.length; for(var i = 0;i&lt;length;i++)&#123; arry2[i] = arry1[i]; &#125;&#125;","updated":"2021-05-26T02:36:55.788Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"面试","slug":"面试","permalink":"https://lifei-2019.github.io/tags/面试/"}]},{"title":"面试篇(2)","date":"2020-09-03T11:47:55.000Z","path":"interview5/","text":"本文接上篇博客面试篇(1) 问题来源: 阿里盒马前端五面问题总结 eventloop宏任务（Macrotasks）：js同步执行的代码块，setTimeout、setInterval、XMLHttprequest、setImmediate、I/O、UI rendering等。 微任务（Microtasks）：promise、process.nextTick（node环境）、Object.observe, MutationObserver等。 微任务比宏任务要牛逼一点 浏览器执行的顺序： (1)执行主代码块，这个主代码块也是宏任务 (2)若遇到Promise，把then之后的内容放进微任务队列 (3)遇到setTimeout，把他放到宏任务里面 (4)一次宏任务执行完成，检查微任务队列有无任务 (5)有的话执行所有微任务 (6)执行完毕后，开始下一次宏任务。 举例：去窗口办理业务正常 task 同志你好，这是我的资料 好的，我现在处理。处理完了，请下一位 Promise 同志你好，这是我资料 你这资料这没填对，你这样，你填完后重新排到队尾好吧，咱们别阻碍别人的业务 好的好的，谢谢 setTimeout 同志你好，这是我资料 你的证件带了吗？ 哎！我忘家了，我现在回去拿！ 哎 …，你回去拿哈，回来了重新叫号重新排队 好的好的，不好意思同志 所以 Promise 的优先级会高于 setTimeout。micro-tasks 列队结束后会(通常)会触发一次 update rendering。整个流程差不多是： 有没有 macrotask 任务？有就来一个 有没有 microtask 任务？有就把这个列队的任务全弄完 弄完了，需要更新视图(update rendering)吗？需要就更新 上代码！ 上面的执行结果是2，1。从规范上来讲，setTimeout有一个4ms的最短时间，也就是说不管你设定多少，反正最少都要间隔4ms才运行里面的回调。而Promise的异步没有这个问题。 从具体实现上来说，这两个的异步队列不一样，Promise所在的那个异步队列优先级要高一些。具体讲解看第二个例子： 执行结果1，2，3，5，4 为什么执行这样的结果？ 1、创建Promise实例是同步执行的。所以先输出1，2，3，这三行代码都是同步执行。 2、promise.then和setTimeout都是异步执行，会先执行谁呢？ setTimeout异步会放到异步队列中等待执行。 promise.then异步会放到microtask queue中。microtask队列中的内容经常是为了需要直接在当前脚本执行完后立即发生的事，所以当同步脚本执行完之后，就调用microtask队列中的内容，然后把异步队列中的setTimeout放入执行栈中执行，所以最终结果是先执行promise.then异步，然后再执行setTimeout异步。 这是由于：Promise 的回调函数属于异步任务，会在同步任务之后执行。但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。 注意：目前microtask队列中常用的就是promise.then。 1234567891011setTimeout(() =&gt; &#123; console.log(7)&#125;, 0)new Promise((resolve, reject) =&gt; &#123; console.log(3); resolve(); console.log(4);&#125;).then(() =&gt; &#123; console.log(6)&#125;)console.log(5) 执行结果3，4，5，6，7 参考掘金的一篇文章 ES5和ES6对象继承有几种方式，都是如何实现的呢？1.构造继承（当然构造继承又有三种实现方式，如下） 借用构造函数（constructor stealing）的技术（有时候也叫做伪造对象或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。别忘了，函数只不过是在特定环境中执行代码的对象，因此通过使用 apply()和 call()方法也可以在（将来）新创建的对象上执行构造函数，如下所示 冒充继承 1234567891011121314151617181920function Person(name,age)&#123; this.name = name ; this.age = age; this.showName = function()&#123; console.log('我是'+name); &#125;&#125;/** * @description 以自身运行环境运行函数，这时函数内的this均指向Child， * 因此父类的属性全部移植到子类中 */function Child()&#123; //这三句代码最关键 this.temp = Person; //创建一个自身缓存函数并将父类构造赋值 this.temp('李端','26'); delete this.temp;//删除缓存函数&#125;var child = new Child();child.showName();//我是李端 绑定this方式实现 1234567891011121314151617function Person(name,age)&#123; this.name = name ; this.age = age; this.showName = function()&#123; console.log('我是'+name); &#125;&#125;/** * @description 以自身运行环境运行函数，这时函数内的this均指向Child， * 因此父类的属性全部移植到子类中 */function Child()&#123; Person.bind(this)('李端','26'); //绑定this到Person运行环境执行函数&#125;var child = new Child();child.showName();//我是李端 call的方式实现 123456789101112function Person(name,age)&#123; this.name = name ; this.age = age; this.showName = function()&#123; console.log('我是'+name); &#125;&#125;function Child()&#123; Person.call(this,'李端','26');&#125;;var child = new Child();child.showName(); apply方式实现 123456789101112function Person(name,age)&#123; this.name = name ; this.age = age; this.showName = function()&#123; console.log('我是'+name); &#125; &#125; function Child()&#123; Person.apply(this,['李端','26']); &#125;; var child = new Child(); child.showName(); 2.原型继承1234567891011121314function Person(name,age)&#123; this.name = name; this.age = age;&#125;Person.prototype.sayHello = function()&#123; alert('使用原型得到'+this.name);&#125;var per = new Person('李端','26');per.sayHello();//创建新对象并实现继承function Student()&#123;&#125;;Student.prototype = new Person('端瑞','23')var stu = new Student();stu.sayHello(); 3.组合继承（组合构造和原型方式实现继承） 组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。下面来看一个例子 12345678910111213141516171819202122232425262728function SuperType(name)&#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;; function SubType(name, age)&#123; //继承属性 SuperType.call(this, name); this.age = age;&#125; //继承方法SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;;var instance1 = new SubType(\"Nicholas\", 29);instance1.colors.push(\"black\");alert(instance1.colors); //\"red,blue,green,black\"instance1.sayName(); //\"Nicholas\";instance1.sayAge(); //29var instance2 = new SubType(\"Greg\", 27);alert(instance2.colors); //\"red,blue,green\"instance2.sayName(); //\"Greg\";instance2.sayAge(); //27 4.寄生继承 寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，并且同样也是由克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。以下代码示范了寄生式继承模式。在这个例子中，createAnother()函数接收了一个参数，也就是将要作为新对象基础的对象。然后，把这个对象（original）传递给 object()函数，将返回的结果赋值给 clone。再为 clone 对象添加一个新方法 sayHi()，最后返回 clone 对象。可以像下面这样来使用 createAnother()函数： 12345678910111213function createAnother(original)&#123; var clone = Object(original); //通过调用函数创建一个新对象 clone.sayHi = function()&#123; //以某种方式来增强这个对象 alert(\"hi\"); &#125;; return clone; //返回这个对象&#125;var person = &#123; name: \"Nicholas\", friends: [\"Shelby\", \"Court\", \"Van\"]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); //\"hi\" 5.寄生组合继承 寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示 1234567891011121314151617181920212223function inheritPrototype(subType, superType)&#123; var prototype = Object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125;function SuperType(name)&#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;; 6.es6继承代码量少，易懂 12345678910111213141516171819202122232425262728//class 相当于es5中构造函数//class中定义方法时，前后不能加function，全部定义在class的protopyte属性中//class中定义的所有方法是不可枚举的//class中只能定义方法，不能定义对象，变量等//class和方法内默认都是严格模式//es5中constructor为隐式属性class People&#123; constructor(name=&apos;wang&apos;,age=&apos;27&apos;)&#123; this.name = name; this.age = age; &#125; eat()&#123; console.log(`$&#123;this.name&#125; $&#123;this.age&#125; eat food`) &#125;&#125;//继承父类class Woman extends People&#123; constructor(name = &apos;ren&apos;,age = &apos;27&apos;)&#123; //继承父类属性 super(name, age); &#125; eat()&#123; //继承父类方法 super.eat() &#125; &#125; let wonmanObj=new Woman(&apos;xiaoxiami&apos;); wonmanObj.eat(); ES5继承和ES6继承的区别 es5继承首先是在子类中创建自己的this指向，最后将方法添加到this中 Child.prototype=new Parent() || Parent.apply(this) || Parent.call(this) es6继承是使用关键字先创建父类的实例对象this，最后在子类class中修改this Element-ui按需引入可以看我之前写的博客 webpack优化缩小文件搜索范围Webpack从Entry出发递归解析导入语句寻找相应的依赖，在项目庞大的时候，文件量大增，递归解析速度明显的下降。 减少被loader匹配到的文件数,通过include缩小搜索范围。 1include:path.resolve(_dirname,&apos;src&apos;) //只对src目录下的文件进行处理 reolve.modules 指定第三方模块的目录，默认情况下，webpack会先从./node_modules，如果未找到则在从../node_modules，依次沿上级目录寻找。当第三方模块固定在./node_modules时就不需要递归寻找。 123resolve:&#123; modules:[path.resolve(_dirname,&apos;node_modules&apos;)],&#125; resolve.alias 对于某些庞大的第三方库，替换其导入路径，直接使用打包完成最小的min文件，例如React 12345resolve:&#123; alias:&#123; &apos;react&apos;:path.resolve(_dirname,&apos;./node_modules/react/dist/react.min.js&apos;), &#125;&#125; 使用该方法的缺点是会影响Tree-Shaking，一般对于整体性较强的库来使用。 * resolve.extensions配置 指定默认的匹配的后缀，减少不必要的尝试 123resolve:&#123; extensions:[&apos;js&apos;,&apos;css&apos;]&#125; module.noParse配置 让webpack忽略没有采用模块化标准的文件，不用去递归解析这一部分，如JQuery 1noParse:[/react\\.min\\.js%/], //忽略react.min.js DllPlugin 动态链接库动态链接库的思想 将网页依赖的基础模块抽离，打包到一个个单独的动态链接中。（一个链接可包括多个模块） 当导入的模块存在于动态链接库中时，模块不用再次被打包，直接从动态链接库中获取 页面依赖的动态链接库都需要被加载 原理可以把DLL看做一个代码仓库，这个代码仓库里面拷贝了程序所需要的库函数，并且把这些函数存储在一个独立的文件里。项目编译时的时候并不会把其加入编译之后，而是当程序运行时需要调用到里面的函数时，动态的将函数地址传给调用程序 构建速度的对性能提升很大，因为动态链接库只用编译一次，之后的构建都不会再编译动态链接库中的模块了。 使用DllPlugin需要两个webpack的内部插件 DllPlugin插件 用于打包出一个个单独的动态链接库文件 DllReferencePlugin插件 引入Dllplugin打包好的动态链接库文件 步骤 * 新建一个webpack配置文件用于打包输出Dll文件 12345678910111213141516171819module.export = &#123; entry :&#123; react:[&apos;react&apos;,&apos;react-dom&apos;], &#125;, output:&#123; //输出的动态库的文件名称 filename:&apos;[name].dll.js&apos;, path:path.resolve(_dirname,&apos;dist&apos;), //存放动态库的全局变量名称 library:&apos;_dll_[name]&apos; &#125;, plugins:[ new DllPlugin(&#123; //动态库的全局变量名称，name和output.library一致，其实是manifest.json中的name值 name:&apos;_dll_[name]&apos;, path:path.join(_dirname,&apos;dist&apos;,&apos;[name]_manifest.json&apos;), &#125;), ]&#125; 打包过后的会生成两个文件文件 react_manifest.json1234567891011121314151617181920&#123; //文件暴露在全局变量中的名称 &quot;name&quot;: &quot;_dll_react&quot;, &quot;content&quot;: &#123; //每个模块 &quot;./node_modules/_react@16.6.3@react/index.js&quot;: &#123; &quot;id&quot;: 0, &quot;buildMeta&quot;: &#123; &quot;providedExports&quot;: true &#125; &#125;, &quot;./node_modules/_object-assign@4.1.1@object-assign/index.js&quot;: &#123; &quot;id&quot;: 1, &quot;buildMeta&quot;: &#123; &quot;providedExports&quot;: true &#125; &#125;, ......... &#125;&#125; react.dll.js其中react_manifest.json描述了对应的dll.js文件包含了哪些模块，每个模块的路径，id。当进行编译的时候，main.js入口文件遇到dll.js中的模块时，能够通过dll.js文件暴露的全局变量_dll_react直接获取。 使用动态链接库文件 12345678910111213module.exports = &#123; entry: &apos;./src/index.js&apos;, output: &#123; filename: &apos;[name]_[hash:8].js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;, plugins: [ new DllReferencePlugin(&#123; //告诉webpack使用的动态链接库 manifest:require(&apos;./dist/react_manifest.json&apos;), &#125;) ] &#125; web-dev-server的优化自动刷新的原理 向网页中注入代理客户端代码，代理客户端和webpack通过Websocket通信控制刷新整个网页 将要开发的网页放进iframe中，通过刷新iframe来刷新整个网页 代理客户端刷新当项目输出多个chunk的时候，devserver并不知道网页依赖于哪个chunk，于是简单的粗暴向所有的chunk都注入代理客户端，导致问题就是当输出的chunk变多的时候，编译速度明显的下降。有两种方式可以优化其构建速度 - 关闭不是很好用的inline模式，--inline false，这样devser会采用第二种方式刷新网页方式，将网页放入iframe中，通过访问localhost.cn:8080/webpack-dev-server就能够访问到原来的网页。 - 手动向网页注入代理客户端脚本，向index.html插入&lt;script src=&quot;localhost.cn:8080/webpack-dev-server&quot;&gt;&lt;/script&gt; 模块热替换模块热替换与自动刷新原理相似，都是在网页中注入一个代理客户端来连接webpack和网页。 原理模块热替换会对源码进行相应的处理 假设现在有两个js文件，一个main.js,一个appcomponent.js，main.js是appcomponent.js的父组件。当开启hmr的时候，hotmodule会去改变main.js的源码如下 1234567//加入了module.hot，accepet第一个参数是代表要接收哪些子模块的替换，第二个参数是子模块发生变化的回调函数if(module.hot)&#123; module.hot.accepet([&apos;./AppComponent&apos;],()=&gt;&#123; render(&lt;AppComponent/&gt;,window.getElementById(&quot;app&quot;)); &#125;); &#125;)&#125; 当修改了appcomponent.js的时候，appcomponent的模块更新就会一层一层的往上传，直到某层文件接收当前文件的变化，例如上面的main.js接收appcomponent.js的更新之后，就会调用回调函数，将APPComponent重新替换掉，来实现不刷新使网页变化。但是如果修改的是最外层的main.js就会刷新整个网页。当模块发生变化后，事件一层一层的上传，但是到最后也没有相应的文件来接收变化，就会刷新整个网页。 作者：Mondo链接：https://zhuanlan.zhihu.com/p/88602013来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 happypack多线程执行webpack执行预处理文件时单线程的，我们可以使用happypack来多线程处理文件。 安装 1npm i happypack -D 使用 修改webpack.base.js文件 123456789101112131415161718192021222324252627const happyThreadPool = HappyPack.ThreadPool(&#123; size: os.cpus().length &#125;);module: &#123; rules: [ &#123; test: /\\.js$/, loader: &apos;happypack/loader?id=babel&apos;, // 原始loader替换成`happypack/loader` include: [resolve(&apos;src&apos;)] &#125; ]&#125;,plugins: [ new HappyPack(&#123; // id标识 需要处理的loader id: &apos;babel&apos;, // loader配置和原始配置一样 loaders: [ &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [&apos;es2015&apos;], cacheDirectory: true &#125; &#125; ], threadPool: happyThreadPool &#125;)] 富文本编辑器内部要显示脚本?转义？禁止一些tag和属性值？ （具体不太了解） async和await的es5实现(先空着)","updated":"2020-09-09T11:07:52.132Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"面试","slug":"面试","permalink":"https://lifei-2019.github.io/tags/面试/"}]},{"title":"项目小技巧","date":"2020-08-25T09:02:24.000Z","path":"interview4/","text":"这是实习期间对自己碰到的一些小技巧进行整理 Vue的href动态拼接绑定123&lt;template slot-scope=&quot;scope&quot;&gt; &lt;a :href=&quot;&apos;http://192.168.21.19:8088/orgparameter/file/getFileInfo?fileName=&apos;+scope.row.fileName+&apos;&amp;version=&apos;+scope.row.version&quot; :download=&quot;scope.row.fileName&quot;&gt;下载&lt;/a&gt;&lt;/template&gt; 注意点：href前面要加“：”或者v-bind: 字符串要用单引号“ ‘’ ”包住 加上了冒号是为了动态绑定数据，等号后面可以写变量。如果不使用冒号，等号后面就可以写字符串等原始类型数据。这是就无法进行动态绑定数据了 字符串太长用“…”点开查看更多1234567&lt;template slot-scope=&quot;scope&quot;&gt; &lt;div&gt; &lt;div v-if=&quot;scope.row.describe &amp;&amp; scope.row.describe.length&lt;=10&quot;&gt;&#123;&#123; scope.row.describe &#125;&#125;&lt;/div&gt; &lt;div v-if=&quot;scope.row.describe &amp;&amp; scope.row.describe.length&gt;10 &amp;&amp; !scope.row.showAll&quot;&gt;&#123;&#123; scope.row.describe.substr(0,20)+&apos;...&apos; &#125;&#125;(&lt;span class=&quot;more&quot; @click=&quot;scope.row.showAll=true&quot;&gt;查看更多&lt;/span&gt;)&lt;/div&gt; &lt;div v-if=&quot;scope.row.describe &amp;&amp; scope.row.describe.length&gt;10 &amp;&amp; scope.row.showAll&quot;&gt;&#123;&#123; scope.row.describe &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; postcss.config.js 作用&amp;配置 给postcss用的 postcss 是帮我们后处理css ，css已经编译完成了，在stylus-loader编译成css之后，在通过postcss优化css，通过一系列组件去优化，比如以下，通过autoprefixer 添加css前缀 1234567const autoprefixer = require(&apos;autoprefixer&apos;)module.exports = &#123; plugins: [ autoprefixer() ]&#125; Vue 使用Scss预处理Css，在使用深度作用选择器修改局部ui默认样式时，/deep/报错不生效深度作用选择器有&gt;&gt;&gt;和别名/deep/&gt;&gt;&gt;基本在纯css中使用，类似Sass，less的Css预编译器一般都用/deep/。 出现的问题最近在写项目的时候（使用eslint-standard代码校验），我用Sass(dart-Sass)使用/deep/修改局部默认ui样式的时候，发现终端报错，并指明是/deep/这块的错误。报错如下! 无奈我只好另起一个style去写纯Css去修改默认ui样式。之后经过一番查找，了解到现在可以使用::v-deep去代替/deep/ 123::v-deep .el-scrollbar__wrap &#123; overflow-x: hidden;&#125; 如此，成功修改默认ui样式，类名前缀成功添加！ vue-cli3项目解决npm run dev在浏览器打开两次的问题 删掉vue.config.js文件里面devServer下面的 open:true 在package.json文件 scripts对象 dev键后面加 –open，（”dev”: “vue-cli-service serve –open”） ok 重新运行npm run dev (修改配置文件后要重新启动项目修改才会生效） jenkins的时间格式Jenkins时间表使用的UNIX知名的Cron语法 Cron语法包括以空格分隔的五个字段，示意如下： 1234567* * * * *第一个* 分钟 [0,59]第二个* 小时 [0,23]第三个* 月的一天 [1,31]第四个* 月 [1,12]第五个* 周的一天 [0,7] 0和7是星期日123456 值的范围表示方法 12* 9-17 * * * 表示每天上午9点和下午17点之间的每一分钟1 间隔的时间表示方法 12345H/2 * * * * 表示每隔2分钟H H/2 * * * 表示每隔2小时H H H/2 * * 表示每隔2天H H H H/2 * 表示每隔2个月H H 10-17 * 6 表示每隔每个月的10-17号的每个星期六","updated":"2020-09-16T01:49:24.577Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"面试","slug":"面试","permalink":"https://lifei-2019.github.io/tags/面试/"}]},{"title":"Typescript","date":"2020-08-23T01:53:20.000Z","path":"Typescript/","text":"Typescript简介TypeScript是由微软公司在2012年正式发布，现在也有8年的不断更新和维护了，TypeScript的成长速度是非常快的，现在已经变成了前端必会的一门技能。TypeScript其实就是JavaScript的超集，也就是说TypeScript是建立在JavaScript之上的，最后都会转变成JavaScript。这就好比漫威里的钢铁侠，没穿装甲之前，他实力一般，虽然聪明有钱，但还是接近人类。但是有了装甲，他就厉害太多了，甚至可以和神干一架。 TypeScript开发环境搭建如果你想使用TypeScript来编写代码，你需要先安装一下它的开发环境，这并不复杂。 1.安装Node的运行环境你可以到Node.js官网去下载Node进行安装(https://node.js.org)，建议你下载LTS版本,也就是长期支持版本。安装的过程我就不演示了，这个过程就和安装QQ一样，没有任何难度。 如果你已经安装了，可以打开命令行工具，然后使用node -v命令查看安装的版本，但是一般还有一个命令需要检测一下，就是npm -v,如果两个命令都可以输出版本号，说明你的Node安装已经没有任何问题了。 2.全局安装TypeScript你要使用TypeScript先要在你的系统中全局安装一下TypeScript，这里你可以直接在VSCode中进行安装，安装命令可以使用npm也可以使用yarn 12npm install typescript -gyarn global add typescript 这两个你使用那个都是可以的，根据喜好自行选择，我在视频中使用的npm进行安装。 3.建立项目目录和编译TS文件在E盘(当然你可以在你喜欢的任何一个地方安装)，新建一个目录，我这里起的目录名字叫做TypeScriptDemo，然后把这个文件在VSCode中打开。 我在视频里用了命令行的形式建立，直接使用ctrl+r打开运行，然后在运行的文本框里输入cmd，回车后，打开命令行工具，在命令行中输入下面的命令。 12e:mkdir TypeScriptDemo 完成后，打开E盘，打开VSCode，把新建立的文件夹拖入到VSCode当中，新建一个demo1.ts`文件，写入下面代码： 123456function jsfei()&#123; let web: string=\"Hello World\" console.log(web)&#125;jsfei() 这时候你使用node demo1.ts是执行不成功的，因为Node不能直接运行TypeScript文件，需要用tsc demo1.ts转换一下，转换完成后typeScript代码被编译成了javaScript代码,新生成一个demo1.js的文件，这时候你在命令行输入node demo1.js,在终端里就可以顺利的输出jsfei的字符了。 4.ts-node的安装和使用但是这样操作的效率实在是太低了，你可以使用ts-node插件来解决这个问题，有了这个插件，我们就不用再编译了，而使用ts-node就可以直接看到编写结果。 使用npm命令来全局安装，直接在命令行输入下面的命令： 1npm install -g ts-node 安装完成后，就可以在命令中直接输入如下命令，来查看结果了。 1ts-node Demo1.ts TypeScript的静态类型TypeScript的一个最主要特点就是可以定义静态类型，英文是Static Typing。那到底是什么意思那？太复杂的概念性东西这里就不讲了，你可以简单的理解“静态类型”为，就是你一旦定义了，就不可以再改变了。比如你是男人就是男人，一辈子都要作男人；是女人就是女人，一辈子都是女人。这个事不可以改变！呃….好像现在也可以随便变来变去啊，这里说的是正常情况。但是它还有一些特性，这个并不像表面的那么简单。现在我们就来学习。 如何定义静态类型建立一个新的demo2.ts文件，然后写下这段代码： 1const count : number = 1; 这就是最简单的定义一个数字类型的count的变量，这里的: number就是定义了一个静态类型。这样定义后count这个变量在程序中就永远都是数字类型了，不可以改变了。比如我们这时候给count复制一个字符串，它就报错了。 123//错误代码const count : number = 1;count = 'jsfei' 但这只是最简单的理解，再往深一层次理解，你会发现这时候的count变量,可以使用number类型上所有的属性和方法。我们可以通过在count后边打上一个.看出这个特性，并且编辑器会给你非常好的提示。这也是为什么我喜欢用VScode编辑器的一个原因。 自定义静态类型你还可以自己去定义一个静态类型，比如现在你定义一个小姐姐的类型，然后在声明变量的时候，就可以使用这个静态类型了，看下面的代码。 123456789interface XiaoJieJie &#123; uname: string , age:number&#125; const xiaohong : XiaoJieJie =&#123; uname: '小红', age: 18&#125; 这时候你如果声明变量，跟自定义不一样，VSCode直接就会报错。需要注意的是，这时候xiaohong变量也具有uname和age属性了。 这个地方你需要记住的是，如果使用了静态类型，不仅意味着变量的类型不可以改变，还意味着类型的属性和方法也跟着确定了。这个特点就大大提高了程序的健壮性，并且编辑器这时候也会给你很好的语法提示，加快了你的开发效率。 随着你不断的深入学习，你会对这两个优点有更深的理解。 TypeScript基础静态类型和对象类型在TypeScript静态类型分为两种，一种是基础静态类型，一种是对象类型，这两种都经常使用，非常重要，我们先来看一下什么是基础静态类型。 基础静态类型基础静态类型非常简单，只要在声明变量的后边加一个:号，然后加上对应的类型哦。比如下面的代码，就是声明了一个数字类型的变量，叫做count。 12const count : number = 918;const myName ：string = 'jsfei' 类似这样常用的基础类型还有，我这里就举几个最常用的哦,null,undefinde,symbol,boolean，void这些都是最常用的基础数据类型，至于例子，我这里就不详细的写了，后面碰到，我们再继续讲解。 对象类型我们先来看一个例子，通过例子有经验的小伙伴就知道个大概了，然后我们再来讲解。新建一个文件demo3.ts（你可以跟我不一样）,然后写下如下代码。 12345678const xiaoJieJie:&#123; name:string, age:number&#125; = &#123; name:'大脚', age:18&#125;console.log(xiaoJieJie.name) 写完后，我们在terminal（终端）中输入ts-node demo3.ts，可以看到结果输出了大脚。这就是一个经典的对象类型，也是最简单的对象类型。对象类型也可以是数组，比如现在我们需要很多小姐姐，我们就可以这样写。 1const xiaoJieJies : String [] = ['谢大脚','刘英','小红'] 这时候的意思是，变量xiaoJieJies必须是一个数组，数组里的内容必须是字符串。你可以试着把字符串改为数字，VSCode会直接给我们报错。 1const xiaoJieJies : String [] = ['谢大脚','刘英',123] 现在都讲究面向对象编程，我这面向对象编程这么多年了，也没再多编出来一个。我们再来看看下面的代码。这个代码就是用类的形式，来定义变量。 12class Person&#123;&#125;const dajiao : Person = new Person() 这个意思就是dajiao必须是一个Person类对应的对象才可以。我们还可以定义一个函数类型，并确定返回值。代码如下： 1const jianXiaoJieJie : ()=&gt; string =()=&gt;&#123;return '大脚'&#125; 那我们现在总结一下对象类型可以有几种形式： 对象类型 数组类型 类类型 函数类型 这几种形式我们在TypeScript里叫做对象类型。 TypeScript中的类型注释和类型推断TypeScript中的两个基本概念：类型注解和类型推断，这两个概念在我们编写TypeScript代码时会一直使用(重点)，但很多教程都没有讲解，不过在官方文档中有比较好的解释。你现在可能还不能完全理解我说的这两个概念，但是你看完文章后就会有很直观的了解啦。 type annotation 类型注解这个概念我们在前三节课中一直使用，只是我没明确这个概念和关系，所以你会觉的很陌生。这就好比，你身边有一个特别漂亮的姑娘，她一直很喜欢你，你也很喜欢她，但窗户纸一直没捅破，直到有一天你们喝多后，去了如家酒店（谈了谈心），你们的关系就明确了。 学程序并没有这么复杂，我们直接点，新建一个文件demo4.ts ,然后看代码： 12let count : number; count = 123 这段代码就是类型注解，意思是显示的告诉代码，我们的count变量就是一个数字类型，这就叫做类型注解。是不是一下就明白了，其实程序这东西就这么简单，真正复杂的是人。 type inferrence 类型推断当你明白了类型注解的概念之后，再学类型推断就更简单了，先来看一段代码。还是在Demo4.ts文件中写入下面的代码。 1let countInference = 123 这时候我并没有显示的告诉你变量countInference是一个数字类型，但是如果你把鼠标放到变量上时，你会发现TypeScript自动把变量注释为了number（数字）类型，也就是说它是有某种推断能力的，通过你的代码TS会自动的去尝试分析变量的类型。这个就彷佛是人的情商比较高，还没等女生表白那，你就已经看出她的心思。 工作使用问题（潜规则） 如果 TS 能够自动分析变量类型， 我们就什么也不需要做了 如果 TS 无法分析变量类型的话， 我们就需要使用类型注解 先来看一个不用写类型注解的例子： 123const one = 1;const two = 2;const three = one + two; 再来看一个用写类型注解的例子： 12345function getTotal(one , two)&#123; return one + two&#125;const total = getTotal(1,2) 这种形式，就需要用到类型注释了，因为这里的one和two会显示为any类型。这时候如果你传字符串，你的业务逻辑就是错误的，所以你必须加一个类型注解，把上面的代码写成下面的样子。 12345function getTotal(one : number, two :number)&#123; return one + two&#125;const total = getTotal(1,2) 这里有的一个问题是，为什么total这个变量不需要加类型注解，因为当one和two两个变量加上注解后，TypeScript就可以自动通过类型推断，分析出变量的类型。 当然TypeScript也可以推断出对象中属性的类型，比如现在写一个小姐姐的对象，然后里边有两个属性。 1234const XiaoJieJie = &#123; name:'刘英', age:18&#125; 写完后你把鼠标放在XiaoJieJie对象上面，就会提示出他里边的属性，这表明TypeScript也分析出了对象的属性的类型。 在写TypeScript代码的一个重要宗旨就是每个变量，每个对象的属性类型都应该是固定的，如果你推断就让它推断，推断不出来的时候你要进行注释。 TypeScript函数参数和返回类型定义这节主要学习一下函数的参数类型定义和返回值的定义，学完这节内容后，你会对函数的参数和返回值类型定义都有通透的了解。 简单类型定义上节课我们写了一个getTotal的函数，并且对传入的参数作了定义，我们再复习一遍。 新建一个文件demo5.ts,然后写入代码 12345function getTotal(one : number, two :number)&#123; return one + two&#125;const total = getTotal(1,2) 这时候我们写的代码其实是有一个小坑的，就是我们并没有定义getTotal的返回值类型，虽然TypeScript可以自己推断出返回值是number类型。 但是如果这时候我们的代码写错了，比如写程了下面这个样子。 12345function getTotal(one : number, two :number)&#123; return one + two+ ''&#125;const total = getTotal(1,2) 这时候total的值就不是number类型了，但是不会报错。有的小伙伴这时候可能会说，可以直接给total一个类型注解，比如写成这个样子。 1const total : number =getTotal(1,2) 这样写虽然可以让编辑器报错，但是这还不是很高明的算法，因为你没有找到错误的根本，这时错误的根本是getTotal()函数的错误，所以合适的做法是给函数的返回值加上类型注解，代码如下： 12345function getTotal(one : number, two :number) : number&#123; return one + two&#125;const total = getTotal(1,2) 这段代码就比较严谨了，所以小伙伴们在写代码时，尽量让自己的代码更加严谨。 函数无返回值时定义方法有时候函数是没有返回值的，比如现在定义一个sayHello的函数，这个函数只是简单的terminal打印，并没有返回值。 123function sayHello()&#123; console.log('hello world')&#125; 这就是没有返回值的函数，我们就可以给他一个类型注解void，代表没有任何返回值。 123function sayHello() : void&#123; console.log('hello world')&#125; 如果这样定义后，你再加入任何返回值，程序都会报错。 never返回值类型如果一个函数是永远也执行不完的，就可以定义返回值为never，那什么样的函数是永远也执行不完的那?我们先来写一个这样的函数(比如执行执行的时候，抛出了异常，这时候就无法执行完了)。 1234function errorFuntion() : never&#123; throw new Error() console.log('Hello World')&#125; 还有一种是一直循环，也是我们常说的死循环，这样也运行不完，比如下面的代码： 1234function forNever() : never&#123; while(true)&#123;&#125; console.log('Hello JSPang')&#125; 函数参数为对象(解构)时这个坑有很多小伙伴掉下去过，就是当一个函数的参数是对象时，我们如何定义参数对象的属性类型。我先写个一般javaScript的写法。 12345function add (&#123;one , two&#125;)&#123; return one + two&#125;const total = add(&#123;one:1,two:2&#125;) 在浏览器中你会看到直接报错了，意思是total有可能会是任何类型，那我们要如何给这样的参数加类型注解那？最初你可能会这样写。 12345function add (&#123;one :number , two :number&#125;)&#123; return one + two&#125;const total = add(&#123;one:1,two:2&#125;) 你在编辑器中会看到这种写法是完全错误的。那正确的写法应该是这样的。 12345function add (&#123;one , two &#125; : &#123;one:number, two:number&#125;) :number&#123; return one + two&#125;const three = add(&#123;one:1,two:2&#125;) 如果参数是对象，并且里边只有一个属性时，我们更容易写错。 错误代码如下： 12345function getNumber (&#123;one &#125;:number)&#123; return one; &#125; const one = getNumber(&#123;one:1&#125;) 看着好像没什么问题，但实际这是有问题的，正确的代码应该时这样的。 12345function getNumber (&#123;one &#125; :&#123;one:number&#125;) :number&#123; return one;&#125;const one = getNumber(&#123;one:1&#125;) 这样写才是正确的写法，小伙伴们赶快动手练习一下吧，刚开始学你可能会觉的很麻烦，但是你写的时间长了，你就会发现有规矩还是好的。人向往自由，缺鲜有人能屈驾自由。 TypeScript中数组类型的定义这节课学习一下TypeScript中的数组类型，一般的数组类型定义我们已经接触过了，只是没有单独拿出来讲，所以先来复习一下。 一般数组类型的定义现在我们可以定义一个最简单的数组类型，比如就是数字类型，那么就可以这么写： 1const numberArr = [1,2,3] 这时候你把鼠标放在numberArr上面可以看出，这个数组的类型就是number类型。这是TypeScript通过类型推断自己推断出来的。 如果你要显示的注解，也非常简单，可以写成下面的形式。 1const numberArr:number[] = [1,2,3] 同样道理，如果你的数组各项是字符串，你就可以写成这样。 1const stringArr : string [] = ['a','b','c'] 也就是说你可以定义任意类型的数组，比如是undefined。 1const undefinedArr : undefined[]=[undefined,undefined] 这时候问题来了，如果数组中有多种类型，比如既有数字类型，又有字符串的时候。那我们要如何定义那。 很简单，只要加个()，然后在里边加上|就可以了，具体看代码。 1const arr: ( number| string )[] = [1,'string',2] 数组简单类型的定义就是这样了，并不难。 数组中对象类型的定义如果你作过一些项目，你就会知道真实的项目中数组中一定会有对象的出现。那对于这类带有对象的数组定义就稍微麻烦点了。 比如现在我们要定义一个有很多小姐姐的数组，每一个小姐姐都是一个对象。这是的定义就编程了这样。 1234const xiaoJieJies : &#123;name:string , age:Number&#125;[] = [ &#123;name:'刘英',age:18&#125;, &#123;name:'谢大脚',age:28&#125;] 这种形式看起来比较麻烦，而且如果有同样类型的数组，写代码也比较麻烦，TypeScript为我们准备了一个概念，叫做类型别名(type alias)。 比如刚才的代码，就可以定义一个类型别名，定义别名的时候要以type关键字开始。现在定义一个Lady的别名。 1type Lady = &#123;name:string , age:Number&#125;; 有了这样的类型别名以后哦，就可以把上面的代码改为下面的形式了。 123456type Lady = &#123;name:string , age:Number&#125;;const xiaoJieJies : Lady[] = [ &#123;name:'刘英',age:18&#125;, &#123;name:'谢大脚',age:28&#125;] 这样定义是完全起作用的，比如我们下面在对象里再加入一个属性，这时候编译器就会直接给我们报错了。 这时候有的小伙伴就会问了，我用类进行定义可以吗？答案是可以的，比如我们定义一个Madam的类,然后用这个类来限制数组的类型也是可以的。 123456789class Madam &#123; name: string ; age:number ;&#125;const xiaoJieJies : Madam[] = [ &#123;name:'刘英',age:18&#125;, &#123;name:'谢大脚',age:28&#125;] 可以看到结果，我们这么写也是完全可以的。 TypeScript中元组的使用和类型约束TypeScript中提供了元组的概念，这个概念是JavaScript中没有的。但是不要慌张，其实元组在开发中并不常用，也可能是我的经历还不够。一般只在数据源是CSV这种文件的时候，会使用元组。其实你可以把元组看成数组的一个加强，它可以更好的控制或者说规范里边的类型。 元组的基本应用我们先来看一个数组和这个数组注解的缺点，比如我们有一个小姐姐数组，数组中有姓名、职业和年龄，代码如下： 1const xiaojiejie = ['dajiao','teacher',28] 这时候把鼠标放到xiaojiejie变量上面，可以看出推断出来的类型。我们就用类型注解的形式给他作一个注解，代码如下： 1const xiaojiejie :(string | number)[] = ['dajiao','teacher',28] 这时候你已经增加了代码注解，但是这并不能很好的限制，比如我们把代码改成下面的样子，TypeScript依然不会报错。 1const xiaojiejie :(string | number)[] = ['dajiao',28,'teacher'] 我们只是简单的把数组中的位置调换了一下，但是TypeScript并不能发现问题，这时候我们需要一个更强大的类型，来解决这个问题，这就是元组。 元组和数组类似，但是类型注解时会不一样。 1const xiaojiejie : [string,string ,number] = ['dajiao','teacher',28] 这时候我们就把数组中的每个元素类型的位置给固定住了，这就叫做元组。 元组的使用目前我的工作中不经常使用元组，因为如果要使用元组，完全可以使用对象的形式来代替，但是如果你维护老系统，你会发现有一种数据源时CSV,这种文件提供的就是用逗号隔开的，如果要严谨的编程就需要用到元组了。例如我们有这样一组由CSV提供的（注意这里只是模拟数据）。 123'dajiao','teacher',28'liuying','teacher',18'cuihua','teacher',25 如果数据源得到的数据时这样的，你就可以使用元组了。 12345const xiaojiejies:[string,string,number][]=[ ['dajiao','teacher',28], ['liuying','teacher',18], ['cuihua','teacher',25],] 要搞清楚元组和数组的区别，在理解后能在项目中适当的时候使用不同的类型。 TypeScript中的interface接口现在公司要开始招聘小姐姐了，这时候你需要一些小姐姐的简历投递和自动筛选功能，就是不符合简历要求的会直接被筛选掉，符合的才可以进入下一轮的面试。那最好的解决方法就是写一个接口。TypeScript中的接口，就是用来规范类型的。 Interface接口初步了解现在我们要作一个简历的自动筛选程序，很简单。年龄小于25岁，胸围大于90公分的，可以进入面试环节。我们最开始的写法是这样的。（新建一个文件Demo8.ts,然后编写如下代码） 123456const screenResume=( name:string, age:number,bust:number)=&gt;&#123; age&lt;24 &amp;&amp; bust&gt;=90 &amp;&amp; console.log(name+'进入面试') age&gt;24 || bust&lt;90 &amp;&amp; console.log(name+'你被淘汰')&#125;screenResume('大脚',18,94) 写好后，好像我们的程序写的不错，可以在终端中使用ts-node demo8.ts进行查看。这时候老板又增加了需求，说我必须能看到这些女孩的简历。于是你又写了这样一个方法。 12345const getResume=(name:string,age:number,bust:number)=&gt;&#123; console.log(name+'年龄是：'+age) console.log(name+'胸围是：'+bust)&#125;getResume('大脚',18,94) 这时候问题来了，程序开发中一直强调“代码重用”，两个方法用的类型注解一样，需要作个统一的约束。大上节课我们学了一个类型别名的知识可以解决代码重复的问题，这节课我们就学习一个更常用的语法接口（Interface）. 我们可以把这两个重复的类型注解，定义成统一的接口。代码如下： 12345interface Girl &#123; name : string; age : number; bust : number;&#125; 有了接口后，我们的程序也要作一些修改，需要写成下面的样子。这样就更像是面向对象编程了。 1234567891011121314151617const screenResume=( girl:Girl)=&gt;&#123; girl.age&lt;24 &amp;&amp; girl.bust&gt;=90 &amp;&amp; console.log(girl.name+'进入面试') girl.age&gt;24 || girl.bust&lt;90 &amp;&amp; console.log(girl.name+'你被淘汰')&#125;const getResume=( girl:Girl)=&gt;&#123; console.log(girl.name+'年龄是：'+girl.age) console.log(girl.name+'胸围是：'+girl.bust)&#125;const girl=&#123; name:'大脚', age:18, bust:94&#125;screenResume(girl)getResume(girl) 这时候我们代码就显得专业了很多，以后再用到同样的接口也不怕了，直接使用girl就可以了。 接口和类型别名的区别现在我们学了接口，也学过了类型别名，这两个语法和用处好像一样，我先表个态，确实用起来基本一样，但是也有少许的不同。 类型别名可以直接给类型，比如string，而接口必须代表对象。 比如我们的类型别名可以写出下面的代码： 1type Girl1= stirng 但是接口就不能这样写，它必须代表的是一个对象，也就是说，你初始化girl的时候，必须写出下面的形式. 12345const girl=&#123; name:'大脚', age:18, bust:94&#125; 接口非必选值得定义这节课我们多学一点，因为接口这里的知识点还是挺多的。比如这时候老板又有了新的要求，要求尽量能看到小姐姐的腰围，但是不作强制要求，就是可选值吗。那接口如何定义那？其实typeScript已经为我们准备好了相应的办法，就是在:号前加一个? 比如把Girl的接口写成这样。 123456interface Girl &#123; name : string; age : number; bust : number; waistline ?: number;&#125; 然后我们再修改一下getResume方法，写成这样。 12345const getResume=( girl:Girl)=&gt;&#123; console.log(girl.name+'年龄是：'+girl.age) console.log(girl.name+'胸围是：'+girl.bust) girl.waistline &amp;&amp; console.log(girl.name+'腰围是：'+girl.waistline)&#125; 这时候在定义girl对象的时候，就可以写saistline（腰围），也可以不写了。 好了，这节课就先到这里，Interface(接口)的知识并没有讲完，我们下节课接着讲。 TypeScript中的interface接口2允许加入任意值简历一般是有自由发挥的空间的，所以这时候需要一些任意值，就是自己愿意写什么就写什么。这时候interface接口也是支持的。方法如下： 我们接着上节课的代码，新建一个demo6.ts，然后把上节课代码拷贝过来。 1234567interface Girl &#123; name : string; age : number; bust : number; waistline ?: number; [propname:string]:any;&#125; 这个的意思是，属性的名字是字符串类型，属性的值可以是任何类型。 这时候我们在对象里给一个性别,代码如下： 1234567const girl=&#123; name:'大脚', age:18, bust:94, waistline:21, sex:'女'&#125; 再修改一下代码，这首就没有错误了。 123456const getResume=( girl:Girl)=&gt;&#123; console.log(girl.name+'年龄是：'+girl.age) console.log(girl.name+'胸围是：'+girl.bust) girl.waistline &amp;&amp; console.log(girl.name+'腰围是：'+girl.waistline) girl.sex &amp;&amp; console.log(girl.name+'性别是：'+girl.sex)&#125; 这时候我们的程序是不报错的，但是如果我们去掉刚才的设置，就会报错。 1[propname:string]:any; //去掉 接口里的方法接口里不仅可以存属性，还可以存方法，比如这时候有个say()方法，返回值是string类型。这时候你就不要再想成简历了，你需要更面向对象化的编程，想象成一个人。 12345678interface Girl &#123; name : string; age : number; bust : number; waistline ?: number; [propname:string]:any; say():string;&#125; 加上这个say()方法后，程序马上就会报错，因为我们对象里没有say方法。那我们就要给对象一个say方法 12345678910const girl=&#123; name:'大脚', age:18, bust:94, waistline:21, sex:'女', say()&#123; return '欢迎光临 ，XX公司！！' &#125;&#125; 接口和类的约束我们都知道JavaScript从ES6里是有类这个概念的，类可以和接口很好的结合，我们先来看一个例子。下面的 123class XiaoJieJie implements Girl&#123;&#125; 这时候类会直接报错，所以我们需要把这个类写的完全点。 12345678class XiaoJieJie implements Girl&#123; name=\"刘英\" age=18 bust=90 say()&#123; return '欢迎光临 ，XX公司！！' &#125;&#125; 接口间的继承接口也可以用于继承的，比如你新写一个Teacher接口，继承于Person接口。 123interface Teacher extends Girl&#123; teach():string&#125; 比如这时候老板说了，只看Teacher级别的简历，那我们需要修改getResume()方法。 123456const getResume=( girl:Teacher)=&gt;&#123; console.log(girl.name+'年龄是：'+girl.age) console.log(girl.name+'胸围是：'+girl.bust) girl.waistline &amp;&amp; console.log(girl.name+'腰围是：'+girl.waistline) girl.sex &amp;&amp; console.log(girl.name+'性别是：'+girl.sex)&#125; 修改后，你就会发现下面我们调用getResume()方法的地方报错了,因为这时候传的值必须有Teach方法， 1getResume(girl) 修改girle对象，增加teach（）方法，这时候就不会报错了。 12345678910111213const girl=&#123; name:'大脚', age:18, bust:94, waistline:21, sex:'女', say()&#123; return '欢迎光临 ，XX公司！！' &#125;, teach()&#123; return '我是一个老师' &#125;&#125; 关于接口的知识就讲到这里吧，这基本包含了接口80%的知识，还有些基本不用的语法，我就不讲了。如果课程中遇到，我们再讲。学会了接口，你还需要明白一件事，就是接口只是对我们开发的约束，在生产环境中并没有体现。也可以说接口只是在TypeScript里帮我们作语法校验的工具，编译成正式的js代码，就不会有任何用处了。","updated":"2020-08-24T07:59:18.670Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"}]},{"title":"element-ui全部引入和按需引入","date":"2020-08-14T03:34:25.000Z","path":"element-ui-1/","text":"UI组件–element-ui–全部引入和按需引入主要就是一句话, 如果用到的组件少, 要按需引入, 如果用到的组件很多,就全部引入, 因为按需引入全部的, 和全部引入效果一样 完整引入在 main.js 中写入以下内容： 1234567891011import Vue from &apos;vue&apos;;import ElementUI from &apos;element-ui&apos;;import &apos;element-ui/lib/theme-chalk/index.css&apos;;import App from &apos;./App.vue&apos;;Vue.use(ElementUI);new Vue(&#123; el: &apos;#app&apos;, render: h =&gt; h(App)&#125;); 以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入, 如果自定义主题, 则引入自定义主题. 按需引入借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。 首先，安装 babel-plugin-component： 1234npm install babel-plugin-component -D或者yarn add babel-plugin-component --dev 然后，将 .babel.config.js修改为： 123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;presets&quot;: [[&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]], &quot;plugins&quot;: [ [ &quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;theme-chalk&quot; &#125; ] ]&#125;根据原来的模板文件, 我的改为了:&#123; // presets 加载是倒序的 &quot;presets&quot;: [ [&quot;env&quot;, &#123; &quot;modules&quot;: false, &quot;targets&quot;: &#123; // 市场份额 大于 1%，最近2个大版本，不包括 IE8 &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;] &#125; &#125;], // stage-x 是 Javascript 语法的一些提案，那这部分可能依赖了ES6的语法，解析的时候得先解析这部分到ES6,在把ES6解析成ES5 &quot;stage-2&quot; ], // plugins 优先于 presets进行编译。 &quot;plugins&quot;: [ &quot;transform-vue-jsx&quot;, &quot;transform-runtime&quot;, [ &quot;component&quot;, &#123; &quot;libraryName&quot;: &quot;element-ui&quot;, &quot;styleLibraryName&quot;: &quot;~theme&quot; &#125; ] ]&#125; 接下来，如果你只希望引入部分组件，比如 Button 和 Select，那么需要在 main.js 中写入以下内容： 123456789101112131415import Vue from &apos;vue&apos;;import &#123; Button, Select &#125; from &apos;element-ui&apos;;import App from &apos;./App.vue&apos;;Vue.component(Button.name, Button);Vue.component(Select.name, Select);/* 或写为 * Vue.use(Button) * Vue.use(Select) */new Vue(&#123; el: &apos;#app&apos;, render: h =&gt; h(App)&#125;); 完整组件列表和引入方式（完整组件列表以 components.json 为准） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import Vue from &apos;vue&apos;;import &#123; Pagination, Dialog, Autocomplete, Dropdown, DropdownMenu, DropdownItem, Menu, Submenu, MenuItem, MenuItemGroup, Input, InputNumber, Radio, RadioGroup, RadioButton, Checkbox, CheckboxButton, CheckboxGroup, Switch, Select, Option, OptionGroup, Button, ButtonGroup, Table, TableColumn, DatePicker, TimeSelect, TimePicker, Popover, Tooltip, Breadcrumb, BreadcrumbItem, Form, FormItem, Tabs, TabPane, Tag, Tree, Alert, Slider, Icon, Row, Col, Upload, Progress, Badge, Card, Rate, Steps, Step, Carousel, CarouselItem, Collapse, CollapseItem, Cascader, ColorPicker, Transfer, Container, Header, Aside, Main, Footer, Loading, MessageBox, Message, Notification&#125; from &apos;element-ui&apos;;Vue.use(Pagination);Vue.use(Dialog);Vue.use(Autocomplete);Vue.use(Dropdown);Vue.use(DropdownMenu);Vue.use(DropdownItem);Vue.use(Menu);Vue.use(Submenu);Vue.use(MenuItem);Vue.use(MenuItemGroup);Vue.use(Input);Vue.use(InputNumber);Vue.use(Radio);Vue.use(RadioGroup);Vue.use(RadioButton);Vue.use(Checkbox);Vue.use(CheckboxButton);Vue.use(CheckboxGroup);Vue.use(Switch);Vue.use(Select);Vue.use(Option);Vue.use(OptionGroup);Vue.use(Button);Vue.use(ButtonGroup);Vue.use(Table);Vue.use(TableColumn);Vue.use(DatePicker);Vue.use(TimeSelect);Vue.use(TimePicker);Vue.use(Popover);Vue.use(Tooltip);Vue.use(Breadcrumb);Vue.use(BreadcrumbItem);Vue.use(Form);Vue.use(FormItem);Vue.use(Tabs);Vue.use(TabPane);Vue.use(Tag);Vue.use(Tree);Vue.use(Alert);Vue.use(Slider);Vue.use(Icon);Vue.use(Row);Vue.use(Col);Vue.use(Upload);Vue.use(Progress);Vue.use(Badge);Vue.use(Card);Vue.use(Rate);Vue.use(Steps);Vue.use(Step);Vue.use(Carousel);Vue.use(CarouselItem);Vue.use(Collapse);Vue.use(CollapseItem);Vue.use(Cascader);Vue.use(ColorPicker);Vue.use(Transfer);Vue.use(Container);Vue.use(Header);Vue.use(Aside);Vue.use(Main);Vue.use(Footer);Vue.use(Loading.directive);Vue.prototype.$loading = Loading.service;Vue.prototype.$msgbox = MessageBox;Vue.prototype.$alert = MessageBox.alert;Vue.prototype.$confirm = MessageBox.confirm;Vue.prototype.$prompt = MessageBox.prompt;Vue.prototype.$notify = Notification;Vue.prototype.$message = Message;","updated":"2020-09-08T12:12:00.728Z","link":"","tags":[]},{"title":"3d特效","date":"2020-08-07T03:29:27.000Z","path":"3d特效/","text":"项目地址 使用CSS3创建简单的3D场景 创建场景 rotate(旋转)、skew(扭曲)、scale(缩放)、translate(移动) perspective；perspective-origin transform：translate平移 rotate旋转 translateX(x px) retateX(x deg) [transform-style:preserve-3d]意思是transform操作是对3D进行的 transfom-origin 调整旋转中心x轴left center right y轴 top center bottom z轴 length px transition: &lt;过渡属性名称&gt;&lt;过渡时间&gt;&lt;过渡模式&gt;-weebkit-transition Safari、chrome -moz-transition Firefox -o-transition Opera 过渡模式:​ ease 缓慢开始缓慢结束 ​ linear 匀速 ​ ease-in 缓慢开始 ​ ease-out 缓慢结束 ​ ease-in-out 颜色变色1s： -weebkit-transition: color 1s Drawcontext.moveTo(x,y) 一个点 context.lineTo(x,y) 画线 context.lineWidth 线条宽度 context.strokeStyle 线条颜色 context.fillStyle 填充颜色 context.stroke() 绘制线条 context.fill() 绘制填色块 context.beginPath() 开始绘制一段 context.closePath 结束 Draw an arccontext.arc(centerx,centery,radius,startingAngle,endingAngle,anticlockwise=false) 参数分别对应圆心x、y值、半径、开始弧度、结束弧度、顺/逆时针 其中无论顺/逆时针，0.5π的位置不会变 AnimationsetInterval( function(){ render() uppdate() },50) context.clearRect (x,y,width,height) 对空间内的矩形图像刷新 context.canvas 找到上下文对应的画布","updated":"2020-09-02T14:07:29.054Z","link":"","tags":[{"name":"CSS3","slug":"CSS3","permalink":"https://lifei-2019.github.io/tags/CSS3/"},{"name":"3D","slug":"3D","permalink":"https://lifei-2019.github.io/tags/3D/"},{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"}]},{"title":"面试篇(1)","date":"2020-08-05T08:26:29.000Z","path":"interview3/","text":"阿里盒马前端五面问题总结 1.提交表单，常用的方法有哪些？应用层，通信层发生了哪些过程？ 在form表单提交时我们最常用的方式时get和post，form表单提交时最要注意的就是enctype，enctype属性默认是application/x-www-form-urlencoded. 在get方式时，浏览器会以当前的enctype编码方式将form数据转化成一个字符串，并将改字符串append到url上，以？分割。加载该新的url 在post方式中： 如果form中没有type为file的控件时，form也会以默认enctype进行编码。 如果是具有type为file的控件时，enctype得设置成multipart/form-data，这样浏览器会将表单以控件为单位分割，并为每个部分加上Content-Disposition（form-data或者时file）、content-type（默认值为text/plain）、name等信息，并加上分割符（boundary） 浏览器请求后发生的完整过程 浏览器发送请求后，DNS（Domain Name System）解析域名得到相应的IP地址。 通过域名访问网页 将域名发送到解析域名的服务器上，有很多专门解析.org、.cn、.com等，最主要有一台根域名服务器 找到对应的IP地址 应用层http协议（HyperText Transfer Protocol，超文本传输协议） 发送请求的我们称之为客户端（client）、而做出相应的服务器叫做源服务器（origin server）。在客户端和服务端之间可能存在很多中间层，比如代理，网关，隧道等。 http协议中的请求报文和响应报文（具体格式大家可以百度了解下） 通信层（TCP/IP）： 生成http报文及请求 TCP协议将http请求报文进行分割（为了方便传输），并在每个报文上标记序号和端口号发给网络层（IP协议） 网络层增加作为通信目的的MAC地址后转发给链路层（建立电路连接，整个网络的物理基础，典型协议为以太网和ADSL等） 链路层处理后生成的数据包通过物理层传输到接收端 接收到数据的服务端后按序网上传， TCP连接的三次握手四次挥手 IP协议实现数据传递到对方计算机 解析请求报文并生成响应报文 参考资料：https://blog.csdn.net/weixin_42621338/article/details/87354737 2.post和get的区别，列举一下区别1.get在浏览器后退时无害，不发送请求。post在浏览器后退时会再次发送请求。 2.get参数通常放在url后面传递，post则通常放在Request body中传递。但实际上，get也可以用body少量传值，post也可以在url中少量传值，这在技术上是完全行的通的，只是不符合http的规定 3.get比post更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 4.get在url中传输参数有长度限制，post没有限制。get之所以会限制请求长度，是因为url请求数据量太大对浏览器和服务器都是很大的负担，处理起来有成本，所以浏览器和服务器对单次访问都做了限制。（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。超过的部分，恕不处理。虽然GET可以带request body，也不能保证一定能被接收到。所以此处的不同，是因为HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。所以如果请求参数可能很长很多的话，直接用post即可（如果用get，超过限制，参数传不过去，会报null）！ 5.GET产生一个TCP数据包；POST产生两个TCP数据包（重点区别！）**。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。也就是post请求，第一次将header发送过去，确认服务器和网络没问题可以服务，才会将真正的data数据提交。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ 5.1. GET与POST都有自己的语义，不能随便混用。get从指定的资源获取数据，post是向指定的资源提交数据（使用场景！） 5.2.在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。也就是网络好的话get和post请求效率基本一样，网络不好的时候post对验证请求数据完整性更有优势。 5.3.并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次 联系1.get和post只是http请求的两种方式，底层都是TCP/IP协议进行通信的。大致过程：用户发出http请求（此时用户的电脑也是一个端，有自己的ip，通过socket使用tcp协议传送数据），请求数据包会通过tcp协议通过网络传给解析的ip，ip收到数据之后（可能还会使用tcp协议与其他ip进行数据交互），处理完成之后，再通过tcp协议将结果返回给用户。所以get和post本质并无区别，只是被http规定了不同的行为和方式。 2.之所以有get和post区分，是因为他们底层数据的传输都是基于tcp协议，如果不做区分，网络中都是某一种服务类别，难免会混乱。为了避免这种情况发生，http协议诞生了。HTTP给网络运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给请求包贴上GET的标签（设置method为GET），而且要求把传送的数据放在url中以方便记录。如果是POST请求，在请求数据包贴上POST的标签。 用法1.get：如果主要是为了获取数据，比如一些获取数据的get请求，且加上请求参数的url不会特别大（小于1k还是2k），且最好没有需要保密的字段，则用get请求； 2.post：如果主要是为了提交一些数据，比如提交一些数据给后台保存，删除等（通常是一些写方法），无论是否有一定数据量均可使用post； 3.以上没有严格划分，即使使用post提交请求来get一些数据也是可以的 HTTP常见状态码1××：消息响应 2××：成功响应 3××：重定响应 4××：客户端错误 5××：服务器端错误 500 内部服务器错误404 错误请求，因发送的请求语法错误,服务器无法正常读取。 403 禁止访问客户端没有权利访问所请求内容,服务器拒绝本次请求。 （状态码403通常代表客户端错误，是指的服务器端有能力处理该请求，但是拒绝授权访问。这个状态码类似于401，但是进入该状态后不能再继续进行验证，该访问是长期禁止的，并且与应用逻辑密切相关，比如密码不正确等。） 400 错误请求因发送的请求语法错误,服务器无法正常读取。 （一般会因为前端提交数据的字段名称，或者是字段类型和后台的实体类不一致，导致无法封装。） 401 Unauthorized 未经授权需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过。 200 请求成功PUT 和 DELETE 的请求成功通常并不是响应200OK的状态码而是 204No Content 表示无内容(或者 201Created表示一个资源首次被创建成功)。 206 部分内容Partial Content 206 部分内容，当客户端通过使用range头字段进行文件分段下载时使用该状态码。 状态码206表示服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 301 永久重定向Moved Permanently 301 永久移动，该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的Location:头字段里找到。 尽管标准要求浏览器在收到该响应并进行重定向时不应该修改http method和body，但是有一些浏览器可能会有问题。所以最好是在应对GET 或 HEAD 方法时使用301，其他情况使用308 来替代301。 302 临时重定向Found 302临时移动，该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的Location:头字段里找到。 即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。所以推荐仅在响应 GET 或 HEAD 方法时采用 302 状态码，而在其他时候使用 307 Temporary Redirect 来替代，因为在这些场景下方法变换是明确禁止的。 502 无效网关Bad Gateway 502 网关错误，服务器作为网关且从上游服务器获取到了一个无效的HTTP响应。 bad gateway502代表您所访问的网站出了问题，因为502 Bad Gateway 服务器作为网关或者代理时，是为了完成访问下一个服务器，但该服务器返回了非法的应答。也许是暂时的，也许是的。建议大家稍等一下再从新访问试试。 前端鉴权 HTTP Basic Authentication session-cookie机制 Token验证 OAuth开放授权 1、HTTP Basic Authentication(基本不用)在HTTP中，基本认证是允许http用户代理（浏览器）在请求时，提供用户名和密码的一种方式。是一种十分简单的技术，使用的是HTTP头部字段强制用户访问网络资源，而不是通过cookie、sessionId、登陆页面等非获取访问控制的手段。 很多网页浏览器都支持这个，但是很少可以在公网上使用，因为他并没有为传送凭证提供数据保护，使用简单的base64编码后直接发送，编码可逆且安全性低。还有一个缺点就是用户在打开浏览器的情况下用户无法登出，也就是无法注销你已登录。解决方法一般是服务器准备一个注销的账号，当服务器接收到的账号密码是注销账号时就会注销。 如果用户在没有验证的情况下会返回401状态码提示用户进行授权，基本上就是一种密码机制，中间可能会被截取和修改字段，所以是很不安全的机制。 2、session-cookie机制（用的少）利用服务端的session和浏览器的cookie来实现前后端鉴权，我们知道http是一种无状态的请求，用户请求完成就会关闭。如果要维持状态就需要浏览器第一次请求的时候在服务端创建一个session，session有一个唯一的标识就是sessionId。一般生产sessionId之后经过加密（可不用加密）返回给客户端，以cookie的形式保存在浏览器中。 当下一次请求时就会在请求头中加入cookie信息，服务器取出sessionId与之前生成的sessionId比对是否一致，来判断请求是否合法。 这种方法一般用在老版本的web系统，因为信息也是存储在cookie当中，也有不安全的成分在里面，一般现在的系统也不会采用这种形式的鉴权。 3.token我们输入用户名和密码点击登陆的时候，加入网站是以Token进行鉴权的话，会有以下的步骤产生： 用户名和密码请求登陆 服务端验证是否为数据库用户 成功，下发令牌Token给客户端 客户端以后每次请求都会带上令牌 服务端每次都会验证令牌 其实看起来和上一个的验证方法差不多呀，到底有哪些区别呢？ session和cookie机制是在客户端与服务端之间保持一个状态，服务端创建session对象也是需要开辟一定的内存空间来保存登陆状态的，但是利用Token的话就不会保持状态，只需比对令牌是否有效即可。 也就是说Token是不存储在服务器的，这个Token本身就保存着登陆状态，服务器根据事先定义好的规则进行解密就可以知道该Token是否合理。初次之外，我们知道不只是浏览器是代理客户端，手机APP也是，在手机上面cookie是不起作用的，那么久限制了客户端类型，Token验证就不会有这个问题。 4、OAuth开放授权这种方法用的是最多的，我们常见的一些网站比如CSDN、掘金等都可以利用微信和QQ进行登陆的，无须使用其他的用户名和密码。这种方式就可以省略了很多步骤，使得用户体验良好。 那么它是怎么操作的呢？ 向用户请求授权 用户授权，返回凭证code给第三方（CSDN/掘金） 利用code向授权服务器请求Access Token 返回Access Token 利用Access Token向资源服务器请求用户资源 获取用户资源，登陆成功 OAuth2.0参考资料 5.说说https的内在原理，ssl握手过程先验知识1、对称加密 有流式、分组两种，加密和解密都是使用的同一个密钥。 例如：DES、AES-GCM、ChaCha20-Poly1305等 2、非对称加密 加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。 例如：RSA、DSA、ECDSA、 DH、ECDHE 3、哈希算法 将任意长度的信息转换为较短的固定长度的值，通常其长度要比信息小得多，且算法不可逆。 例如：MD5、SHA-1、SHA-2、SHA-256 等 4、数字签名 签名就是在信息的后面再加上一段内容（信息经过hash后的值），可以证明信息没有被修改过。hash值一般都会加密后（也就是签名）再和信息一起发送，以保证这个hash值不被修改。 具体过程1、获取公钥 （1）提供一个下载公钥的地址，回话前让客户端去下载。（缺点：下载地址有可能是假的；客户端每次在回话前都先去下载公钥也很麻烦）（2）回话开始时，服务器把公钥发给客户端（缺点：黑客冒充服务器，发送给客户端假的公钥） 2、那有木有一种方式既可以安全的获取公钥，又能防止黑客冒充呢？ 那就需要用到终极武器了：SSL 证书（申购） 如上图所示，在第 ② 步时服务器发送了一个SSL证书给客户端，SSL 证书中包含的具体内容有： （1）证书的发布机构CA （2）证书的有效期 （3）公钥 （4）证书所有者 （5）签名 ……… 3、客户端在接受到服务端发来的SSL证书时，会对证书的真伪进行校验，以浏览器为例说明如下： （1）首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验 （2）浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发 （3）如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。 （4）如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密 （5）浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比 （6）对比结果一致，则证明服务器发来的证书合法，没有被冒充 （7）此时浏览器就可以读取证书中的公钥，用于后续加密了 4、所以通过发送SSL证书的形式，既解决了公钥获取问题，又解决了黑客冒充问题，一箭双雕，HTTPS加密过程也就此形成 所以相比HTTP，HTTPS 传输更加安全 （1） 所有信息都是加密传播，黑客无法窃听。 （2） 具有校验机制，一旦被篡改，通信双方会立刻发现。 （3） 配备身份证书，防止身份被冒充。 参考知乎上的文章 6.为什么要用非对称密钥，pms呢？公钥怎么了？1）对称加密：两边需要使用相同的密钥，需要使用一种安全的方式交换密钥，单纯使用对称加密，无法实现密钥交换。 2）非对称加密：只使用非对称加密是可以满足安全性要求的，但是由于非对称加密的计算耗时高于对称加密的2-3个数量级（相同安全加密级别），所以才先使用非对称交换密钥，之后再使用对称加密通信。 先补充说明一下SSL握手过程（算法列表，完整性鉴别，不重数…等细节略）： 客户端获取证书取得服务器公钥仅仅只是一个开始，之后客户端利用这个公钥发送给服务器一个PMS（Pre-Master Secret 前主密钥），双方共享了这个PMS之后利用特定的算法导出这次会话所要使用的对称密钥，然后这次对话的数据全都用这个对称密钥加密（非对称加密的计算开销太大，不能大量使用） 是否每次HTTPS请求都要进行SSL握手？ 并不是。SSL是逻辑上独立于运输层的，并且是面向连接的，所以不管进行几次https请求，也不管tcp连接有没有更新，只要客户和服务器的SSL连接没有终止并且双方没有丢失这段SSL连接的识别号，客户和服务器之间就可以一直使用握手阶段生成的对称密钥进行应用层通信。只有重新进行SSL连接时才会再握手。 7.响应式布局响应式布局：容器大小随窗口大小而变化，一套界面代码对应多种屏幕。 自适应布局：容器大小不随窗口大小而变化，边距随窗口大小而变化。 优点： 智能响应式设计为客户提供了更高的浏览体验。 响应式网站建设比传统网站更适合SEO排名。 可以通过一个网站访问多个终端，从而降低了开发成本。 响应式网页原理解析@media 媒体查询就是根据不同设备给予不同的样式，我们用这个css3中的语句就可以设计我们网站的样式了 这里我们还需要了解下“em”这样一个值，我们平时设计网页大小的时候都是使用的px（这样一个相对于屏幕大小的长度单位），而“em” 这个单位是相对于我们浏览器大小的尺寸单位，因为任意未调整浏览器默认字体高度都是16px,所以我们可以认为1em=16px. 响应式网站=媒体查询+弹性图片@media 媒体查询就是根据不同设备给予不同的样式，我们用这个css3中的语句就可以设计我们网站的样式了 这里我们还需要了解下“em”这样一个值，我们平时设计网页大小的时候都是使用的px（这样一个相对于屏幕大小的长度单位），而“em” 这个单位是相对于我们浏览器大小的尺寸单位，因为任意未调整浏览器默认字体高度都是16px,所以我们可以认为1em=16px. 那么我们知道em这个单位到底有什么用处呢？ 先不要着急我们再来了解下rem这个单位，em是根据浏览器来进行大小评定的单位，而在支持rem的浏览器中，rem是根据HTML标签来进行定位的，他的参考是HTML的根元素。1、IE9/IE10在用于伪元素时或者使用字体简写声明时不支持rem；2、IOS Safari5.0-5.1虽然支持rem，但是在使用媒体查询时不支持rem。如果你的网站面向是IE用户那么还是少量考虑rem了吧。 知道了em和rem那么我是不是就可以通过监控这两个单位表示的数给予不同设备，不同的样式了能？那么我简单写了下面一些内容 1234567891011121314151617181920@media only screen and (max-width: 50em) &#123; header .top ul li a &#123; padding: 0 1rem; &#125;&#125;/*最大宽度为50em的时候给予一些样式设置*/@media only screen and (min-width: 30.0625em) and (max-width: 50em) &#123;&#125;/*在30.0625em和50em之间给予一个样式*/@media only screen and (max-width: 30em) &#123; header .top .tel, header .top ul li:nth-child(3), /*规定属于header里.top的第四个子元素的每个li的*/ header .top ul li:nth-child(4) &#123; display: none; &#125;&#125;/*30em以下给予一个样式*//*大小数据根据你需要对于对应设备的响应而设置*/ 通过上面一段简单的代码我们就可以对我们不同分辨率下网站的显示出来效果做不同的调整，更好的突出我们想展现的页面元素，尤其在移动设备上突出一些我们更想让用户看到的元素，减少我们一些表示意义并不大的元素。 接下来解决一个我们想让在不同设备上都显示出来我们的高清图片这样一个问题，我们把它叫做弹性图片,这就要牵扯到h5的一个新的标签SOURCE,它里面有一个媒体资源类型属性media,可以设置浏览器在什么样的状态下选择什么样的图片就可以做到弹性图片了，下面是一些简单参考代码 12345678910111213141516171819202122232425&lt;dev class=&quot;ad&quot;&gt; &lt;div class=&quot;owl-carousel owl-theme&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;picture&gt; &lt;source srcset=&quot;img/ad001-l.png&quot; media=&quot;(min-width:50em)&quot;&gt; &lt;source srcset=&quot;img/ad001-m.png&quot; media=&quot;(min-width:30em)&quot;&gt; &lt;img src=&quot;img/ad001.png&quot;&gt; &lt;/picture&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;picture&gt; &lt;source srcset=&quot;img/ad002-l.png&quot; media=&quot;(min-width:50em)&quot;&gt; &lt;source srcset=&quot;img/ad002-m.png&quot; media=&quot;(min-width:30em)&quot;&gt; &lt;img src=&quot;img/ad002.png&quot;&gt; &lt;/picture&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;picture&gt; &lt;source srcset=&quot;img/ad003-l.png&quot; media=&quot;(min-width:50em)&quot;&gt; &lt;source srcset=&quot;img/ad003-m.png&quot; media=&quot;(min-width:30em)&quot;&gt; &lt;img src=&quot;img/ad003.png&quot;&gt; &lt;/picture&gt; &lt;/div&gt; &lt;/div&gt;&lt;/dev&gt; 8.dom树和cssom树原理1 根据HTML构建HTML树（DOM） 2 根据CSS构建CSS树（CSSOM） 3 将两棵树合并成一颗渲染树（render tree） 4 Layout布局（文档流，盒模型，计算大小和位置） 5 Paint绘制 （把边框颜色，文字颜色，阴影等画出来） 6 Compose 合成 （根据层叠关系展示画面） 如果DOM或CSSOM被修改，您只能在执行一遍以上的步骤，以确定哪些像素需要在屏幕上进行重新渲染。 优化关键渲染路径就是指最大限度缩短执行上述第一步至第五步耗费的总时间。这样一来，就能尽快将内弄渲染到屏幕上，此外还能缩短首次渲染后屏幕刷新的时间，即为交互式内容实现更高的刷新率。 9.为什么link要在前，script标签要在后面呢？CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染。 JS 阻塞 DOM 解析，但浏览器会”偷看”DOM，预先下载相关资源。 浏览器遇到 &lt;script&gt;且没有defer或async属性的 标签时，会触发页面渲染，因而如果前面CSS资源尚未加载完毕时，浏览器会等待它加载完毕在执行脚本。 所以，&lt;script&gt;最好放底部，&lt;link&gt;最好放头部，如果头部同时有&lt;script&gt;与&lt;link&gt;的情况下，最好将&lt;script&gt;放在&lt;link&gt; 10.XSS攻击1，escapeHTML将&lt; &gt; &amp; “ ‘转成字符实体 使用场景： （1）用户在页面中录入（比如输入框）&lt;script&gt;alert(2);&lt;/script&gt;， js将该内容提交给后端保存 （2）显示时，后端将字符串返回前端；js接收到之后： a, 使用escapeHTML，将字符串转为 &lt;script&gt;alert(2);&lt;/script&gt;此时，浏览器将能正确解析，因为浏览器接收到实体字符后，转成对应的尖括号等。 b, 不使用escapeHTML，浏览器一看到&lt;，便认为是html标签的开始，直接把刚才的字符串当脚本执行了，这就是xss漏洞。 2，unescapeHTML将字符实体转成&lt; &gt; &amp; “ ‘ 使用场景： 后端将已经转义后的内容显示到页面；比如&lt;script&gt;alert(2);&lt;/script&gt;js收到后： a，前端进行unescapeHTML，则可以直接dom操作，将标签显示到页面。 b，前端没有unescapeHTML，则原样输出&lt;script&gt;alert(2);&lt;/script&gt;，但此时并没有执行。 转义字符： 提示：使用实体名而不是数字的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（对实体数字的支持却很好）。 除此之外，还可以限制上传文件的文件类型。","updated":"2020-09-03T12:51:57.428Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"面试","slug":"面试","permalink":"https://lifei-2019.github.io/tags/面试/"}]},{"title":"vue框架篇","date":"2020-07-16T01:53:56.000Z","path":"interview2/","text":"Vue 是如何检测数组和对象变化的？通过代理原型的方式实现。 怎么实现代码原型12345678910111213141516171819202122232425262728293031323334353637methodsToPatch.forEach(function(method) &#123; // cache original method // 获取原方法 var original = arrayProto[method]; // def方法重新定义arrayMethods的method方法，然后将新的取值方法赋值 def(arrayMethods, method, function mutator() &#123; var args = [], len = arguments.length; while (len--) args[len] = arguments[len]; var result = original.apply(this, args); var ob = this.__ob__; var inserted; switch (method) &#123; case 'push': case 'unshift': // [].push(1),[].unshift(1) // arg = [1] inserted = args; break case 'splice': // [1,2,3].splice(0,1,1) // 第三个参数为插入的值 inserted = args.slice(2); break &#125; if (inserted) &#123; ob.observeArray(inserted); &#125; // 监听变化，如果不是插入操作直接循环响应 // 如果是去除数组参数方法，触发一次notify将会重新计算 // 如果仅仅是数字数据，任何操作只需要再次执行一次notify则可以 // 但是如果新增的是一个对象类型，就需要重新监听 // 为什么用角标和length属性不能监听的原因是因为无法触发obj的get方法，所以没法动态监听 // notify change ob.dep.notify(); return result &#125;); &#125;); 正如该题所问，vue对push,pop,splice等方法进行了hack，hack方式很简单，如果加入新对象，对新对象进行响应式化，至于如何响应式化请参考vue源码。 举例来说对于push和unshift会推入一个新的对象到数组里(不管从前还是从后),记录这个加入的对象，并调用Observe方法将加入的对象转换成响应式对象,对于splice方法，如果加入了新对象也是将该对象响应式化。 最后一步是向外抛出数组变化，提醒观察者进行更新。 为什么要对数组单独处理 在Vue现有阶段中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以我们需要对这些操作进行hack，让vue能监听到其中的变化。 存在问题对于Object.defineProperty的缺陷导致如果直接改变数组下标是无法hack的，由于此点，vue提供了$set方法，最新的解决方案当然是利用Proxy对象进行监听，但是Proxy的缺陷在于兼容性，可能会为了性能以及便利而放弃兼容性吧，一切都要看尤大的决定了。 webpack 热更新原理1.当修改了一个或多个文件； 2.文件系统接收更改并通知webpack； 3.webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新； 4.HMR Server 使用webSocket通知HMR runtime 需要更新，HMR运行时通过HTTP请求更新jsonp； 5.HMR运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。 关于HMP: 模块热替换(hot module replacement) 双向绑定和 vuex 是否冲突？当在严格模式中使用 Vuex 时，在属于 Vuex 的 state 上使用 v-model 会比较棘手： 1&lt;input v-model=&quot;obj.message&quot;&gt; 假设这里的 obj 是在计算属性中返回的一个属于 Vuex store 的对象，在用户输入时，v-model 会试图直接修改 obj.message。在严格模式中，由于这个修改不是在 mutation 函数中执行的, 这里会抛出一个错误。 用“Vuex 的思维”去解决这个问题的方法是：给 中绑定 value，然后侦听 input 或者 change 事件，在事件回调中调用一个方法: 123456789101112&lt;input :value=&quot;message&quot; @input=&quot;updateMessage&quot;&gt;// ...computed: &#123; ...mapState(&#123; message: state =&gt; state.obj.message &#125;)&#125;,methods: &#123; updateMessage (e) &#123; this.$store.commit(&apos;updateMessage&apos;, e.target.value) &#125;&#125; 下面是 mutation 函数： 123456// ...mutations: &#123; updateMessage (state, message) &#123; state.obj.message = message &#125;&#125; #双向绑定的计算属性必须承认，这样做比简单地使用“v-model + 局部状态”要啰嗦得多，并且也损失了一些 v-model 中很有用的特性。另一个方法是使用带有 setter 的双向绑定计算属性： 123456789101112&lt;input v-model=\"message\"&gt;// ...computed: &#123; message: &#123; get () &#123; return this.$store.state.obj.message &#125;, set (value) &#123; this.$store.commit('updateMessage', value) &#125; &#125;&#125; webpack 打包 vue 速度太慢怎么办？1.使用webpack-bundle-analyzer对项目进行模块分析生成report，查看report后看看哪些模块体积过大，然后针对性优化，比如项目中引用了常用的UI库element-ui和v-charts等 2.配置webpack的externals ，官方文档的解释：防止将某些import的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖。 所以，可以将体积大的库分离出来： 12345// ...externals: &#123;&apos;element-ui&apos;: &apos;Element&apos;,&apos;v-charts&apos;: &apos;VCharts&apos;&#125; 3.然后在main.js中移除相关库的import 4.在index.html模板文件中，添加相关库的cdn引用，如： 123&lt;script src=&quot;https://unpkg.com/element-ui@2.10.0/lib/index.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/echarts/dist/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/v-charts/lib/index.min.js&quot;&gt;&lt;/script&gt; vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？首先分析原因VUE首页加载过慢，其原因是因为它是一个单页应用，需要将所有需要的资源都下载到浏览器端并解析。 考虑解决办法 1.使用首屏SSR + 跳转SPA方式来优化 2.改单页应用为多页应用，需要修改webpack的entry 3.改成多页以后使用应该使用prefetch的就使用 4.处理加载的时间片，合理安排加载顺序，尽量不要有大面积空隙 5.CDN资源还是很重要的，最好分开，也能减少一些不必要的资源损耗 6.使用Quicklink，在网速好的时候 可以帮助你预加载页面资源 7.骨架屏这种的用户体验的东西一定要上，最好借助stream先将这部分输出给浏览器解析 8.合理使用web worker优化一些计算 React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？这里的n指的是页面的VDOM节点数，这个不太严谨。如果更严谨一点，我们应该应该假设 变化之前的节点数为m，变化之后的节点数为n。 React 和 Vue 做优化的前提是 “放弃了最优解”，本质上是一种权衡，有利有弊。 倘若这个算法用到别的行业，比如医药行业，肯定是不行的，为什么？ React 和 Vue 做的假设是： 检测VDOM的变化只发生在同一层 检测VDOM的变化依赖于用户指定的key 如果变化发生在不同层或者同样的元素用户指定了不同的key或者不同元素用户指定同样的key，React 和 Vue都不会检测到，就会发生莫名其妙的问题。 但是React 认为， 前端碰到上面的第一种情况概率很小，第二种情况又可以通过提示用户，让用户去解决，因此 这个取舍是值得的。 没有牺牲空间复杂度，却换来了在大多数情况下时间上的巨大提升,明智的选择！ 基本概念首先大家要有个基本概念。其实这是一个典型的最小编辑距离的问题，相关算法有很多，比如Git中，提交之前会进行一次对象的diff操作，就是用的这个最小距离编辑算法。 leetcode 有原题目如果想明白这个O(n^3)， 可以先看下这个。 对于树，我们也是一样的，我们定义三种操作，用来将一棵树转化为另外一棵树： 删除 删除一个节点，将它的children交给它的父节点 插入 在children中 插入一个节点 修改 修改节点的值 事实上，从一棵树转化为另外一棵树，我们有很多方式，我们要找到最少的。 直观的方式是用动态规划，通过这种记忆化搜索减少时间复杂度。 算法 由于树是一种递归的数据结构，因此最简单的树的比较算法是递归处理。 详细描述这个算法可以写一篇很长的论文，这里不赘述。 大家想看代码的，这里有一份 确切地说，树的最小距离编辑算法的时间复杂度是O(n^2m(1+logmn)), 我们假设m 与 n 同阶， 就会变成 O(n^3)。 Vue 的响应式原理中 Object.defineProperty 有什么缺陷？ Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应； Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。 Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。 Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法。1. 原生 DOM 操作 vs. 通过框架封装操作。这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。 2. 对 React 的 Virtual DOM 的误解。React 从来没有说过 “React 比原生操作 DOM 快”。React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作… 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。 我们可以比较一下 innerHTML vs. Virtual DOM 的重绘性能消耗： innerHTML: render html string O(template size) + 重新创建所有 DOM 元素 O(DOM size) Virtual DOM: render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change) Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。前面说了，和 DOM 操作比起来，js 计算是极其便宜的。这才是为什么要有 Virtual DOM：它保证了 1）不管你的数据变化多少，每次重绘的性能都可以接受；2) 你依然可以用类似 innerHTML 的思路去写你的应用。 3. MVVM vs. Virtual DOM相比起 React，其他 MVVM 系框架比如 Angular, Knockout 以及 Vue、Avalon 采用的都是数据绑定：通过 Directive/Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作。MVVM 的变化检查是数据层面的，而 React 的检查是 DOM 结构层面的。MVVM 的性能也根据变动检测的实现原理有所不同：Angular 的脏检查使得任何变动都有固定的 O(watcher count) 的代价；Knockout/Vue/Avalon 都采用了依赖收集，在 js 和 DOM 层面都是 O(change)： 脏检查：scope digest O(watcher count) + 必要 DOM 更新 O(DOM change) 依赖收集：重新收集依赖 O(data change) + 必要 DOM 更新 O(DOM change)可以看到，Angular 最不效率的地方在于任何小变动都有的和 watcher 数量相关的性能代价。但是！当所有数据都变了的时候，Angular 其实并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，这个代价在小量更新的时候几乎可以忽略，但在数据量庞大的时候也会产生一定的消耗。 MVVM 渲染列表的时候，由于每一行都有自己的数据作用域，所以通常都是每一行有一个对应的 ViewModel 实例，或者是一个稍微轻量一些的利用原型继承的 “scope” 对象，但也有一定的代价。所以，MVVM 列表渲染的初始化几乎一定比 React 慢，因为创建 ViewModel / scope 实例比起 Virtual DOM 来说要昂贵很多。这里所有 MVVM 实现的一个共同问题就是在列表渲染的数据源变动时，尤其是当数据是全新的对象时，如何有效地复用已经创建的 ViewModel 实例和 DOM 元素。假如没有任何复用方面的优化，由于数据是 “全新” 的，MVVM 实际上需要销毁之前的所有实例，重新创建所有实例，最后再进行一次渲染！这就是为什么题目里链接的 angular/knockout 实现都相对比较慢。相比之下，React 的变动检查由于是 DOM 结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。 Angular 和 Vue 都提供了列表重绘的优化机制，也就是 “提示” 框架如何有效地复用实例和 DOM 元素。比如数据库里的同一个对象，在两次前端 API 调用里面会成为不同的对象，但是它们依然有一样的 uid。这时候你就可以提示 track by uid 来让 Angular 知道，这两个对象其实是同一份数据。那么原来这份数据对应的实例和 DOM 元素都可以复用，只需要更新变动了的部分。或者，你也可以直接 track by $index 来进行 “原地复用”：直接根据在数组里的位置进行复用。在题目给出的例子里，如果 angular 实现加上 track by $index 的话，后续重绘是不会比 React 慢多少的。甚至在 dbmonster 测试中，Angular 和 Vue 用了 track by $index 以后都比 React 快: dbmon (注意 Angular 默认版本无优化，优化过的在下面） 顺道说一句，React 渲染列表的时候也需要提供 key 这个特殊 prop，本质上和 track-by 是一回事。 4. 性能比较也要看场合在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。 初始渲染：Virtual DOM &gt; 脏检查 &gt;= 依赖收集 小量数据更新：依赖收集 &gt;&gt; Virtual DOM + 优化 &gt; 脏检查（无法优化） &gt; Virtual DOM 无优化 大量数据更新：脏检查 + 优化 &gt;= 依赖收集 + 优化 &gt; Virtual DOM（无法/无需优化）&gt;&gt; MVVM 无优化 不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都不是性能，而是它 1) 为函数式的 UI 编程方式打开了大门；2) 可以渲染到 DOM 以外的 backend，比如 ReactNative。 5. 总结以上这些比较，更多的是对于框架开发研究者提供一些参考。主流的框架 + 合理的优化，足以应对绝大部分应用的性能需求。如果是对性能有极致需求的特殊情况，其实应该牺牲一些可维护性采取手动优化：比如 Atom 编辑器在文件渲染的实现上放弃了 React 而采用了自己实现的 tile-based rendering；又比如在移动端需要 DOM-pooling 的虚拟滚动，不需要考虑顺序变化，可以绕过框架的内置实现自己搞一个。 聊聊 Redux 和 Vuex 的设计思想。不管是Vue，还是 React，都需要管理状态（state），比如组件之间都有共享状态的需要。什么是共享状态？比如一个组件需要使用另一个组件的状态，或者一个组件需要改变另一个组件的状态，都是共享状态。 父子组件之间，兄弟组件之间共享状态，往往需要写很多没有必要的代码，比如把状态提升到父组件里，或者给兄弟组件写一个父组件，听听就觉得挺啰嗦。 如果不对状态进行有效的管理，状态在什么时候，由于什么原因，如何变化就会不受控制，就很难跟踪和测试了。如果没有经历过这方面的困扰，可以简单理解为会搞得很乱就对了。 在软件开发里，有些通用的思想，比如隔离变化，约定优于配置等，隔离变化就是说做好抽象，把一些容易变化的地方找到共性，隔离出来，不要去影响其他的代码。约定优于配置就是很多东西我们不一定要写一大堆的配置，比如我们几个人约定，view 文件夹里只能放视图，不能放过滤器，过滤器必须放到 filter 文件夹里，那这就是一种约定，约定好之后，我们就不用写一大堆配置文件了，我们要找所有的视图，直接从 view 文件夹里找就行。 根据这些思想，对于状态管理的解决思路就是：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测。根据这个思路，产生了很多的模式和库，我们来挨个聊聊。 Store 模式最简单的处理就是把状态存到一个外部变量里面，比如:this.$root.$data, 当然也可以是一个全局变量。但是这样有一个问题，就是数据改变后，不会留下变更过的记录，这样不利于调试。 所以我们稍微搞得复杂一点，用一个简单的 Store 模式： 123456789101112var store = &#123; state: &#123; message: &apos;Hello!&apos; &#125;, setMessageAction (newValue) &#123; // 发生改变记录点日志啥的 this.state.message = newValue &#125;, clearMessageAction () &#123; this.state.message = &apos;&apos; &#125;&#125; store 的 state 来存数据，store 里面有一堆的 action，这些 action 来控制 state 的改变，也就是不直接去对 state 做改变，而是通过 action 来改变，因为都走 action，我们就可以知道到底改变（mutation）是如何被触发的，出现错误，也可以记录记录日志啥的。 不过这里没有限制组件里面不能修改 store 里面的 state，万一组件瞎胡修改，不通过 action，那我们也没法跟踪这些修改是怎么发生的。所以就需要规定一下，组件不允许直接修改属于 store 实例的 state，组件必须通过 action 来改变 state，也就是说，组件里面应该执行 action 来分发 (dispatch) 事件通知 store 去改变。这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation)、保存状态快照、历史回滚/时光旅行的先进的调试工具。 这样进化了一下，一个简单的 Flux 架构就实现了。 FluxFlux其实是一种思想，就像MVC，MVVM之类的，他给出了一些基本概念，所有的框架都可以根据他的思想来做一些实现。 Flux把一个应用分成了4个部分： View Action Dispatcher Store 比如我们搞一个应用，显而易见，这个应用里面会有一堆的 View，这个 View 可以是Vue的，也可以是 React的，啥框架都行，啥技术都行。 View 肯定是要展示数据的，所谓的数据，就是 Store，Store 很容易明白，就是存数据的地方。当然我们可以把 Store 都放到一起，也可以分开来放，所以就有一堆的 Store。但是这些 View 都有一个特点，就是 Store 变了得跟着变。 View 怎么跟着变呢？一般 Store 一旦发生改变，都会往外面发送一个事件，比如 change，通知所有的订阅者。View 通过订阅也好，监听也好，不同的框架有不同的技术，反正 Store 变了，View 就会变。 View 不是光用来看的，一般都会有用户操作，用户点个按钮，改个表单啥的，就需要修改 Store。Flux 要求，View 要想修改 Store，必须经过一套流程，有点像我们刚才 Store 模式里面说的那样。视图先要告诉 Dispatcher，让 Dispatcher dispatch 一个 action，Dispatcher 就像是个中转站，收到 View 发出的 action，然后转发给 Store。比如新建一个用户，View 会发出一个叫 addUser 的 action 通过 Dispatcher 来转发，Dispatcher 会把 addUser 这个 action 发给所有的 store，store 就会触发 addUser 这个 action，来更新数据。数据一更新，那么 View 也就跟着更新了。 这个过程有几个需要注意的点： Dispatcher 的作用是接收所有的 Action，然后发给所有的 Store。这里的 Action 可能是 View 触发的，也有可能是其他地方触发的，比如测试用例。转发的话也不是转发给某个 Store，而是所有 Store。 Store 的改变只能通过 Action，不能通过其他方式。也就是说 Store 不应该有公开的 Setter，所有 Setter 都应该是私有的，只能有公开的 Getter。具体 Action 的处理逻辑一般放在 Store 里。 听听描述看看图，可以发现，Flux的最大特点就是数据都是单向流动的。 ReduxFlux 有一些缺点（特点），比如一个应用可以拥有多个 Store，多个Store之间可能有依赖关系；Store 封装了数据还有处理数据的逻辑。 所以大家在使用的时候，一般会用 Redux，他和 Flux 思想比较类似，也有差别。 StoreRedux 里面只有一个 Store，整个应用的数据都在这个大 Store 里面。Store 的 State 不能直接修改，每次只能返回一个新的 State。Redux 整了一个 createStore 函数来生成 Store。 12import &#123; createStore &#125; from &apos;redux&apos;;const store = createStore(fn); Store 允许使用 store.subscribe 方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。这样不管 View 是用什么实现的，只要把 View 的更新函数 subscribe 一下，就可以实现 State 变化之后，View 自动渲染了。比如在 React 里，把组件的render方法或setState方法订阅进去就行。 Action和 Flux 一样，Redux 里面也有 Action，Action 就是 View 发出的通知，告诉 Store State 要改变。Action 必须有一个 type 属性，代表 Action 的名称，其他可以设置一堆属性，作为参数供 State 变更时参考。 1234const action = &#123; type: &apos;ADD_TODO&apos;, payload: &apos;Learn Redux&apos;&#125;; Redux 可以用 Action Creator 批量来生成一些 Action。 ReducerRedux 没有 Dispatcher 的概念，Store 里面已经集成了 dispatch 方法。store.dispatch()是 View 发出 Action 的唯一方法。 123456import &#123; createStore &#125; from &apos;redux&apos;;const store = createStore(fn);store.dispatch(&#123; type: &apos;ADD_TODO&apos;, payload: &apos;Learn Redux&apos;&#125;); Redux 用一个叫做 Reducer 的纯函数来处理事件。Store 收到 Action 以后，必须给出一个新的 State（就是刚才说的Store 的 State 不能直接修改，每次只能返回一个新的 State），这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。 什么是纯函数呢，就是说没有任何的副作用，比如这样一个函数： 1234function getAge(user) &#123; user.age = user.age + 1; return user.age;&#125; 这个函数就有副作用，每一次相同的输入，都可能导致不同的输出，而且还会影响输入 user 的值，再比如： 1234let b = 10;function compare(a) &#123; return a &gt;= b;&#125; 这个函数也有副作用，就是依赖外部的环境，b 在别处被改变了，返回值对于相同的 a 就有可能不一样。 而 Reducer 是一个纯函数，对于相同的输入，永远都只会有相同的输出，不会影响外部的变量，也不会被外部变量影响，不得改写参数。它的作用大概就是这样，根据应用的状态和当前的 action 推导出新的 state： 1(previousState, action) =&gt; newState 类比 Flux，Flux 有些像： 1(state, action) =&gt; state 为什么叫做 Reducer 呢？reduce 是一个函数式编程的概念，经常和 map 放在一起说，简单来说，map 就是映射，reduce 就是归纳。映射就是把一个列表按照一定规则映射成另一个列表，而 reduce 是把一个列表通过一定规则进行合并，也可以理解为对初始值进行一系列的操作，返回一个新的值。 比如 Array 就有一个方法叫 reduce，Array.prototype.reduce(reducer, ?initialValue)，把 Array 整吧整吧弄成一个 newValue。 12345678const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// expected output: 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// expected output: 15 看起来和 Redux 的 Reducer 是不是好像好像，Redux 的 Reducer 就是 reduce 一个列表（action的列表）和一个 initialValue（初始的 State）到一个新的 value（新的 State）。 把上面的概念连起来，举个例子： 下面的代码声明了 reducer： 123456789const defaultState = 0;const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case &apos;ADD&apos;: return state + action.payload; default: return state; &#125;&#125;; createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。 12import &#123; createStore &#125; from &apos;redux&apos;;const store = createStore(reducer); createStore 内部干了什么事儿呢？通过一个简单的 createStore 的实现，可以了解大概的原理（可以略过不看）： 1234567891011121314151617const createStore = (reducer) =&gt; &#123; let state; let listeners = []; const getState = () =&gt; state; const dispatch = (action) =&gt; &#123; state = reducer(state, action); listeners.forEach(listener =&gt; listener()); &#125;; const subscribe = (listener) =&gt; &#123; listeners.push(listener); return () =&gt; &#123; listeners = listeners.filter(l =&gt; l !== listener); &#125; &#125;; dispatch(&#123;&#125;); return &#123; getState, dispatch, subscribe &#125;;&#125;; Redux 有很多的 Reducer，对于大型应用来说，State 必然十分庞大，导致 Reducer 函数也十分庞大，所以需要做拆分。Redux 里每一个 Reducer 负责维护 State 树里面的一部分数据，多个 Reducer 可以通过 combineReducers 方法合成一个根 Reducer，这个根 Reducer 负责维护整个 State。 1234567import &#123; combineReducers &#125; from &apos;redux&apos;;// 注意这种简写形式，State 的属性名必须与子 Reducer 同名const chatReducer = combineReducers(&#123; Reducer1, Reducer2, Reducer3&#125;) combineReducers 干了什么事儿呢？通过简单的 combineReducers 的实现，可以了解大概的原理（可以略过不看）： 1234567891011const combineReducers = reducers =&gt; &#123; return (state = &#123;&#125;, action) =&gt; &#123; return Object.keys(reducers).reduce( (nextState, key) =&gt; &#123; nextState[key] = reducers[key](state[key], action); return nextState; &#125;, &#123;&#125; ); &#125;;&#125;; 流程 再回顾一下刚才的流程图，尝试走一遍 Redux 流程： 1、用户通过 View 发出 Action： 1store.dispatch(action); 2、然后 Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。 1let nextState = xxxReducer(previousState, action); 3、State 一旦有变化，Store 就会调用监听函数。 1store.subscribe(listener); 4、listener可以通过 store.getState() 得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。 1234function listerner() &#123; let newState = store.getState(); component.setState(newState); &#125; 对比 Flux和 Flux 比较一下：Flux 中 Store 是各自为战的，每个 Store 只对对应的 View 负责，每次更新都只通知对应的View： Redux 中各子 Reducer 都是由根 Reducer 统一管理的，每个子 Reducer 的变化都要经过根 Reducer 的整合： 简单来说，Redux有三大原则： 单一数据源：Flux 的数据源可以是多个。 State 是只读的：Flux 的 State 可以随便改。 * 使用纯函数来执行修改：Flux 执行修改的不一定是纯函数。 Redux 和 Flux 一样都是单向数据流。 中间件刚才说到的都是比较理想的同步状态。在实际项目中，一般都会有同步和异步操作，所以 Flux、Redux 之类的思想，最终都要落地到同步异步的处理中来。 在 Redux 中，同步的表现就是：Action 发出以后，Reducer 立即算出 State。那么异步的表现就是：Action 发出以后，过一段时间再执行 Reducer。 那怎么才能 Reducer 在异步操作结束后自动执行呢？Redux 引入了中间件 Middleware 的概念。 其实我们重新回顾一下刚才的流程，可以发现每一个步骤都很纯粹，都不太适合加入异步的操作，比如 Reducer，纯函数，肯定不能承担异步操作，那样会被外部IO干扰。Action呢，就是一个纯对象，放不了操作。那想来想去，只能在 View 里发送 Action 的时候，加上一些异步操作了。比如下面的代码，给原来的 dispatch 方法包裹了一层，加上了一些日志打印的功能： 123456let next = store.dispatch;store.dispatch = function dispatchAndLog(action) &#123; console.log(&apos;dispatching&apos;, action); next(action); console.log(&apos;next state&apos;, store.getState());&#125; 既然能加日志打印，当然也能加入异步操作。所以中间件简单来说，就是对 store.dispatch 方法进行一些改造的函数。不展开说了，所以如果想详细了解中间件，可以点这里。 Redux 提供了一个 applyMiddleware 方法来应用中间件： 1234const store = createStore( reducer, applyMiddleware(thunk, promise, logger)); 这个方法主要就是把所有的中间件组成一个数组，依次执行。也就是说，任何被发送到 store 的 action 现在都会经过thunk，promise，logger 这几个中间件了。 处理异步对于异步操作来说，有两个非常关键的时刻：发起请求的时刻，和接收到响应的时刻（可能成功，也可能失败或者超时），这两个时刻都可能会更改应用的 state。一般是这样一个过程： 请求开始时，dispatch 一个请求开始 Action，触发 State 更新为“正在请求”状态，View 重新渲染，比如展现个Loading啥的。 请求结束后，如果成功，dispatch 一个请求成功 Action，隐藏掉 Loading，把新的数据更新到 State；如果失败，dispatch 一个请求失败 Action，隐藏掉 Loading，给个失败提示。 显然，用 Redux 处理异步，可以自己写中间件来处理，当然大多数人会选择一些现成的支持异步处理的中间件。比如 redux-thunk 或 redux-promise 。 Redux-thunkthunk 比较简单，没有做太多的封装，把大部分自主权交给了用户： 1234567891011121314151617181920212223242526272829303132333435const createFetchDataAction = function(id) &#123; return function(dispatch, getState) &#123; // 开始请求，dispatch 一个 FETCH_DATA_START action dispatch(&#123; type: FETCH_DATA_START, payload: id &#125;) api.fetchData(id) .then(response =&gt; &#123; // 请求成功，dispatch 一个 FETCH_DATA_SUCCESS action dispatch(&#123; type: FETCH_DATA_SUCCESS, payload: response &#125;) &#125;) .catch(error =&gt; &#123; // 请求失败，dispatch 一个 FETCH_DATA_FAILED action dispatch(&#123; type: FETCH_DATA_FAILED, payload: error &#125;) &#125;) &#125;&#125;//reducerconst reducer = function(oldState, action) &#123; switch(action.type) &#123; case FETCH_DATA_START : // 处理 loading 等 case FETCH_DATA_SUCCESS : // 更新 store 等 case FETCH_DATA_FAILED : // 提示异常 &#125;&#125; 缺点就是用户要写的代码有点多，可以看到上面的代码比较啰嗦，一个请求就要搞这么一套东西。 Redux-promiseredus-promise 和 redux-thunk 的思想类似，只不过做了一些简化，成功失败手动 dispatch 被封装成自动了： 12345678910111213141516171819const FETCH_DATA = &apos;FETCH_DATA&apos;//action creatorconst getData = function(id) &#123; return &#123; type: FETCH_DATA, payload: api.fetchData(id) // 直接将 promise 作为 payload &#125;&#125;//reducerconst reducer = function(oldState, action) &#123; switch(action.type) &#123; case FETCH_DATA: if (action.status === &apos;success&apos;) &#123; // 更新 store 等处理 &#125; else &#123; // 提示异常 &#125; &#125;&#125; 刚才的什么 then、catch 之类的被中间件自行处理了，代码简单不少，不过要处理 Loading 啥的，还需要写额外的代码。 其实任何时候都是这样：封装少，自由度高，但是代码就会变复杂；封装多，代码变简单了，但是自由度就会变差。redux-thunk 和 redux-promise 刚好就是代表这两个面。 redux-thunk 和 redux-promise 的具体使用就不介绍了，这里只聊一下大概的思路。大部分简单的异步业务场景，redux-thunk 或者 redux-promise 都可以满足了。 上面说的 Flux 和 Redux，和具体的前端框架没有什么关系，只是思想和约定层面。下面就要和我们常用的 Vue 或 React 结合起来了： VuexVuex 主要用于 Vue，和 Flux，Redux 的思想很类似。 Store每一个 Vuex 里面有一个全局的 Store，包含着应用中的状态 State，这个 State 只是需要在组件中共享的数据，不用放所有的 State，没必要。这个 State 是单一的，和 Redux 类似，所以，一个应用仅会包含一个 Store 实例。单一状态树的好处是能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 Vuex通过 store 选项，把 state 注入到了整个应用中，这样子组件能通过 this.$store 访问到 state 了。 12345678910111213141516171819const app = new Vue(&#123; el: &apos;#app&apos;, // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: &#123; Counter &#125;, template: ` &lt;div class=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; `&#125;)const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; State 改变，View 就会跟着改变，这个改变利用的是 Vue 的响应式机制。 Mutation显而易见，State 不能直接改，需要通过一个约定的方式，这个方式在 Vuex 里面叫做 mutation，更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;) 触发 mutation 事件的方式不是直接调用，比如 increment(state) 是不行的，而要通过 store.commit 方法： 1store.commit(&apos;increment&apos;) 注意：mutation 都是同步事务。 mutation 有些类似 Redux 的 Reducer，但是 Vuex 不要求每次都搞一个新的 State，可以直接修改 State，这块儿又和 Flux 有些类似。具尤大的说法，Redux 强制的 immutability，在保证了每一次状态变化都能追踪的情况下强制的 immutability 带来的收益很有限，为了同构而设计的 API 很繁琐，必须依赖第三方库才能相对高效率地获得状态树的局部状态，这些都是 Redux 不足的地方，所以也被 Vuex 舍掉了。 到这里，其实可以感觉到 Flux、Redux、Vuex 三个的思想都差不多，在具体细节上有一些差异，总的来说都是让 View 通过某种方式触发 Store 的事件或方法，Store 的事件或方法对 State 进行修改或返回一个新的 State，State 改变之后，View 发生响应式改变。 Action到这里又该处理异步这块儿了。mutation 是必须同步的，这个很好理解，和之前的 reducer 类似，不同步修改的话，会很难调试，不知道改变什么时候发生，也很难确定先后顺序，A、B两个 mutation，调用顺序可能是 A -&gt; B，但是最终改变 State 的结果可能是 B -&gt; A。 对比Redux的中间件，Vuex 加入了 Action 这个东西来处理异步，Vuex的想法是把同步和异步拆分开，异步操作想咋搞咋搞，但是不要干扰了同步操作。View 通过 store.dispatch(‘increment’) 来触发某个 Action，Action 里面不管执行多少异步操作，完事之后都通过 store.commit(‘increment’) 来触发 mutation，一个 Action 里面可以触发多个 mutation。所以 Vuex 的Action 类似于一个灵活好用的中间件。 Vuex 把同步和异步操作通过 mutation 和 Action 来分开处理，是一种方式。但不代表是唯一的方式，还有很多方式，比如就不用 Action，而是在应用内部调用异步请求，请求完毕直接 commit mutation，当然也可以。 Vuex 还引入了 Getter，这个可有可无，只不过是方便计算属性的复用。 Vuex 单一状态树并不影响模块化，把 State 拆了，最后组合在一起就行。Vuex 引入了 Module 的概念，每个 Module 有自己的 state、mutation、action、getter，其实就是把一个大的 Store 拆开。 总的来看，Vuex 的方式比较清晰，适合 Vue 的思想，在实际开发中也比较方便。 对比ReduxRedux： view——&gt;actions——&gt;reducer——&gt;state变化——&gt;view变化（同步异步一样） Vuex： view——&gt;commit——&gt;mutations——&gt;state变化——&gt;view变化（同步操作） view——&gt;dispatch——&gt;actions——&gt;mutations——&gt;state变化——&gt;view变化（异步操作） React-reduxRedux 和 Flux 类似，只是一种思想或者规范，它和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。 但是因为 React 包含函数式的思想，也是单向数据流，和 Redux 很搭，所以一般都用 Redux 来进行状态管理。为了简单处理 Redux 和 React UI 的绑定，一般通过一个叫 react-redux 的库和 React 配合使用，这个是 react 官方出的（如果不用 react-redux，那么手动处理 Redux 和 UI 的绑定，需要写很多重复的代码，很容易出错，而且有很多 UI 渲染逻辑的优化不一定能处理好）。 Redux将React组件分为容器型组件和展示型组件，容器型组件一般通过connect函数生成，它订阅了全局状态的变化，通过mapStateToProps函数，可以对全局状态进行过滤，而展示型组件不直接从global state获取数据，其数据来源于父组件。 如果一个组件既需要UI呈现，又需要业务逻辑处理，那就得拆，拆成一个容器组件包着一个展示组件。 因为 react-redux 只是 redux 和 react 结合的一种实现，除了刚才说的组件拆分，并没有什么新奇的东西，所以只拿一个简单TODO项目的部分代码来举例： 入口文件 index.js，把 redux 的相关 store、reducer 通过 Provider 注册到 App 里面，这样子组件就可以拿到 store 了。 12345678910111213import React from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;import &#123; Provider &#125; from &apos;react-redux&apos;import &#123; createStore &#125; from &apos;redux&apos;import rootReducer from &apos;./reducers&apos;import App from &apos;./components/App&apos;const store = createStore(rootReducer)render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(&apos;root&apos;)) actions/index.js，创建 Action： 12345678910111213141516171819let nextTodoId = 0export const addTodo = text =&gt; (&#123; type: &apos;ADD_TODO&apos;, id: nextTodoId++, text&#125;)export const setVisibilityFilter = filter =&gt; (&#123; type: &apos;SET_VISIBILITY_FILTER&apos;, filter&#125;)export const toggleTodo = id =&gt; (&#123; type: &apos;TOGGLE_TODO&apos;, id&#125;)export const VisibilityFilters = &#123; SHOW_ALL: &apos;SHOW_ALL&apos;, SHOW_COMPLETED: &apos;SHOW_COMPLETED&apos;, SHOW_ACTIVE: &apos;SHOW_ACTIVE&apos;&#125; reducers/todos.js，创建 Reducers： 1234567891011121314151617181920const todos = (state = [], action) =&gt; &#123; switch (action.type) &#123; case &apos;ADD_TODO&apos;: return [ ...state, &#123; id: action.id, text: action.text, completed: false &#125; ] case &apos;TOGGLE_TODO&apos;: return state.map(todo =&gt; todo.id === action.id ? &#123; ...todo, completed: !todo.completed &#125; : todo ) default: return state &#125;&#125;export default todos reducers/index.js，把所有的 Reducers 绑定到一起： 12345678import &#123; combineReducers &#125; from &apos;redux&apos;import todos from &apos;./todos&apos;import visibilityFilter from &apos;./visibilityFilter&apos;export default combineReducers(&#123; todos, visibilityFilter, ...&#125;) containers/VisibleTodoList.js，容器组件，connect 负责连接React组件和Redux Store： 1234567891011121314151617181920212223242526import &#123; connect &#125; from &apos;react-redux&apos;import &#123; toggleTodo &#125; from &apos;../actions&apos;import TodoList from &apos;../components/TodoList&apos;const getVisibleTodos = (todos, filter) =&gt; &#123; switch (filter) &#123; case &apos;SHOW_COMPLETED&apos;: return todos.filter(t =&gt; t.completed) case &apos;SHOW_ACTIVE&apos;: return todos.filter(t =&gt; !t.completed) case &apos;SHOW_ALL&apos;: default: return todos &#125;&#125;// mapStateToProps 函数指定如何把当前 Redux store state 映射到展示组件的 props 中const mapStateToProps = state =&gt; (&#123; todos: getVisibleTodos(state.todos, state.visibilityFilter)&#125;)// mapDispatchToProps 方法接收 dispatch() 方法并返回期望注入到展示组件的 props 中的回调方法。const mapDispatchToProps = dispatch =&gt; (&#123; toggleTodo: id =&gt; dispatch(toggleTodo(id))&#125;)export default connect( mapStateToProps, mapDispatchToProps)(TodoList) 简单来说，react-redux 就是多了个 connect 方法连接容器组件和UI组件，这里的“连接”就是一种映射： mapStateToProps 把容器组件的 state 映射到UI组件的 props mapDispatchToProps 把UI组件的事件映射到 dispatch 方法 Redux-saga刚才介绍了两个Redux 处理异步的中间件 redux-thunk 和 redux-promise，当然 redux 的异步中间件还有很多，他们可以处理大部分场景，这些中间件的思想基本上都是把异步请求部分放在了 action creator 中，理解起来比较简单。 redux-saga 采用了另外一种思路，它没有把异步操作放在 action creator 中，也没有去处理 reductor，而是把所有的异步操作看成“线程”，可以通过普通的action去触发它，当操作完成时也会触发action作为输出。saga 的意思本来就是一连串的事件。 redux-saga 把异步获取数据这类的操作都叫做副作用（Side Effect），它的目标就是把这些副作用管理好，让他们执行更高效，测试更简单，在处理故障时更容易。 在聊 redux-saga 之前，需要熟悉一些预备知识，那就是 ES6 的 Generator。 如果从没接触过 Generator 的话，看着下面的代码，给你个1分钟傻瓜式速成，函数加个星号就是 Generator 函数了，Generator 就是个骂街生成器，Generator 函数里可以写一堆 yield 关键字，可以记成“丫的”，Generator 函数执行的时候，啥都不干，就等着调用 next 方法，按照顺序把标记为“丫的”的地方一个一个拎出来骂（遍历执行），骂到最后没有“丫的”标记了，就返回最后的return值，然后标记为 done: true，也就是骂完了（上面只是帮助初学者记忆，别喷~）。 1234567891011121314function* helloWorldGenerator() &#123; yield &apos;hello&apos;; yield &apos;world&apos;; return &apos;ending&apos;;&#125;var hw = helloWorldGenerator();hw.next() // 先把 &apos;hello&apos; 拎出来，done: false 代表还没骂完// &#123; value: &apos;hello&apos;, done: false &#125; next() 方法有固定的格式，value 是返回值，done 代表是否遍历结束hw.next() // 再把 &apos;world&apos; 拎出来，done: false 代表还没骂完// &#123; value: &apos;world&apos;, done: false &#125;hw.next() // 没有 yield 了，就把最后的 return &apos;ending&apos; 拎出来，done: true 代表骂完了// &#123; value: &apos;ending&apos;, done: true &#125;hw.next() // 没有 yield，也没有 return 了，真的骂完了，只能挤出来一个 undefined 了，done: true 代表骂完了// &#123; value: undefined, done: true &#125; 这样搞有啥好处呢？我们发现 Generator 函数的很多代码可以被延缓执行，也就是具备了暂停和记忆的功能：遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值，等着下一次调用next方法时，再继续往下执行。用 Generator 来写异步代码，大概长这样： 123456789101112131415function* gen()&#123; var url = &apos;https://api.github.com/users/github&apos;; var jsonData = yield fetch(url); console.log(jsonData);&#125;var g = gen();var result = g.next(); // 这里的result是 &#123; value: fetch(&apos;https://api.github.com/users/github&apos;), done: true &#125;// fetch(url) 是一个 Promise，所以需要 then 来执行下一步result.value.then(function(data)&#123; return data.json();&#125;).then(function(data)&#123; // 获取到 json data，然后作为参数调用 next，相当于把 data 传给了 jsonData，然后执行 console.log(jsonData); g.next(data);&#125;); 再回到 redux-saga 来，可以把 saga 想象成开了一个以最快速度不断地调用 next 方法并尝试获取所有 yield 表达式值的线程。举个例子： 123456789101112// saga.jsimport &#123; take, put &#125; from &apos;redux-saga/effects&apos;function* mySaga()&#123; // 阻塞: take方法就是等待 USER_INTERACTED_WITH_UI_ACTION 这个 action 执行 yield take(USER_INTERACTED_WITH_UI_ACTION); // 阻塞: put方法将同步发起一个 action yield put(SHOW_LOADING_ACTION, &#123;isLoading: true&#125;); // 阻塞: 将等待 FetchFn 结束，等待返回的 Promise const data = yield call(FetchFn, &apos;https://my.server.com/getdata&apos;); // 阻塞: 将同步发起 action (使用刚才返回的 Promise.then) yield put(SHOW_DATA_ACTION, &#123;data: data&#125;);&#125; 这里用了好几个yield，简单理解，也就是每个 yield 都发起了阻塞，saga 会等待执行结果返回，再执行下一指令。也就是相当于take、put、call、put 这几个方法的调用变成了同步的，上面的全部完成返回了，才会执行下面的，类似于 await。 用了 saga，我们就可以很细粒度的控制各个副作用每一部的操作，可以把异步操作和同步发起 action 一起，随便的排列组合。saga 还提供 takeEvery、takeLatest 之类的辅助函数，来控制是否允许多个异步请求同时执行，尤其是 takeLatest，方便处理由于网络延迟造成的多次请求数据冲突或混乱的问题。 saga 看起来很复杂，主要原因可能是因为大家不熟悉 Generator 的语法，还有需要学习一堆新增的 API 。如果抛开这些记忆的东西，改造一下，再来看一下代码： 1234567function mySaga()&#123; if (action.type === &apos;USER_INTERACTED_WITH_UI_ACTION&apos;) &#123; store.dispatch(&#123; type: &apos;SHOW_LOADING_ACTION&apos;, isLoading: true&#125;); const data = await Fetch(&apos;https://my.server.com/getdata&apos;); store.dispatch(&#123; type: &apos;SHOW_DATA_ACTION&apos;, data: data&#125;); &#125;&#125; 上面的代码就很清晰了吧，全部都是同步的写法，无比顺畅，当然直接这样写是不支持的，所以那些 Generator 语法和API，无非就是做一些适配而已。 saga 还能很方便的并行执行异步任务，或者让两个异步任务竞争： 12345678910// 并行执行，并等待所有的结果，类似 Promise.all 的行为const [users, repos] = yield [ call(fetch, &apos;/users&apos;), call(fetch, &apos;/repos&apos;)]// 并行执行，哪个先完成返回哪个，剩下的就取消掉了const &#123;posts, timeout&#125; = yield race(&#123; posts: call(fetchApi, &apos;/posts&apos;), timeout: call(delay, 1000)&#125;) saga 的每一步都可以做一些断言（assert）之类的，所以非常方便测试。而且很容易测试到不同的分支。 这里不讨论更多 saga 的细节，大家了解 saga 的思想就行，细节请看文档。 对比 Redux-thunk 比较一下 redux-thunk 和 redux-saga 的代码： 和 redux-thunk 等其他异步中间件对比来说，redux-saga 主要有下面几个特点： 异步数据获取的相关业务逻辑放在了单独的 saga.js 中，不再是掺杂在 action.js 或 component.js 中。 dispatch 的参数是标准的 action，没有魔法。 saga 代码采用类似同步的方式书写，代码变得更易读。 代码异常/请求失败 都可以直接通过 try/catch 语法直接捕获处理。 * 很容易测试，如果是 thunk 的 Promise，测试的话就需要不停的 mock 不同的数据。 其实 redux-saga 是用一些学习的复杂度，换来了代码的高可维护性，还是很值得在项目中使用的。 DvaDva是什么呢？官方的定义是：dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。 简单理解，就是让使用 react-redux 和 redux-saga 编写的代码组织起来更合理，维护起来更方便。 之前我们聊了 redux、react-redux、redux-saga 之类的概念，大家肯定觉得头昏脑涨的，什么 action、reducer、saga 之类的，写一个功能要在这些js文件里面不停的切换。 dva 做的事情很简单，就是让这些东西可以写到一起，不用分开来写了。比如： 12345678910111213141516171819202122232425262728293031323334app.model(&#123; // namespace - 对应 reducer 在 combine 到 rootReducer 时的 key 值 namespace: &apos;products&apos;, // state - 对应 reducer 的 initialState state: &#123; list: [], loading: false, &#125;, // subscription - 在 dom ready 后执行 subscriptions: [ function(dispatch) &#123; dispatch(&#123;type: &apos;products/query&apos;&#125;); &#125;, ], // effects - 对应 saga，并简化了使用 effects: &#123; [&apos;products/query&apos;]: function*() &#123; yield call(delay(800)); yield put(&#123; type: &apos;products/query/success&apos;, payload: [&apos;ant-tool&apos;, &apos;roof&apos;], &#125;); &#125;, &#125;, // reducers - 就是传统的 reducers reducers: &#123; [&apos;products/query&apos;](state) &#123; return &#123; ...state, loading: true, &#125;; &#125;, [&apos;products/query/success&apos;](state, &#123; payload &#125;) &#123; return &#123; ...state, loading: false, list: payload &#125;; &#125;, &#125;,&#125;); 以前书写的方式是创建 sagas/products.js, reducers/products.js 和 actions/products.js，然后把 saga、action、reducer 啥的分开来写，来回切换，现在写在一起就方便多了。 比如传统的 TODO 应用，用 redux + redux-saga 来表示结构，就是这样： saga 拦截 add 这个 action, 发起 http 请求, 如果请求成功, 则继续向 reducer 发一个 addTodoSuccess 的 action, 提示创建成功, 反之则发送 addTodoFail 的 action 即可。 如果使用 Dva，那么结构图如下： 整个结构变化不大，最主要的就是把 store 及 saga 统一为一个 model 的概念（有点类似 Vuex 的 Module），写在了一个 js 文件里。增加了一个 Subscriptions, 用于收集其他来源的 action，比如快捷键操作。 123456789101112131415161718192021222324252627282930app.model(&#123; namespace: &apos;count&apos;, state: &#123; record: 0, current: 0, &#125;, reducers: &#123; add(state) &#123; const newCurrent = state.current + 1; return &#123; ...state, record: newCurrent &gt; state.record ? newCurrent : state.record, current: newCurrent, &#125;; &#125;, minus(state) &#123; return &#123; ...state, current: state.current - 1&#125;; &#125;, &#125;, effects: &#123; *add(action, &#123; call, put &#125;) &#123; yield call(delay, 1000); yield put(&#123; type: &apos;minus&apos; &#125;); &#125;, &#125;, subscriptions: &#123; keyboardWatcher(&#123; dispatch &#125;) &#123; key(&apos;⌘+up, ctrl+up&apos;, () =&gt; &#123; dispatch(&#123;type:&apos;add&apos;&#125;) &#125;); &#125;, &#125;,&#125;); 之前我们说过约定优于配置的思想，Dva正式借鉴了这个思想。 MobX前面扯了这么多，其实还都是 Flux 体系的，都是单向数据流方案。接下来要说的 MobX，就和他们不太一样了。 我们先清空一下大脑，回到初心，什么是初心？就是我们最初要解决的问题是什么？最初我们其实为了解决应用状态管理的问题，不管是 Redux 还是 MobX，把状态管理好是前提。什么叫把状态管理好，简单来说就是：统一维护公共的应用状态，以统一并且可控的方式更新状态，状态更新后，View跟着更新。不管是什么思想，达成这个目标就ok。 Flux 体系的状态管理方式，只是一个选项，但并不代表是唯一的选项。MobX 就是另一个选项。 MobX背后的哲学很简单：任何源自应用状态的东西都应该自动地获得。译成人话就是状态只要一变，其他用到状态的地方就都跟着自动变。 看这篇文章的人，大概率会对面向对象的思想比较熟悉，而对函数式编程的思想略陌生。Flux 或者说 Redux 的思想主要就是函数式编程（FP）的思想，所以学习起来会觉得累一些。而 MobX 更接近于面向对象编程，它把 state 包装成可观察的对象，这个对象会驱动各种改变。什么是可观察？就是 MobX 老大哥在看着 state 呢。state 只要一改变，所有用到它的地方就都跟着改变了。这样整个 View 可以被 state 来驱动。 123456789const obj = observable(&#123; a: 1, b: 2&#125;)autoRun(() =&gt; &#123; console.log(obj.a)&#125;)obj.b = 3 // 什么都没有发生obj.a = 2 // observe 函数的回调触发了，控制台输出：2 上面的obj，他的 obj.a 属性被使用了，那么只要 obj.a 属性一变，所有使用的地方都会被调用。autoRun 就是这个老大哥，他看着所有依赖 obj.a 的地方，也就是收集所有对 obj.a 的依赖。当 obj.a 改变时，老大哥就会触发所有依赖去更新。 MobX 允许有多个 store，而且这些 store 里的 state 可以直接修改，不用像 Redux 那样每次还返回个新的。这个有点像 Vuex，自由度更高，写的代码更少。不过它也会让代码不好维护。 MobX 和 Flux、Redux 一样，都是和具体的前端框架无关的，也就是说可以用于 React（mobx-react) 或者 Vue（mobx-vue)。一般来说，用到 React 比较常见，很少用于 Vue，因为 Vuex 本身就类似 MobX，很灵活。如果我们把 MobX 用于 React 或者 Vue，可以看到很多 setState() 和 http://this.state.xxx = 这样的处理都可以省了。 还是和上面一样，只介绍思想。具体 MobX 的使用，可以看这里。 对比 Redux我们直观地上两坨实现计数器代码： Redux： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React, &#123; Component &#125; from &apos;react&apos;;import &#123; createStore, bindActionCreators,&#125; from &apos;redux&apos;;import &#123; Provider, connect &#125; from &apos;react-redux&apos;;// ①action typesconst COUNTER_ADD = &apos;counter_add&apos;;const COUNTER_DEC = &apos;counter_dec&apos;;const initialState = &#123;a: 0&#125;;// ②reducersfunction reducers(state = initialState, action) &#123; switch (action.type) &#123; case COUNTER_ADD: return &#123;...state, a: state.a+1&#125;; case COUNTER_DEC: return &#123;...state, a: state.a-1&#125;; default: return state &#125;&#125;// ③action creatorconst incA = () =&gt; (&#123; type: COUNTER_ADD &#125;);const decA = () =&gt; (&#123; type: COUNTER_DEC &#125;);const Actions = &#123;incA, decA&#125;;class Demo extends Component &#123; render() &#123; const &#123; store, actions &#125; = this.props; return ( &lt;div&gt; &lt;p&gt;a = &#123;store.a&#125;&lt;/p&gt; &lt;p&gt; &lt;button className=&quot;ui-btn&quot; onClick=&#123;actions.incA&#125;&gt;增加 a&lt;/button&gt; &lt;button className=&quot;ui-btn&quot; onClick=&#123;actions.decA&#125;&gt;减少 a&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125;// ④将state、actions 映射到组件 propsconst mapStateToProps = state =&gt; (&#123;store: state&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; // ⑤bindActionCreators 简化 dispatch actions: bindActionCreators(Actions, dispatch)&#125;)// ⑥connect产生容器组件const Root = connect( mapStateToProps, mapDispatchToProps)(Demo)const store = createStore(reducers)export default class App extends Component &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;Root /&gt; &lt;/Provider&gt; ) &#125;&#125; MobX： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import React, &#123; Component &#125; from &apos;react&apos;;import &#123; observable, action &#125; from &apos;mobx&apos;;import &#123; Provider, observer, inject &#125; from &apos;mobx-react&apos;;// 定义数据结构class Store &#123; // ① 使用 observable decorator @observable a = 0;&#125;// 定义对数据的操作class Actions &#123; constructor(&#123;store&#125;) &#123; this.store = store; &#125; // ② 使用 action decorator @action incA = () =&gt; &#123; this.store.a++; &#125; @action decA = () =&gt; &#123; this.store.a--; &#125;&#125;// ③实例化单一数据源const store = new Store();// ④实例化 actions，并且和 store 进行关联const actions = new Actions(&#123;store&#125;);// inject 向业务组件注入 store，actions，和 Provider 配合使用// ⑤ 使用 inject decorator 和 observer decorator@inject(&apos;store&apos;, &apos;actions&apos;)@observerclass Demo extends Component &#123; render() &#123; const &#123; store, actions &#125; = this.props; return ( &lt;div&gt; &lt;p&gt;a = &#123;store.a&#125;&lt;/p&gt; &lt;p&gt; &lt;button className=&quot;ui-btn&quot; onClick=&#123;actions.incA&#125;&gt;增加 a&lt;/button&gt; &lt;button className=&quot;ui-btn&quot; onClick=&#123;actions.decA&#125;&gt;减少 a&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; ); &#125;&#125;class App extends Component &#123; render() &#123; // ⑥使用Provider 在被 inject 的子组件里，可以通过 props.store props.actions 访问 return ( &lt;Provider store=&#123;store&#125; actions=&#123;actions&#125;&gt; &lt;Demo /&gt; &lt;/Provider&gt; ) &#125;&#125;export default App; 比较一下： Redux 数据流流动很自然，可以充分利用时间回溯的特征，增强业务的可预测性；MobX 没有那么自然的数据流动，也没有时间回溯的能力，但是 View 更新很精确，粒度控制很细。 Redux 通过引入一些中间件来处理副作用；MobX 没有中间件，副作用的处理比较自由，比如依靠 autorunAsync 之类的方法。 Redux 的样板代码更多，看起来就像是我们要做顿饭，需要先买个调料盒装调料，再买个架子放刀叉。。。做一大堆准备工作，然后才开始炒菜；而 MobX 基本没啥多余代码，直接硬来，拿着炊具调料就开干，搞出来为止。 但其实 Redux 和 MobX 并没有孰优孰劣，Redux 比 Mobx 更多的样板代码，是因为特定的设计约束。如果项目比较小的话，使用 MobX 会比较灵活，但是大型项目，像 MobX 这样没有约束，没有最佳实践的方式，会造成代码很难维护，各有利弊。一般来说，小项目建议 MobX 就够了，大项目还是用 Redux 比较合适。 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？ key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。 vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 Vue 的 diff 函数中。可以先了解一下 diff 算法。 在交叉对比的时候，当新节点跟旧节点头尾交叉对比没有结果的时候，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点（这里对应的是一个 key =&gt; index 的 map 映射）。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用一种遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。 Vue 部分源码如下： 123456// vue src/core/vdom/patch.js // oldCh 是一个旧虚拟节点数组， if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) 创建 map 函数： 123456789function createKeyToOldIdx (children, beginIdx, endIdx) &#123; let i, key const map = &#123;&#125; for (i = beginIdx; i &lt;= endIdx; ++i) &#123; key = children[i].key if (isDef(key)) map[key] = i &#125; return map&#125; 遍历寻找： 1234567// sameVnode 是对比新旧节点是否相同的函数function findIdxInOld (node, oldCh, start, end) &#123; for (let i = start; i &lt; end; i++) &#123; const c = oldCh[i] if (isDef(c) &amp;&amp; sameVnode(node, c)) return i &#125; &#125; SPA（单页面应用）和MPA（多页面应用） 模式示意图 单页面应用 第一次进入页面时会请求一个html文件，刷新清除一下，切换到其他组件，此时路径也相应变化，但是并没有新的html文件请求，页面内容却变化了。 原理： js会感知到url的变化，通过这一点可以用js动态地将当前页面的内容清除，然后将下一个页面的内容挂载到当前页面上。这个时候的路由不再是后端来做了，而是前端来做，判断页面显示相应的组件，清除不需要的。 页面跳转： js渲染 优点： 页面切换快 缺点： 首屏时间稍慢，SEO差 1. 为什么页面切换快？页面每次切换跳转时，并不需要处理html文件的请求，这样就节约了很多HTTP发送时延，所以我们在切换页面的时候速度很快。 2. 为什么首屏时间慢，SEO 差？单页应用的首屏时间慢，首屏时需要请求一次html，同时还要发送一次js请求，两次请求回来了，首屏才会展示出来。相对于多页面应用，首屏时间慢。 SEO效果差，因为搜索引擎只认识html里的内容，不认识js渲染生成的内容，搜索引擎不识别，也就不会给一个好排名，会导致单页应用做出来的网页在搜索引擎上的排名差。 3. 为什么还要用 Vue 呢？Vue官方提供了一些其他的技术来解决这些缺点，比如服务端渲染技术（SSR），通过这些技术可以完美解决这些缺点，这样一来单页面应用对于前端来说就是非常完美的页面开发解决方案了。 多页面应用 每一次页面跳转的时候，后台服务器都会返回一个新的html文档，这种类型的网站也就是多页网站，也叫多页应用。 页面跳转： 返回HTML 优点： 首屏时间快，SEO效果好 缺点： 页面切换慢 1. 为什么多页应用的首屏时间快？首屏时间叫做页面首个屏幕的内容展现的时间，当我们访问页面的时候，服务器返回一个html，页面就会展示出来，这个过程只经历了一个HTTP请求，所以页面展示的速度非常快。 2. 为什么搜索引擎优化效果好（SEO）？搜索引擎在做网页排名的时候，要根据网页的内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别html内容的，而我们每个页面所有的内容都放在html中，所以这种多页应用SEO排名效果好。 3. 缺点：切换慢每次跳转都需要发送一个HTTP请求，如果网络状态不好，在页面间来回跳转时，就会发生明显的卡顿，影响用户体验。 总结 / 多页面应用模式MPA 单页面应用模式SPA 应用构成 由多个完整页面构成 一个外壳页面和多个页面片段构成 跳转方式 页面之间的跳转是从一个页面到另一个页面 一个页面片段删除或隐藏，加载另一个页面片段并显示。片段间的模拟跳转，没有开壳页面 跳转后公共资源是否重新加载 是 否 URL模式 http://xxx/page1.html和http://xxx/page2.html http://xxx/shell.html#page1和http://xxx/shell.html#page2 用户体验 页面间切换加载慢，不流畅，用户体验差，尤其在移动端 页面片段间切换快，用户体验好，包括移动设备 能否实现转场动画 否 容易实现（手机APP动效） 页面间传递数据 依赖URL、cookie或者localstorage，实现麻烦 页面传递数据容易（Vuex或Vue中的父子组件通讯props对象） 搜索引擎优化（SEO） 可以直接做 需要单独方案（SSR） 特别适用的范围 需要对搜索引擎友好的网站 对体验要求高，特别是移动应用 开发难度 较低，框架选择容易 较高，需要专门的框架来降低这种模式的开发难度","updated":"2020-08-07T07:14:14.574Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"面试","slug":"面试","permalink":"https://lifei-2019.github.io/tags/面试/"}]},{"title":"Eslint入门","date":"2020-07-12T08:13:34.000Z","path":"Eslint/","text":"两个月之前在项目中就开始使用 Eslint ，当时直接 copy 别人的 .eslintrc.js 文件，感觉好复杂，一直没吃透，中间去把 Eslint 官方文档看了数遍，依然无果。今天刚好没事，回过头来想整理一下 Eslint 的使用，突然发现变得好简单。总结下在这过程中走得弯路。 先要知道 Lint 是什么，Eslint 又是什么； 因为想要的太多（想把 Eslint 官方文档里每个字都记住）就容易抓不住重点（目的是在项目中使用 Eslint，这仅仅是个工具，工具又怎么会搞的太难）。 目标学习完本教程希望对下面这个 .eslintrc.js 文件能够做到心里有数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// .eslintrc.js module.exports = &#123; \"extends\": \"airbnb\", \"rules\": &#123; \"semi\": [2, \"never\"], \"no-console\": 0, \"comma-dangle\": [2, \"always-multiline\"], \"max-len\": 0, \"react/jsx-first-prop-new-line\": 0, \"react/jsx-filename-extension\": 0, \"space-before-function-paren\": [2, \"always\"], \"no-unused-expressions\": [0, &#123; \"allowShortCircuit\": true, \"allowTernary\": true &#125;], \"arrow-body-style\": [0, \"never\"], \"func-names\": 0, \"prefer-const\": 0, \"no-extend-native\": 0, \"no-param-reassign\": 0, \"no-restricted-syntax\": 0, \"no-eval\": 0, \"no-continue\": 0, \"react/jsx-no-bind\": 0, \"no-unused-vars\": [2, &#123; \"ignoreRestSiblings\": true &#125;], \"no-underscore-dangle\": 0, \"global-require\": 0, \"import/no-unresolved\": 0, \"import/extensions\": 0, \"jsx-a11y/href-no-hash\": 0, \"react/no-array-index-key\": 0, \"react/require-default-props\": 0, \"react/forbid-prop-types\": 0, \"react/no-string-refs\": 0, \"react/no-find-dom-node\": 0, \"import/no-extraneous-dependencies\": 0, \"import/prefer-default-export\": 0, \"react/no-danger\": 0, \"jsx-a11y/no-static-element-interactions\": 0, &#125;, \"parser\": \"babel-eslint\", \"parserOptions\": &#123; \"sourceType\": \"module\", \"ecmaVersion\": 8, \"ecmaFeatures\": &#123; \"jsx\": true, \"experimentalObjectRestSpread\": true &#125; &#125;, \"settings\": &#123; \"import/resolver\": \"node\" &#125;&#125;; Eslint 是什么编码规范每个程序员都有自己的编码习惯，最常见的莫过于： 有的人写代码一行代码结尾必须加分号 ;，有的人觉得不加分号 ; 更好看； 有的人写代码一行代码不会超过 80 个字符，认为这样看起来简洁明了，有的人喜欢把所有逻辑都写在一行代码上，觉得别人看不懂的代码很牛逼； 有的人使用变量必然会先定义 var a = 10;，而粗心的人写变量可能没有定义过就直接使用 b = 10;； Lint 的含义如果你写自己的项目怎么折腾都没关系，但是在公司中老板希望每个人写出的代码都要符合一个统一的规则，这样别人看源码就能够看得懂，因为源码是符合统一的编码规范制定的。 那么问题来了，总不能每个人写的代码老板都要一行行代码去检查吧，这是一件很蠢的事情。凡是重复性的工作，都应该被制作成工具来节约成本。这个工具应该做两件事情： 提供编码规范； 提供自动检验代码的程序，并打印检验结果：告诉你哪一个文件哪一行代码不符合哪一条编码规范，方便你去修改代码。 Lint 因此而诞生。 Eslint 的含义Lint 是检验代码格式工具的一个统称，具体的工具有 Jslint 、 Eslint 等等 ……….. 我们可以形象地将 Lint 看成是电商行业，而电商行业具体表现有淘宝（Eslint）、京东（Jslint）等。 使用 Eslint 确保你的电脑安装了 node 和 npm 环境 创建项目npm init 指令会在项目根目录下生成 package.json 文件。 12345$ d:$ cd d:$ mkdir test-eslint$ cd test-eslint$ npm init 安装依赖包--save-dev 会把 eslint 安装到 package.json 文件中的 devDependencies 属性中，意思是只是开发阶段用到这个包，上线时就不需要这个包了。 1$ npm install eslint --save-dev 设置 package.json 文件打开 package.json 文件，修改 script 属性如下： 12345\"scripts\": &#123; \"test\": \"react-scripts test --env=jsdom\", \"lint\": \"eslint src\", \"lint:create\": \"eslint --init\"&#125; script 属性的意思是脚本，使用方法是在 cmd 窗口中输入 npm run 指令 的形式，如：npm run lint:create； &quot;lint:create&quot;: &quot;eslint --init&quot; 这个脚本是为了生成 .eslintrc.js 文件，在介绍 Lint 的时候说到 Lint 应该提供编码规范，规范写在哪里，就写在这个文件，所以我们需要创建它； &quot;lint&quot;: &quot;eslint src&quot; 在介绍 Lint 的时候也说到 Lint 应该提供自动校验代码的程序，这个脚本是让 Lint 自动检验 src 目录下所有的 .js 文件。 创建 .eslint.js 文件123456789101112131415161718$ npm run lint:create&gt; 20170811@0.1.0 lint:create D:\\code\\test\\20170811&gt; eslint --init? How would you like to configure ESLint? Answer questions about your style // 以问答的形式创建配置文件? Are you using ECMAScript 6 features? Yes // 是否校验 Es6 语法? Are you using ES6 modules? Yes // 是否校验 Es6 模块语法? Where will your code run? Browser // 代码运行环境，Browser 指浏览器? Do you use CommonJS? Yes // 是否校验 CommonJs 语法? Do you use JSX? Yes // 是否校验 JSX 语法? Do you use React? Yes // 是否校验 React 语法? What style of indentation do you use? Tabs // 首行空白选择 Tab 键还是 Space? What quotes do you use for strings? Double // 字符串使用单引号 'string' 还是双引号 \"string\"? What line endings do you use? Windows // 操作系统? Do you require semicolons? Yes // 每行代码结尾是否校验加分号 ;? What format do you want your config file to be in? JavaScript // 以 .js 格式生成配置文件Installing eslint-plugin-react@latest // 因为要校验 Reac 语法，所以这里需要下载一个 React 语法规则的包 创建完成后根目录下应该会出现 .eslintrc.js 文件 创建 index.js 文件在根目录下创建 src/index.js 文件，内容如下，接下来就使用 Eslint 来检验这个 .js 文件是否符合编码规范。 1const lint = 'eslint' 此时的目录结构应该为： 12345- test-eslint + .eslintrc.js + package.json - src + index.js 校验代码12345678$ npm run lint 1:7 error 'lint' is assigned a value but never used no-unused-vars 1:14 error Strings must use doublequote quotes 1:22 error Missing semicolon semi 3 problems (3 errors, 0 warnings) 2 errors, 0 warnings potentially fixable with the `--fix` option. 这里报了三个错误，分别是： index.js 第1行第7个字符，报错编码规则为 no-unused-vars：变量 lint 只定义了，但是未使用； index.js 第1行第14个字符，报错编码规则为 quotes：编码规范字符串只能使用双引号，这里却使用了单引号； index.js 第1行第22个字符，报错编码规则为 semi：编码规范每行代码结尾必须加分号，这里没有加分号。 当我们熟悉了编码规范之后，只需进行响应的修改就可以使代码形成统一的风格。刚开始如果对编码规范具体某一条规则不了解的话，可以在 eslint规则表 查看用法。（不建议去背规则表，而是用到什么查什么，把它当成字典来用，不那么累） 设置 –fix 参数打开 package.json 文件，修改 script 属性如下： 12345\"scripts\": &#123; \"test\": \"react-scripts test --env=jsdom\", \"lint\": \"eslint src --fix\", \"lint:create\": \"eslint --init\"&#125; 说明：这里给 &quot;lint&quot;: &quot;eslint src --fix&quot;, 加上 --fix 参数，是 Eslint 提供的自动修复基础错误的功能。 此时运行 npm run lint 会看到少了两条报错信息，并不是说编码规范变了，而是 Eslint 自动修复了基础错误，打开 index.js 文件，可看到字符串自动变成了双引号，并且代码末尾也加上了分号。可惜的是 –fix 只能修复基础的不影响代码逻辑的错误，像 no-unused-vars 这种错误只能手动修改。 配置文件讲解按照上述操作，会生成默认 .eslintrc.js 配置文件，内容如下： 12345678910111213141516171819202122232425262728293031323334353637// .eslintrc.js module.exports = &#123; \"env\": &#123; \"browser\": true, \"commonjs\": true, \"es6\": true &#125;, \"extends\": \"eslint:recommended\", \"parserOptions\": &#123; \"ecmaFeatures\": &#123; \"experimentalObjectRestSpread\": true, \"jsx\": true &#125;, \"sourceType\": \"module\" &#125;, \"plugins\": [ \"react\" ], \"rules\": &#123; \"indent\": [ \"error\", \"tab\" ], \"linebreak-style\": [ \"error\", \"windows\" ], \"quotes\": [ \"error\", \"double\" ], \"semi\": [ \"error\", \"always\" ] &#125;&#125; 该文件导出一个对象，对象包含属性 env、extends、parserOptions、plugins、rules 五个属性，作为刚学习 Eslint 的新手，我们总是想要竭尽所能的详细了解每一个属性是什么，干嘛用的，以获取小小的安全感。 env、parserOptions、plugins这三个放在一起将是因为你只需要知道它们是干嘛的：我的程序里要用到 ES6 、React 、JSX 语法，这几个属性就是让 Eslint 能够检验到这些语法的。其余的你不需要知道更多的哪怕一丢丢的东东了。 作者在学习之初在这块浪费了很多时间，官方文档看了很多遍，大多不能理解什么意思，后来想它既然提供这么一个自动生成配置文件的工具，并且是命令行交互的方式，我只需要告诉它我要用 ES6 、React 、JSX 语法，它会自动进行相关配置满足我的要求即可。 extends前面一直说检验代码遵循编码规范，那到底是什么规范呢。 值为 “eslint:recommended” 的 extends 属性启用一系列核心规则，这些规则是经过前人验证的最佳实践（所谓最佳实践，就是大家伙都觉得应该遵循的编码规范），想知道最佳实践具体有哪些编码规范，可以在 eslint规则表 中查看被标记为 √ 的规则项。 如果觉得官方提供的默认规则不好用，可以自定义规则配置文件，然后发布成 Npm 包，eslint-config-airbnb 就是别人自定义的编码规范，使用 npm 安装后，在我们自己的 .eslintrc.js 中进行配置 “extends”: “airbnb”，eslint-config 这个前缀可以省略不写，这样我们就使用了 eslint-config-airbnb 中的规则，而不是官方的规则 “extends”:”eslint:recommended” 了。关于如何创建自定义规则配置并共享可以参考： 如何自定义规则配置 关于 “airbnb” 编码规范说两句，在接触到大多数开源项目中，大多数的作者都会使用 “airbnb” 编码规范而不是 官方的 “extends”: “eslint:recommended” 编码规范。 如果我们觉得 eslint-config-airbnb 规则配置中个别规则并不符合当前项目的要求，可以直接在 .eslintrc.js 配置 rules 属性，优先级高于共享规则 airbnb。 rules配置文件也生成了，我们怎么知道我们的系统会遵循什么规则呢？？ 在前面的列子中，使用 npm run lint 校验出了三处错误，假如我们的项目中字符串就是要使用单引号而不是双引号，代码结尾就是要不加分号才好看，变量就是定义了可能不会使用，我们可以通过设置 rules 来定义我们自己的编码规范，即规则。 ESLint 附带有大量的规则，修改规则应遵循如下要求： “off” 或 0 - 关闭规则 “warn” 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出) “error” 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出) 有的规则没有属性，只需控制是开启还是关闭，像这样：”eqeqeq”: “off”，有的规则有自己的属性，使用起来像这样：”quotes”: [“error”, “double”]，具体有没有自带属性，可查看 eslint规则表。 修改 .eslintrc.js 文件中的 rules 属性： 12345678910111213141516171819\"rules\": &#123; \"indent\": [ \"error\", \"tab\" ], \"linebreak-style\": [ \"error\", \"windows\" ], \"quotes\": [ \"error\", \"single\" // 改成字符串必须由单引号括起来而不是双引号，'string'不报错，\"string\"报错 ], \"semi\": [ \"error\", \"never\" // 改成代码结尾不再加分号，加了分号报错，不加分号不报错 ], \"no-unused-vars\": 0 // 0 相当于 off，表示关闭规则，相当于不再校验这条规则：变量定义了必须使用&#125; 此时再使用 npm run lint 进行代码校验，没有报错就说明校验通过，代码符合统一编码规范。 1234567D:\\code\\test\\20170811&gt;npm run lint&gt; 20170811@0.1.0 lint D:\\code\\test\\20170811&gt; eslint srcD:\\code\\test\\20170811&gt; 可能存在的疑问刚接触 ESlint ，并不清楚有哪些规则怎么办，要去 eslint规则表 一条条记忆吗？答案是 no。 个人认为 ESlint 的配置文件并不是一次性完成的，而是在项目过程中慢慢完善的。你可以放心大胆的先进行编码，然后使用 npm run lint 校验代码的编码规范，如果这时候报错，可以在报错信息中知道是哪一条编码规范报错了，你可能并不认识它们，此时去 eslint规则表 查询相应规则的使用方法，如：no-unused-vars，从而进一步确定项目中是否需要这条编码规范，如果需要，进行局部调整即可。 12345678$ npm run lint 1:7 error 'lint' is assigned a value but never used no-unused-vars 1:14 error Strings must use doublequote quotes 1:22 error Missing semicolon semi 3 problems (3 errors, 0 warnings) 2 errors, 0 warnings potentially fixable with the `--fix` option. 更新部分全局变量配置。如使用 window 对象，默认情况下会报 no-undef 的错误，需要在 .eslintrc 中进行相应配置。 12345678&#123; \"rules\": &#123; // ... &#125;, \"globals\": &#123; \"window\": true &#125;&#125; 单行跳过 lint 校验在实际编码时，可能会出现以下的代码。 123456const apple = \"apple\";const balana = \"balana\";module.exports = &#123; fruit: balana ;&#125; 在最上面定义了两个变量，在底部的配置文件中只可能用到其中一个变量，另一个用不到的在 eslint 校验时就会报错 no-unused-vars 的错误，意思是变量定义了但是没有被用到。 其中一种解决方案是在 .eslintrc 文件中配置 rules no-unused-vars: 0，意思是项目中不检验变量定义未使用这条规则。强烈不建议这样做，这个规则十分有用，可以规避编写代码时遗漏的变量。 另一种解决方案就是使用行内注释跳过对 apple 和 balana 两个变量跳过 eslint 校验，只影响这两个变量，不影响外部。 123456const apple = \"apple\"; // eslint-disable-lineconst balana = \"balana\"; // eslint-disable-line module.exports = &#123; fruit: balana ;&#125; 此时使用 eslint 校验时就不会再报错了。 常见规则含义解释 object-shorthand 设置该规则，表示对象属性要简写。 1234var foo = &#123;x: x&#125;; // 会报错var bar = &#123;a: function () &#123;&#125;&#125;; // 会报错var foo = &#123;x&#125;; // 不会报错var bar = &#123;a () &#123;&#125;&#125;; // 不会报错 prefer-arrow-callback 要求回调函数使用箭头函数 123456// 回调函数，函数的参数是个函数，这个参数函数就是回调函数funciton bar () &#123;&#125; // 不是回调函数，不会报错// setTimeout 的第一个参数就是回调函数，不用箭头函数会报错setTimeout(() =&gt; &#123; // .......&#125;, 1000) no-param-reassign 禁止对函数的参数重新赋值 123456789function bar (&#123; data = &#123;&#125; &#125;) &#123; data.num = 12; // 会报错&#125;/* 虽然报错，又不想要将该校验关闭，如果代码中只有 data 这个属性有这种情形，可以在 .eslintrc.js 中的 rules 属性中添加配置（可忽略 data 属性做此校验）：'no-param-reassign': ['error', &#123; 'props': true, 'ignorePropertyModificationsFor': ['data'] &#125;],'no-param-reassign': 0, // 关闭该属性校验*/ no-trailing-spaces 禁止行尾空格 no-shadow 禁止变量声明与外层作用域的变量同名 123function sum (num) &#123; let num = 2; // 报错，因为 num 变量作为参数已经申明过了&#125; 常用的几个规则1234\"quotes\": [1, \"single\"], # 单引号\"quote-props\":[2, \"as-needed\"], # 双引号自动变单引号\"semi\": [2, \"never\"], # 一行结尾不要写分号\"comma-dangle\": [1,\"always-multiline\"] # 对象或数组多行写法时，最后一个值加逗号","updated":"2020-09-16T07:23:53.350Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"Eslint","slug":"Eslint","permalink":"https://lifei-2019.github.io/tags/Eslint/"}]},{"title":"基础篇","date":"2020-07-10T08:13:00.000Z","path":"interview1/","text":"闭包找到的是同一地址中父级函数中对应变量最终的值 123456789101112131415function a() &#123; const b = 2 console.log(b)&#125;a()此时运行a()后里面的b被释放function a() &#123; const b = 2 return function c()&#123; console.log(b) &#125;&#125;a()此时运行完a()后b仍然保留在内存里。 变量提升在非严格模式下，JavaScript中存在变量提升的特点。 原因 JavaScript的工作原理是先编译再执行，在编译过程中，解释器会把所有声明“移动”到所在作用域的最上面，而赋值或其他逻辑会留在原地，这就是变量提升。 例如 12345foo();function foo()&#123; console.log(a); // undefined var a = 2; &#125; 在编译后将被理解为下面的形式 123456function foo()&#123; var a; console.log(a); // undefined a = 2; &#125;foo()； 2.函数优先 在提升过程中，函数声明将首先提升，然后才是变量。只有函数声明（ function a(){} ）才会被提升，函数表达式（ var a = function b(){} ）不会提升。如果存在相同的声明，相同的变量声明将被忽略；相同的函数声明，后面的将会覆盖前面的。 例如 12345678foo(); // 1var foo;function foo()&#123; console.log(1);&#125;foo = function()&#123; console.log(2);&#125; 将被理解为 1234567function foo()&#123; console.log(1);&#125;foo(); // 1foo = function()&#123; console.log(2);&#125; session,token,cokkies知乎高赞的一篇文章，写的很不错。 Sessionsession 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。 session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。 服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。 tokens Cookiecookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。 cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。 CSS选择器权重!important Infinity(正无穷) 行间样式 1000 id 100 class|属性|伪类 10 标签|伪元素 1 通用选择器(*) |子选择器(&gt;)|相邻选择器(+)|同胞选择器（~） 0 权值可以相加 span的权值为 = id选择器100+类选择器10+元素选择器1 = 111 权值相同时由于HTML代码的执行特点时从上往下执行，因此在权值相同的情况下，后面的选择器会覆盖前面的选择器相同的属性 权值不同时两种选择器覆盖了同一属性，此时权重高的选择器生效。 权值跃迁​ 权值跃迁讨论的问题是，当有11个元素选择器和1个类选择器同时选中同一元素时，哪个选择器的样式会生效。​ ​ 结论是：权级高的选择器的样式会生效。 理解方式1 因为权值不能跃迁，也就意味着无论有多少个0级的选择器，生效的仍然是1级选择器，因 为选择器的权级无法跃迁。理解方式2 CSS里面的进制并不是10进制，而是256进制，所以10个低级选择器并不能等于1个高级选择器 eventloopsetTimeout, setInterval, setImmediate 属于 macro-tasks Promise, MutantObserver 属于 micro-tasks 举例：去窗口办理业务正常 task 同志你好，这是我的资料 好的，我现在处理。处理完了，请下一位 Promise 同志你好，这是我资料 你这资料这没填对，你这样，你填完后重新排到队尾好吧，咱们别阻碍别人的业务 好的好的，谢谢 setTimeout 同志你好，这是我资料 你的证件带了吗？ 哎！我忘家了，我现在回去拿！ 哎 …，你回去拿哈，回来了重新叫号重新排队 好的好的，不好意思同志 所以 Promise 的优先级会高于 setTimeout。micro-tasks 列队结束后会(通常)会触发一次 update rendering。整个流程差不多是： 有没有 macrotask 任务？有就来一个 有没有 microtask 任务？有就把这个列队的任务全弄完 弄完了，需要更新视图(update rendering)吗？需要就更新 上代码！ 上面的执行结果是2，1。从规范上来讲，setTimeout有一个4ms的最短时间，也就是说不管你设定多少，反正最少都要间隔4ms才运行里面的回调。而Promise的异步没有这个问题。 从具体实现上来说，这两个的异步队列不一样，Promise所在的那个异步队列优先级要高一些。具体讲解看第二个例子： 执行结果1，2，3，5，4 为什么执行这样的结果？ 1、创建Promise实例是同步执行的。所以先输出1，2，3，这三行代码都是同步执行。 2、promise.then和setTimeout都是异步执行，会先执行谁呢？ setTimeout异步会放到异步队列中等待执行。 promise.then异步会放到microtask queue中。microtask队列中的内容经常是为了需要直接在当前脚本执行完后立即发生的事，所以当同步脚本执行完之后，就调用microtask队列中的内容，然后把异步队列中的setTimeout放入执行栈中执行，所以最终结果是先执行promise.then异步，然后再执行setTimeout异步。 这是由于：Promise 的回调函数属于异步任务，会在同步任务之后执行。但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。 注意：目前microtask队列中常用的就是promise.then。 1234567891011setTimeout(() =&gt; &#123; console.log(7)&#125;, 0)new Promise((resolve, reject) =&gt; &#123; console.log(3); resolve(); console.log(4);&#125;).then(() =&gt; &#123; console.log(6)&#125;)console.log(5) 执行结果3，4，5，6，7","updated":"2020-09-24T06:08:30.700Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"面试","slug":"面试","permalink":"https://lifei-2019.github.io/tags/面试/"}]},{"title":"一些闲话","date":"2020-06-23T02:47:55.000Z","path":"一些闲话/","text":"一些闲话，大佬勿看。 一个多月没写博客了，倒不是因为我懒（呸，都半年没发朋友圈了还不懒），主要是上个月忙着找工作，然后准备入职，到现在入职两周，感触最深的是社会不会像学校，学校里的课程你可以靠一个月时间突击一下，最后混个八十来分完事，但是工作之后越来越感觉到自己的知识储备太匮乏，直接导致的是进度的拖欠，也正是社会上普遍的加班情况。 更新于7-24 又工作了快一个月，渐渐感受到互联网公司的节奏，早上九点上班，晚上六点半下班，其实从严格的工作时间上来说甚至勉强才到八个小时，并且天天呆在办公室，但是深深感到身心上的劳累【可能是刚从学校进入社会遭受毒打】，每天下班回家就摊在沙发上“葛优躺”，第二天醒过来就开始忧虑开题论文和明年的找工作，真是个不让人省心的小孩。 更新于8-5 今天 又是没有找到论文题目的一天。 又是纠结就业的一天。 最近在看一些面试题 一个以面试官出题角度看的 一个对深入前端的建议 阿里盒马前端 前端知识体系（vue） 找时间单独写一篇整理一下。","updated":"2020-09-15T02:07:27.136Z","link":"","tags":[]},{"title":"终于搞明白了路由元信息是个啥了","date":"2020-06-18T03:12:03.000Z","path":"vue-路由元信息/","text":"为什么会有路由元信息这个东西？我们在做网站登录验证的时候，可以使用到beforeEach 钩子函数进行验证操作，如下面代码 ，如果页面path为’/goodsList’，那么就让它跳转到登录页面，实现了验证登录。 123456router.beforeEach((to, from, next) =&gt; &#123; if (to.path === '/goodsList') &#123; next('/login') &#125; else next()&#125;) 如果需要登录验证的网页多了怎么办？ 1.这里是对比path。如果需要验证的网页很多，那么在if条件里得写下所有的路由地址，将会是非常麻烦的一件事情。 2.因为路由是可以嵌套的。有’/goodsList’，那么可能会有’/goodsList/online’，再或者还有’/goodsList/offline’、’/goodsList/audit’、’/goodsList/online/edit’等等。 如果像刚才例子中这样对比（to.path === ‘/goodsList’），就非常单一，其他的路径压根不会限制（验证）到，照样能正常登陆！因为每个to.path根本不一样。 我们所理想的就是把’/goodsList’限制了，其他所有的以’/goodsList’开头的那些页面都给限制到！ to Route: 即将要进入的目标 路由对象我们打印一下to 它有很多属性，有 fullPath hash matched meta name params path query 其中有个属性，matched，就是匹配了的路由，我们打印出来，这个是个数组。它的第一项就是{path: “/goodslist”}，一直到最为具体的当前path （例如：{path: “/goodslist/online/edit”}） 这里可以循环matched这个数组，看每一项的path 有没有等于’/goodsList’,只要其中一个有，那么就让它跳转到登录状态 12345678router.beforeEach((to, from, next) =&gt; &#123; if (to.matched.some(function (item) &#123; return item.path == '/goodslist' &#125;)) &#123; next('/login') &#125; else next()&#125;) 那么这里只是对goodsList进行验证判断，且限制的还是path，如果页面中还有会员列表、资讯列表、广告列表都需要进行验证的时候，用path来做限制似乎有点不好用。轮到主角登场了 meta字段（元数据）直接在路由配置的时候，给每个路由添加一个自定义的meta对象，在meta对象中可以设置一些状态，来进行一些操作。用它来做登录校验再合适不过了 12345678910111213141516171819202122&#123; path: '/actile', name: 'Actile', component: Actile, meta: &#123; login_require: false &#125;,&#125;,&#123; path: '/goodslist', name: 'goodslist', component: Goodslist, meta: &#123; login_require: true &#125;, children:[ &#123; path: 'online', component: GoodslistOnline &#125; ]&#125; 这里我们只需要判断item下面的meta对象中的login_require是不是true，就可以做一些限制了 12345678router.beforeEach((to, from, next) =&gt; &#123; if (to.matched.some(function (item) &#123; return item.meta.login_require &#125;)) &#123; next('/login') &#125; else next()&#125;)","updated":"2020-08-10T02:47:24.315Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://lifei-2019.github.io/tags/vue/"}]},{"title":"chrome devtools","date":"2020-06-15T02:08:15.000Z","path":"chrome devtools/","text":"chrome devtools 【vscode有一个live server插件，还有一个eslint代码规范化】 功能简介elements元素面板：检查和调整也你俺，调试DOM,调试CSS。 network网络面板：调试请求，了解页面静态资源分布，网页性能 console控制台面板：调试js，查看consolelog日志，交互式代码调试 sources源代码资源面板：调试js页面源代码，进行断点调试代码 application应用面板：查看&amp;调试客户端存储，如cokkie，LocalStorage,SessionStorage performance性能面板：查看页面性能细节，细粒度对网页载入进行性能优化（高阶） memory内存面板：js cpu分析器，内存堆分析器（高阶） security安全面板：查看页面安全及证书问题 audits面板：使用google lighthouse辅助性能分析，给出优化建议（高阶） elements可以双向选择，在elements的左面有选项 点击代码中一段后，可以用ctrl+f进行搜索 可以修改内容和属性 document.querySelectAll(‘img’) $0返回当前选中代码 右键—&gt;copy js path 右键—&gt;break on 提供断点、删除 调节样式及CSSelements—&gt;styles 可以直接修改或者点击右侧进入文件（左下角有{}可以将css代码格式化） filter可以过滤想找的样式名 盒模型（box model） 在元素中增加类与伪类 ：hov显示/不显示元素状态 ：cls增加一个类 +增加一个规则 （!important强制提升优先级） animation （例如transmission: 1s ease-in-out） console调试js交互式编程 console. log/table/group/warn/error(异常逻辑catch) console custom 定制样式 [console.log(“%c123”), “color:red”] console.assert(false, ‘断言失败’) console.time() 这里是函数代码 console.timeEnd() console.clear()清除 Sources使用断点调试js 区别于以前的反复回到本地文件里修改console.log 可以写一个debuger执行到这一行的时候程序会自动暂停，可以在Source的右下角的scope里看各个变量的值，Source左下角看各种事件 使用snippets：比如可以临时引入jQuery库 使用filesystem：模拟本地文件目录 Network查看网页资源分布、针对单已请求查看request、response或者时间消耗等waterfull Applicationcookies: name value domain等等 可以通过document.cookie=”test=1” localstorage.get/setItem(‘’)","updated":"2020-09-08T12:36:26.387Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"}]},{"title":"Node.js简介","date":"2020-05-19T05:23:56.000Z","path":"node1/","text":"简介Node.js是一个内置有chrome V8引擎的JavaScript运行环境，他可以使原本在浏览器中运行的JavaScript有能力跑后端，从而操作我们数据库，进行文件读写等。 Node.js使得JavaScript可以脱离浏览器的窗口，独立运行在Node.js提供的环境中，所以Node.js中没有BOM，DOM这些概念。Node.js中根本没有页面，主要是进行一些服务器上的操作（比如：读写文件，网络通信…）。我们只需要基本的JavaScript语法基础（ES6）即可学习。 特点（记住三句话） 事件驱动 非阻塞IO模型（异步） 轻量和高效 安装官网地址nodejs.org 我们在开发的过程中，每次改完代码之后都必须重启服务器，显然这样的操作效率是比较低，这里给大家推荐个工具，nodemon,nodemon可以帮我们实时监听项目中代码的变化，并且自动重启服务，而且配置简单。 安装：npm install -g nodemon 使用nodemon运行项目，取代之前的node app.js。 1nodemon [your app.js] 项目运行之后，nodemon会自动监听代码的改动，并且重新启动服务，大大增加我们开发效率。 nodemon常见配置 在命令行指定应用的端口号：nodemon ./server.js localhost 8080 查看帮助，帮助里面有很多选项都是一目了然：nodemon -h 或者 nodemon --help 运行 debug 模式：nodemon --debug ./server.js 80 手动重启项目： Nodemon 命令运行的终端 窗口中输入 rs 两个字符，然后再按下回车键，就能手动重启 Nodemon了。","updated":"2020-08-07T07:13:57.886Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"Node","slug":"Node","permalink":"https://lifei-2019.github.io/tags/Node/"}]},{"title":"01-jQuery的介绍和选择器","date":"2020-05-18T06:19:20.000Z","path":"jQuery-1/","text":"jQuery 的介绍 掌握jquery的内容 如何获取DOM 如何操作DOM 如何设置样式 如何处理事件 如何进行AJAX 掌握jquery原理 引入 jQuery 的原因在用 js 写代码时，会遇到一些问题： window.onload 事件有事件覆盖的问题，因此只能写一个事件。 代码容错性差。 浏览器兼容性问题。 书写很繁琐，代码量多。 代码很乱，各个页面到处都是。 动画效果很难实现。 如下图所示： jQuery的出现，可以解决以上问题。 什么是 jQueryjQuery 是 js 的一个库，封装了我们开发过程中常用的一些功能，方便我们调用，提高开发效率。 js库是把我们常用的功能放到一个单独的文件中，我们用的时候，直接引用到页面里即可。 以下是jQuery的相关信息： 官网：http://jquery.com/ 官网API文档：http://api.jquery.com/ 中文汉化API文档：http://www.css88.com/jqapi-1.9/ 学习jQuery，主要是学什么初期，主要学习如何使用jQuery操作DOM，其实就是学习jQuery封装好的那些API。 这些API的共同特点是：几乎全都是方法。所以，在使用jQuery的API时，都是方法调用，也就是说要加小括号()，小括号里面是相应的参数，参数不同，功能不同。 jQuery初体验现在用原生 js 来写下面这一段代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; height: 100px; background-color: pink; margin: 10px; display: none; &#125; &lt;/style&gt; &lt;script&gt; //原生js window.onload = function () &#123; var btn = document.getElementsByTagName(&quot;button&quot;)[0]; var divArr = document.getElementsByTagName(&quot;div&quot;); btn.onclick = function () &#123; for (var i = 0; i &lt; divArr.length; i++) &#123; divArr[i].style.display = &quot;block&quot;; divArr[i].innerHTML = &quot;生命壹号&quot;; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;显示五个div盒子和设置内容&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果用 jQuery 来写，保持其他的代码不变，``部分的代码修改为：（需要提前引入 ） 123456789101112131415161718&lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt; //jquery版 $(document).ready(function () &#123; //获取元素 var jQbtn = $(&quot;button&quot;);//根据标签名获取元素 var jQdiv = $(&quot;div&quot;);//根据标签名获取元素 //绑定事件 jQbtn.click(function () &#123; jQdiv.show(1000);//显示盒子。 jQdiv.html(&quot;tomorrow！&quot;);//设置内容 //上面的两行可以写成链式编程：jQdiv.show(3000).html(1111); &#125;);//事件是通过方法绑定的。 &#125;);&lt;/script&gt; jQuery 的两大特点（1）链式编程：比如.show()和.html()可以连写成.show().html()。 链式编程原理：return this。 通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 this。 （2）隐式迭代：隐式 对应的是 显式。隐式迭代的意思是：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法；而不用我们再进行循环，简化我们的操作，方便我们调用。 如果获取的是多元素的值，大部分情况下返回的是第一个元素的值。 jQuery 的使用使用 jQuery 的基本步骤（1）引包 （2）入口函数 （3）功能实现代码（事件处理） 如下图所示： 主要，导包的代码一定要放在js代码的最上面。 jQuery 的版本jQuery 有两个大版本： 1.x版本：最新版为 v1.11.3。 2.x版本：最新版为 v2.1.4（不再支持IE6、7、8）。 3.x版本。 PS：开发版本一般用1.10以上。 我们以 v1.11.1版本为例，下载下来后发现，里面有两个文件： 它们的区别是： 第一个是未压缩版，第二个是压缩版。 平时开发过程中，可以使用任意一个版本；但是，项目上线的时候，推荐使用压缩版。 jQuery 的入口函数和 $ 符号入口函数（重要）原生 js 的入口函数指的是：window.onload = function() {}; 如下： 12345 //原生 js 的入口函数。页面上所有内容加载完毕，才执行。 //不仅要等文本加载完毕，而且要等图片也要加载完毕，才执行函数。window.onload = function () &#123; alert(1);&#125; 而 jQuery的入口函数，有以下几种写法： 写法一： 1234//1.文档加载完毕，图片不加载的时候，就可以执行这个函数。$(document).ready(function () &#123; alert(1);&#125;) 写法二：（写法一的简洁版） 1234//2.文档加载完毕，图片不加载的时候，就可以执行这个函数。$(function () &#123; alert(1);&#125;); 写法三： 1234//3.文档加载完毕，图片也加载完毕的时候，在执行这个函数。$(window).ready(function () &#123; alert(1);&#125;) jQuery入口函数与js入口函数的区别： 区别一：书写个数不同： Js 的入口函数只能出现一次，出现多次会存在事件覆盖的问题。 jQuery 的入口函数，可以出现任意多次，并不存在事件覆盖问题。 区别二：执行时机不同： Js的入口函数是在所有的文件资源加载完成后，才执行。这些文件资源包括：页面文档、外部的js文件、外部的css文件、图片等。 jQuery的入口函数，是在文档加载完成后，就执行。文档加载完成指的是：DOM树加载完成后，就可以操作DOM了，不用等到所有的外部资源都加载完成。 文档加载的顺序：从上往下，边解析边执行。 jQuery的$符号jQuery 使用 $ 符号原因：书写简洁、相对于其他字符与众不同、容易被记住。 jQuery占用了我们两个变量：$ 和 jQuery。当我们在代码中打印它们俩的时候： 123456789&lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log($); console.log(jQuery); console.log($===jQuery);&lt;/script&gt; 打印结果如下： 从打印结果可以看出，$ 代表的就是 jQuery。 那怎么理解jQuery里面的 $ 符号呢？ $ 实际上表示的是一个函数名 如下： 123456789$(); // 调用上面我们自定义的函数$$(document）.ready(function()&#123;&#125;); // 调用入口函数$(function()&#123;&#125;); // 调用入口函数$(“#btnShow”) // 获取id属性为btnShow的元素$(“div”) // 获取所有的div标签元素 如上方所示，jQuery 里面的 $ 函数，根据传入参数的不同，进行不同的调用，实现不同的功能。返回的是jQuery对象。 jQuery这个js库，除了$ 之外，还提供了另外一个函数：jQuery。jQuery函数跟 $ 函数的关系：jQuery === $。 js中的DOM对象 和 jQuery对象 比较（重点，难点）二者的区别通过 jQuery 获取的元素是一个数组，数组中包含着原生JS中的DOM对象。举例： 针对下面这样一个div结构： 12345&lt;div&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 通过原生 js 获取这些元素节点的方式是： 123var myBox = document.getElementById(&quot;box&quot;); //通过 id 获取单个元素var boxArr = document.getElementsByClassName(&quot;box&quot;); //通过 class 获取的是数组var divArr = document.getElementsByTagName(&quot;div&quot;); //通过标签获取的是数组 通过 jQuery 获取这些元素节点的方式是：（获取的都是数组） 1234//获取的是数组，里面包含着原生 JS 中的DOM对象。var jqBox1 = $(&quot;#box&quot;);var jqBox2 = $(&quot;.box&quot;);var jqBox3 = $(&quot;div&quot;); 我们打印出来看看： 上图显示，由于JQuery 自带了 css()方法，我们还可以直接在代码中给 div 设置 css 属性。 总结：jQuery 就是把 DOM 对象重新包装了一下，让其具有了 jQuery 方法。 二者的相互转换1、 DOM 对象 转为 jQuery对象： 1$(js对象); 举例：（拿上一段的代码举例） 1234//转换。jqBox1 = $(myBox);jqBox2 = $(boxArr);jqBox3 = $(divArr); DOM 对象转换成了 jquery 对象之后，上面的功能可以直接调用。 2、jQuery对象 转为 DOM 对象： 123jquery对象[index]; //方式1（推荐）jquery对象.get(index); //方式2 jQuery对象转换成了 DOM 对象之后，可以直接调用 DOM 提供的一些功能。如： 123//jquery对象转换成 DOM 对象之后jqBox3[0].style.backgroundColor = &quot;black&quot;;jqBox3.get(4).style.backgroundColor = &quot;pink&quot;; 总结：如果想要用哪种方式设置属性或方法，必须转换成该类型。 举例：隔行变色代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //入口函数 jQuery(function () &#123; var jqLi = $(&quot;li&quot;); for (var i = 0; i &lt; jqLi.length; i++) &#123; if (i % 2 === 0) &#123; //jquery对象，转换成了js对象 jqLi[i].style.backgroundColor = &quot;pink&quot;; &#125; else &#123; jqLi[i].style.backgroundColor = &quot;yellow&quot;; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： jQuery 选择器我们以前在CSS中学习的选择器有： 今天来学习一下jQuery 选择器。 jQuery选择器是jQuery强大的体现，它提供了一组方法，让我们更加方便的获取到页面中的元素。 1、jQuery 的基本选择器 解释如下： 举例： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //入口函数 jQuery(document).ready(function () &#123; //三种方式获取jquery对象 var jqBox1 = $(&quot;#box&quot;); var jqBox2 = $(&quot;.box&quot;); var jqBox3 = $(&quot;div&quot;); //操作标签选择器 jqBox3.css(&quot;width&quot;, 100); jqBox3.css(&quot;height&quot;, 100); jqBox3.css(&quot;margin&quot;, 10); jqBox3.css(&quot;background&quot;, &quot;pink&quot;); //操作类选择器(隐式迭代，不用一个一个设置) jqBox2.css(&quot;background&quot;, &quot;red&quot;); //操作id选择器 jqBox1.css(&quot;background&quot;, &quot;yellow&quot;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 2、层级选择器 解释如下： 举例： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //获取ul中的li设置为粉色 //后代：儿孙重孙曾孙玄孙.... var jqLi = $(&quot;ul li&quot;); jqLi.css(&quot;margin&quot;, 5); jqLi.css(&quot;background&quot;, &quot;pink&quot;); //子代：亲儿子 var jqOtherLi = $(&quot;ul&gt;li&quot;); jqOtherLi.css(&quot;background&quot;, &quot;red&quot;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;ol&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;li&gt;ccc&lt;/li&gt; &lt;/ol&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果： 3、基本过滤选择器 解释： 举例： 1234567891011121314151617181920212223242526&lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(document).ready(function () &#123; // :odd $(&quot;li:odd&quot;).css(&quot;background&quot;, &quot;red&quot;); // :even $(&quot;li:even&quot;).css(&quot;background&quot;, &quot;green&quot;); // :eq(index) $(&quot;ul li:eq(3)&quot;).css(&quot;font-size&quot;, &quot;30px&quot;); //设置第四个li的字体 // :lt(index) $(&quot;li:lt(6)&quot;).css(&quot;font-size&quot;, &quot;30px&quot;); // :gt(index) $(&quot;.ulList1 li:gt(7)&quot;).css(&quot;font-size&quot;, &quot;40px&quot;); // :first $(&quot;.ulList li:first&quot;).css(&quot;font-size&quot;, &quot;40px&quot;); // :last $(&quot;li:last&quot;).css(&quot;font-size&quot;, &quot;40px&quot;); &#125;);&lt;/script&gt; 4、属性选择器 5、筛选选择器 举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; jQuery(function () &#123; var jqul = $(&quot;ul&quot;); //find(selector); 从jquery对象的后代中查找 //必须制定参数，如果不指定获取不到元素。length === 0 jqul.find(&quot;li&quot;).css(&quot;background&quot;, &quot;pink&quot;); console.log(jqul.find()); //chidlren(selector); 从jquery对象的子代中查找 //不写参数代表获取所有子元素。 jqul.children(&quot;li&quot;).css(&quot;background&quot;, &quot;green&quot;); //eq(索引值); 从jquery对象的子代中查找该索引值的元素 //要写该数组中的第几个。 jqul.children().eq(0).css(&quot;background&quot;, &quot;red&quot;); //next(); 该元素的下一个兄弟元素 jqul.children().eq(0).next().css(&quot;background&quot;, &quot;yellow&quot;); //siblings(selector); 该元素的所有兄弟元素 jqul.children().eq(0).next().siblings().css(&quot;border&quot;, &quot;1px solid blue&quot;); //parent(); 该元素的父元素（和定位没有关系） console.log(jqul.children().eq(0).parent()); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li class=&quot;box&quot;&gt;生命壹号，永不止步&lt;/li&gt; &lt;span&gt;生命壹号，永不止步&lt;/span&gt; &lt;li class=&quot;box&quot;&gt;生命壹号，永不止步&lt;/li&gt; &lt;i&gt;生命壹号，永不止步&lt;/i&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;a id=&quot;box&quot; href=&quot;#&quot;&gt;生命壹号，永不止步&lt;/a&gt; &lt;ol&gt; &lt;li&gt;我是ol中的li&lt;/li&gt; &lt;li&gt;我是ol中的li&lt;/li&gt; &lt;li&gt;我是ol中的li&lt;/li&gt; &lt;li&gt;我是ol中的li&lt;/li&gt; &lt;/ol&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果： 举例举例1：鼠标悬停时，弹出下拉菜单【重要】完整版代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; .wrap &#123; width: 330px; height: 30px; margin: 100px auto 0; padding-left: 10px; background-color: pink; &#125; .wrap li &#123; background-color: yellowgreen; &#125; .wrap &gt; ul &gt; li &#123; float: left; margin-right: 10px; position: relative; &#125; .wrap a &#123; display: block; height: 30px; width: 100px; text-decoration: none; color: #000; line-height: 30px; text-align: center; &#125; .wrap li ul &#123; position: absolute; top: 30px; display: none; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //入口函数 $(document).ready(function () &#123; //需求：鼠标放入一级li中，让他里面的ul显示。移开隐藏。 var jqli = $(&quot;.wrap&gt;ul&gt;li&quot;); //绑定事件 jqli.mouseenter(function () &#123; //这个位置用到了this. // console.log(this); //打印结果是js中的dom对象。注意：jquery对象绑定的事件中，this指js中的dom对象。【重要】 //让this中的ul显示出来。// 原生 js 的做法是：this.children[1].style.display = &quot;block&quot;; //把js的dom对象包装为jquery对象，然后用jquery方法操作 $(this).children(&quot;ul&quot;).show(); &#125;); //绑定事件：鼠标移开时，隐藏下拉菜单 jqli.mouseleave(function () &#123; $(this).children(&quot;ul&quot;).hide(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0);&quot;&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:void(0);&quot;&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，我们可以看到，用 jQuery来操作，是非常方便的。 实现效果如下： this的用法： 上方代码中，核心的一行代码是： 123$(this).children(&quot;ul&quot;).show();$(this).children(&quot;ul&quot;).hide(); 如果我把这行代码中的this直接写成 DOM对象： 123jqli.children(&quot;ul&quot;).show();jqli.children(&quot;ul&quot;).hide(); 产生的结果是：（不是我们期望的结果） 两张图的对比，可以看出this的作用：谁正在调用函数，this就指的是谁。 举例2：鼠标悬停时变色完整版代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //需求；隔行变色；鼠标悬停时，还要变色。 var jqli1 = $(&quot;li:odd&quot;); var jqli2 = $(&quot;li:even&quot;); jqli1.css(&quot;background&quot;, &quot;#cccccc&quot;); jqli2.css(&quot;background&quot;, &quot;white&quot;); //鼠标悬停时变色 var color = &quot;&quot;; $(&quot;li&quot;).mouseenter(function () &#123; color = $(this).css(&quot;background&quot;); //先把之前的颜色保存下来，鼠标离开时还原 $(this).css(&quot;background&quot;, &quot;green&quot;); &#125;); //鼠标离开时，恢复为原来的颜色 $(&quot;li&quot;).mouseleave(function () &#123; $(this).css(&quot;background&quot;, color); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 举例3：突出显示要求：鼠标悬停时，突出显示这个li，让其他的li都半透明。 用 jQuery的选择起来实现，会发现非常方便。 完整版代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; body &#123; background: #000; &#125; .wrap &#123; margin: 100px auto 0; width: 630px; height: 394px; padding: 10px 0 0 10px; background: #000; overflow: hidden; border: 1px solid #fff; &#125; .wrap li &#123; float: left; margin: 0 10px 10px 0; &#125; .wrap img &#123; display: block; border: 0; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; jQuery(window).ready(function () &#123; //需求：鼠标放入li中，其他的li半透明，当前盒子的opacity值为1 $(&quot;.wrap&quot;).find(&quot;li&quot;).mouseenter(function () &#123; //链式编程 $(this).css(&quot;opacity&quot;, 1).siblings(&quot;li&quot;).css(&quot;opacity&quot;, 0.4); &#125;); //离开wrap的时候所有的li的全部opacity值为1； $(&quot;.wrap&quot;).mouseleave(function () &#123; $(this).children().children(&quot;li&quot;).css(&quot;opacity&quot;, 1);// $(&quot;.wrap li&quot;).css(&quot;opacity&quot;,1); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/01.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/02.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/03.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/04.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/05.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/06.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现的效果： 注意这里的css布局里，每一个图片都用一个li来存放。设置li的父亲的宽度之后，然后将li设置为浮动，即可自适应地排列成两排。 工程文件： 2018-02-05-突出显示.rar 举例4：手风琴效果完整版代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123;padding: 0;margin: 0;&#125; ul &#123; list-style-type: none;&#125; .parentWrap &#123; width: 200px; text-align:center; &#125; .menuGroup &#123; border:1px solid #999; background-color:#e0ecff; &#125; .groupTitle &#123; display:block; height:20px; line-height:20px; font-size: 16px; border-bottom:1px solid #ccc; cursor:pointer; &#125; .menuGroup &gt; div &#123; height: 200px; background-color:#fff; display:none; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //需求：鼠标点击span，让他下面的div显示出来。让其他的div隐藏。 $(&quot;.parentWrap span&quot;).click(function () &#123;// $(this).next().show();// //让其他的隐藏// //点击的span的父亲li，的所有的兄弟元素li，的孩子元素div全部隐藏。// $(this).parent(&quot;li&quot;).siblings(&quot;li&quot;).children(&quot;div&quot;).hide(); //连式编程 $(this).next().show().parent(&quot;li&quot;).siblings(&quot;li&quot;).find(&quot;div&quot;).hide(); &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class=&quot;parentWrap&quot;&gt; &lt;li class=&quot;menuGroup&quot;&gt; &lt;span class=&quot;groupTitle&quot;&gt;标题1&lt;/span&gt; &lt;div&gt;我是弹出来的div1&lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;menuGroup&quot;&gt; &lt;span class=&quot;groupTitle&quot;&gt;标题2&lt;/span&gt; &lt;div&gt;我是弹出来的div2&lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;menuGroup&quot;&gt; &lt;span class=&quot;groupTitle&quot;&gt;标题3&lt;/span&gt; &lt;div&gt;我是弹出来的div3&lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;menuGroup&quot;&gt; &lt;span class=&quot;groupTitle&quot;&gt;标题4&lt;/span&gt; &lt;div&gt;我是弹出来的div4&lt;/div&gt; &lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果： 注意这里的 选择器的用法：parent、next 举例5：淘宝精品服饰广告完整版代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; font-size: 12px; &#125; ul &#123; list-style: none; &#125; a &#123; text-decoration: none; &#125; .wrapper &#123; width: 298px; height: 248px; margin: 100px auto 0; border: 1px solid pink; overflow: hidden; &#125; #left, #center, #right &#123; float: left; &#125; #left li, #right li &#123; background: url(images/lili.jpg) repeat-x; &#125; #left li a, #right li a &#123; display: block; width: 48px; height: 27px; border-bottom: 1px solid pink; line-height: 27px; text-align: center; color: black; &#125; #left li a:hover, #right li a:hover &#123; background-image: url(images/abg.gif); &#125; #center &#123; border-left: 1px solid pink; border-right: 1px solid pink; &#125; &lt;/style&gt; &lt;script src=&quot;jquery-1.11.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; jQuery(function () &#123; //需求：鼠标放入两侧的li中，让中间的ul中对应索引值的li显示出来，其他的隐藏。（右侧的li要+9） //左侧先绑。获取绑mouseenter $(&quot;#left li&quot;).mouseenter(function () &#123; //显示对应索引值的中间的li //alert($(this).index()); 获取索引值 $(&quot;#center li&quot;).eq($(this).index()).show().siblings(&quot;li&quot;).hide(); &#125;); //右侧 $(&quot;#right li&quot;).mouseenter(function () &#123; //显示对应索引值的中间的li //alert($(this).index()); 获取索引值 $(&quot;#center li:eq(&quot; + ($(this).index() + 9) + &quot;)&quot;).show().siblings(&quot;li&quot;).hide(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrapper&quot;&gt; &lt;ul id=&quot;left&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;女靴&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;雪地靴&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;冬裙&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;呢大衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;毛衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;棉服&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;女裤&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;羽绒服&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;牛仔裤&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul id=&quot;center&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/女靴.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/雪地靴.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/冬裙.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/呢大衣.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/毛衣.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/棉服.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/女裤.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/羽绒服.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/牛仔裤.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/女包.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/男包.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/登山鞋.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/皮带.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/围巾.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/皮衣.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/男毛衣.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/男棉服.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/男靴.jpg&quot; width=&quot;200&quot; height=&quot;250&quot;/&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul id=&quot;right&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;女包&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;男包&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;登山鞋&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;皮带&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;围巾&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;皮衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;男毛衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;男棉服&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;男靴&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果：","updated":"2020-05-18T14:20:53.311Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"jQuery","slug":"jQuery","permalink":"https://lifei-2019.github.io/tags/jQuery/"}]},{"title":"字符串、数组、对象的扩展","date":"2020-05-17T10:29:44.000Z","path":"ES6-6/","text":"字符串的扩展ES6中的字符串扩展，用得少，而且逻辑相对简单。如下： includes(str)：判断是否包含指定的字符串 startsWith(str)：判断是否以指定字符串开头 endsWith(str)：判断是否以指定字符串结尾 repeat(count)：重复指定次数 举例如下： 123456789101112131415let str = 'abcdefg';console.log(str.includes('a'));//trueconsole.log(str.includes('h'));//false//startsWith(str) : 判断是否以指定字符串开头console.log(str.startsWith('a'));//trueconsole.log(str.startsWith('d'));//false//endsWith(str) : 判断是否以指定字符串结尾console.log(str.endsWith('g'));//trueconsole.log(str.endsWith('d'));//false//repeat(count) : 重复指定次数aconsole.log(str.repeat(5)); 打印结果： Number 的扩展 二进制与八进制数值表示法: 二进制用0b, 八进制用0o。 举例： 12console.log(0b1010);//10console.log(0o56);//46 Number.isFinite(i)：判断是否为有限大的数。比如Infinity这种无穷大的数，返回的就是false。 Number.isNaN(i)：判断是否为NaN。 Number.isInteger(i)：判断是否为整数。 Number.parseInt(str)：将字符串转换为对应的数值。 Math.trunc(i)：去除小数部分。 举例： 1234567891011121314151617181920//Number.isFinite(i) : 判断是否是有限大的数console.log(Number.isFinite(NaN)); //falseconsole.log(Number.isFinite(5)); //trueconsole.log(Number.isFinite(Infinity)); //false//Number.isNaN(i) : 判断是否是NaNconsole.log(Number.isNaN(NaN));//trueconsole.log(Number.isNaN(5));//falsse//Number.isInteger(i) : 判断是否是整数console.log(Number.isInteger(5.23));//falseconsole.log(Number.isInteger(5.0));//trueconsole.log(Number.isInteger(5));//true//Number.parseInt(str) : 将字符串转换为对应的数值console.log(Number.parseInt('123abc'));//123console.log(Number.parseInt('a123abc'));//NaN// Math.trunc(i) : 直接去除小数部分console.log(Math.trunc(13.123));//13 数组的扩展 下面提到的数组的几个方法，更详细的内容，可以看《04-JavaScript基础/17-数组的常见方法.md》。 扩展1：Array.from()1Array.from(伪数组/可遍历的对象) 作用：将伪数组或可遍历对象转换为真数组。 扩展2：Array.of()1Array.of(value1, value2, value3) 作用：将一系列值转换成数组。 扩展3：find() 和 findIndex()方法1： 1find(function(item, index, arr)&#123;return true&#125;) 作用：找出第一个满足「指定条件返回true」的元素。 方法2： 1findIndex(function(item, index, arr)&#123;return true&#125;) 作用：找出第一个满足「指定条件返回true」的元素的index。 对象的扩展扩展11Object.is(v1, v2) 作用：判断两个数据是否完全相等。底层是通过字符串来判断的。 我们先来看下面这两行代码的打印结果： 12console.log(0 == -0);console.log(NaN == NaN); 打印结果： 12truefalse 上方代码中，第一行代码的打印结果为true，这个很好理解。第二行代码的打印结果为false，因为NaN和任何值都不相等。 但是，如果换成下面这种方式来比较： 12console.log(Object.is(0, -0));console.log(Object.is(NaN, NaN)); 打印结果却是： 12falsetrue 代码解释：还是刚刚说的那样，Object.is(v1, v2)比较的是字符串是否相等。 扩展2（重要）1Object.assign(目标对象, 源对象1, 源对象2...) 作用： 将源对象的属性追加到目标对象上。如果对象里属性名相同，会被覆盖。 其实可以理解成：将多个对象合并为一个新的对象。 举例： 123456let obj1 = &#123; name: 'smyhvae', age: 26 &#125;;let obj2 = &#123; city: 'shenzhen' &#125;;let obj3 = &#123;&#125;;Object.assign(obj3, obj1, obj2);console.log(obj3); 打印结果： 上图显示，成功将obj1和obj2的属性复制给了obj3。 扩展3：__proto__属性举例： 12345678let obj1 = &#123;name:'smyhvae'&#125;;let obj2 = &#123;&#125;;obj2.__proto__ = obj1;console.log(obj1);console.log(obj2);console.log(obj2.name); 打印结果： 上方代码中，obj2本身是没有属性的，但是通过__proto__属性和obj1产生关联，于是就可以获得obj1里的属性。","updated":"2020-05-17T12:48:21.805Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"ES6","slug":"ES6","permalink":"https://lifei-2019.github.io/tags/ES6/"}]},{"title":"promise、async等","date":"2020-05-15T15:36:37.000Z","path":"ES6-5/","text":"前言文本主要内容： Promise（比较重要） Symbol async函数 Promise概述Promise对象: 代表了未来某个将要发生的事件(通常是一个异步操作)。 ES6中的promise对象, 可以将异步操作以同步的流程表达出来，很好地解决了回调地狱的问题（避免了层层嵌套的回调函数）。在使用ES5的时候，在多层嵌套回调时，写完的代码层次过多，很难进行维护和二次开发。 回调地狱的举例假设买菜、做饭、洗碗都是异步的。 现在的流程是：买菜成功之后，才能开始做饭。做饭成功后，才能开始洗碗。这里面就涉及到了回调的嵌套。 ES6的Promise是一个构造函数, 用来生成promise实例。 promise对象的3个状态 初始化状态（等待状态）：pending 成功状态：fullfilled 失败状态：rejected 使用promise的基本步骤（1）创建promise对象 （2）调用promise的回调函数then() 代码格式如下： 123456789101112131415161718192021222324let promise = new Promise((resolve, reject) =&gt; &#123; //进来之后，状态为pending console.log('111'); //这一行代码是同步的 //开始执行异步操作（这里开始，写异步的代码，比如ajax请求 or 开启定时器） if (异步的ajax请求成功) &#123; console.log('333'); resolve();//如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fullfilled &#125; else &#123; reject();//如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected &#125;&#125;)console.log('222');//调用promise的then()promise.then(() =&gt; &#123; //如果promise的状态为fullfilled，则执行这里的代码 console.log('成功了'); &#125; , () =&gt; &#123; //如果promise的状态为rejected，则执行这里的代码 console.log('失败了'); &#125;) 代码解释： （1）当new Promise()执行之后，promise对象的状态会被初始化为pending，这个状态是初始化状态。new Promise()这行代码，括号里的内容是同步执行的。括号里定义一个function，function有两个参数：resolve和reject。如下： 如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fullfilled。 如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected （2）promise.then()方法，括号里面有两个参数，分别代表两个函数 function1 和 function2： 如果promise的状态为fullfilled（意思是：如果请求成功），则执行function1里的内容 如果promise的状态为rejected（意思是，如果请求失败），则执行function2里的内容 另外，resolve()和reject()这两个方法，是可以给promise.then()传递参数的。如下： 123456789101112131415161718192021222324let promise = new Promise((resolve, reject) =&gt; &#123; //进来之后，状态为pending console.log('111'); //这行代码是同步的 //开始执行异步操作（这里开始，写异步的代码，比如ajax请求 or 开启定时器） if (异步的ajax请求成功) &#123; console.log('333'); resolve('haha');//如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fullfilled &#125; else &#123; reject('555');//如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected &#125;&#125;)console.log('222');//调用promise的then()promise.then((successMsg) =&gt; &#123; //如果promise的状态为fullfilled，则执行这里的代码 console.log(successMsg, '成功了'); &#125; , (errorMsg) =&gt; &#123; //如果promise的状态为rejected，则执行这里的代码 console.log(errorMsg, '失败了'); &#125;) ajax请求的举例（涉及到嵌套的回调）123456789101112131415161718192021222324252627282930313233343536373839//定义一个请求news的方法function getNews(url) &#123; //创建一个promise对象 let promise = new Promise((resolve, reject) =&gt; &#123; //初始化promise状态为pending //启动异步任务 let request = new XMLHttpRequest(); request.onreadystatechange = function () &#123; if (request.readyState === 4) &#123; if (request.status === 200) &#123; let news = request.response; resolve(news); &#125; else &#123; reject('请求失败了。。。'); &#125; &#125; &#125;; request.responseType = 'json';//设置返回的数据类型 request.open(\"GET\", url);//规定请求的方法，创建链接 request.send();//发送 &#125;) return promise;&#125;getNews('http://localhost:3000/news?id=2') .then((news) =&gt; &#123; console.log(news); document.write(JSON.stringify(news)); console.log('http://localhost:3000' + news.commentsUrl); return getNews('http://localhost:3000' + news.commentsUrl); &#125;, (error) =&gt; &#123; alert(error); &#125;) .then((comments) =&gt; &#123; console.log(comments); document.write('&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;' + JSON.stringify(comments)); &#125;, (error) =&gt; &#123; alert(error); &#125;) Symbol概述背景：ES5中对象的属性名都是字符串，容易造成重名，污染环境。 概念：ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 特点： Symbol属性对应的值是唯一的，解决命名冲突问题 Symbol值不能与其他数据进行计算，包括同字符串拼串 for in、for of 遍历时不会遍历Symbol属性。 创建Symbol属性值Symbol是函数，但并不是构造函数。创建一个Symbol数据类型： 1234let mySymbol = Symbol();console.log(typeof mySymbol); //打印结果：symbolconsole.log(mySymbol); //打印结果：Symbol() 打印结果： 下面来讲一下Symbol的使用。 1、将Symbol作为对象的属性值1234567891011let mySymbol = Symbol();let obj = &#123; name: 'smyhvae', age: 26&#125;;//obj.mySymbol = 'male'; //错误：不能用 . 这个符号给对象添加 Symbol 属性。obj[mySymbol] = 'hello'; //正确：通过**属性选择器**给对象添加 Symbol 属性。后面的属性值随便写。console.log(obj); 上面的代码中，我们尝试给obj添加一个Symbol类型的属性值，但是添加的时候，不能采用.这个符号，而是应该用属性选择器的方式。打印结果： 现在我们用for in尝试对上面的obj进行遍历： 123456789101112131415let mySymbol = Symbol();let obj = &#123; name: 'smyhvae', age: 26&#125;;obj[mySymbol] = 'hello';console.log(obj);//遍历objfor (let i in obj) &#123; console.log(i);&#125; 打印结果： 从打印结果中可以看到：for in、for of 遍历时不会遍历Symbol属性。 创建Symbol属性值时，传参作为标识如果我通过 Symbol()函数创建了两个值，这两个值是不一样的： 123456let mySymbol1 = Symbol();let mySymbol2 = Symbol();console.log(mySymbol1 == mySymbol2); //打印结果：falseconsole.log(mySymbol1); //打印结果：Symbol()console.log(mySymbol2); //打印结果：Symbol() 上面代码中，倒数第三行的打印结果也就表明了，二者的值确实是不相等的。 最后两行的打印结果却发现，二者的打印输出，肉眼看到的却相同。那该怎么区分它们呢？ 既然Symbol()是函数，函数就可以传入参数，我们可以通过参数的不同来作为标识。比如： 12345678//在括号里加入参数，来标识不同的Symbollet mySymbol1 = Symbol('one');let mySymbol2 = Symbol('two');console.log(mySymbol1 == mySymbol2); //打印结果：falseconsole.log(mySymbol1); //打印结果：Symbol(one)console.log(mySymbol2); //打印结果：Symbol(two)。颜色为红色。console.log(mySymbol2.toString());//打印结果：Symbol(two)。颜色为黑色。 打印结果： 定义常量Symbol 可以用来定义常量： 1const MY_NAME = Symbol('my_name'); async函数（异步函数）概述 async 函数是在 ES2017 引入的。 概念：真正意义上去解决异步回调的问题，同步流程表达异步操作。 本质： Generator 的语法糖。 async比之前的 Promise、Generator要好用一些。 语法： 1234async function foo() &#123; await 异步操作; await 异步操作；&#125; 我们在普通的函数前面加上 async 关键字，就成了 async 函数。 async、Promise、Generator的对比（async的特点）1、不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就往下执行。 2、async返回的总是Promise对象，可以用then方法进行下一步操作。 3、async取代Generator函数的星号*，await取代Generator的yield。 4、语意上更为明确，使用简单，经临床验证，暂时没有任何副作用。 promise有几种状态，什么时候会进入catch？ 三个状态：pending、fulfilled、reject 两个过程：padding -&gt; fulfilled、padding -&gt; rejected当pending为rejectd时，会进入catch 设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key123456let name = Symbol('name'); let product = &#123; [name]:\"洗衣机\", \"price\":799 &#125;; Reflect.ownKeys(product); 下面Set结构，打印出的size值是多少123let s = newSet();s.add([1]);s.add([1]);console.log(s.size); 答案：2两个数组[1]并不是同一个值，它们分别定义的数组，在内存中分别对应着不同的存储地址，因此并不是相同的值都能存储到Set结构中，所以size为2 Promise 中reject 和 catch 处理上有什么区别 reject 是用来抛出异常，catch 是用来处理异常 reject 是 Promise 的方法，而 catch 是 Promise 实例的方法 reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch 网络异常（比如断网），会直接进入catch而不会进入then的第二个回调","updated":"2020-09-06T13:00:43.813Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"ES6","slug":"ES6","permalink":"https://lifei-2019.github.io/tags/ES6/"}]},{"title":"ES6环境配置","date":"2020-05-13T15:02:44.000Z","path":"ES6-4/","text":"ES6 的其他优势 使用 babel 语法转换器，支持低端浏览器。 流行的库基本都是基于 ES6 构建。 React 默认使用 ES6 标准开发。 ES6的环境配置（为了兼容 ES5）掌握 ES6 之后，如果要考虑 ES5 的兼容性，可以这样做：写 ES6 语法的 js 代码，然后通过 Babel将 ES6 转换为 ES5。 但是，在这之前，我们需要配置一下相关的环境。 建立工程目录（1）先建立一个空的工程目录 ES6Demo，并在目录下建立两个文件夹 src和 dist： src：书写ES6代码，我们写的 js 程序都放在这里。 dist：利用 Babel 编译生成的 ES5 代码。我们在 HTML 页面需要引入 dist 里的 js 文件。 （2）在 src 里新建文件 index.html： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 我们引入 ES5 中的 js 文件，而不是引入 ES6 中的 js 文件。 --&gt; &lt;script src=\"./dist/index.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 注意，上方代码中，我们引入的是dist目录下的 js 文件。 然后我们新建文件 src/index.js： 12345let a = 'smyhvae';const b = 'qianguyihao';console.log(a);console.log(b); 这个文件是一个 ES6语法 的js文件，稍后，我们尝试把这个 ES6 语法的 js 文件转化为 ES5 的 js 文件。 PS：我们在写代码时，能用单引号尽量用单引号，而不是双引号，前者在压缩之后，程序执行会更快。 全局安装 Babel-cli（1）初始化项目： 在安装Babel之前，需要先用 npm init 先初始化我们的项目。打开终端或者通过cmd打开命令行工具，进入项目目录，输入如下命令： 1npm init -y 上方代码中，-y 代表全部默认同意，就不用一次次按回车了（稍后再根据需要，在文件中手动修改）。命令执行完成后，会在项目的根目录下生成package.json文件： 1234567891011&#123; \"name\": \"es6demo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"smyhvae\", \"license\": \"ISC\"&#125; PS：VS Code 里打开终端的快捷键是：Contol + ~。 （2）全局安装 Babel-cli： 在终端中输入以下命令： 1npm install -g babel-cli 如果安装比较慢的话，Mac 下可以使用cnpm进行安装 ，windows 下可以使用nrm切换到 taobao 的镜像。 （3）本地安装 babel-preset-es2015 和 babel-cli： 1npm install --save-dev babel-preset-es2015 babel-cli 安装完成后，会发现package.json文件，已经多了 devDependencies 选项： （4）新建.babelrc： 在根目录下新建文件.babelrc，输入如下内容： 123456&#123; &quot;presets&quot;:[ &quot;es2015&quot; ], &quot;plugins&quot;:[]&#125; （5）开始转换： 现在，我们应该可以将 ES6 的文件转化为 ES5 的文件了，命令如下：（此命令略显复杂） 1babel src/index.js -o dist/index.js 我们可以将上面这个命令进行简化一下。操作如下： 在文件 package.json 中修改键 scripts中的内容： 123\"scripts\": &#123; \"build\": \"babel src/index.js -o dist/index.js\"&#125;, 修改后的效果如下： 目前为止，环境配置好了。以后，我们执行如下命令，即可将src/index.js这个 ES6 文件转化为 dist/index.js这个 ES5 文件： 1npm run build 我们执行上面的命令之后，会发现， dist目录下会生成 ES5 的 js 文件： index.js： 1234567'use strict';var a = 'smyhvae';var b = 'qianguyihao';console.log(a);console.log(b); 当我们打开网页后，就可以在浏览器的控制台，看到代码的输出结果。","updated":"2020-05-17T12:48:12.576Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"ES6","slug":"ES6","permalink":"https://lifei-2019.github.io/tags/ES6/"}]},{"title":"ES5的一些扩展","date":"2020-05-12T11:49:22.000Z","path":"ES6-3/","text":"JSON 对象1、js对象(数组) –&gt; json对象(数组)： 1JSON.stringify(obj/arr) 2、json对象(数组) –&gt; js对象(数组)： 1JSON.parse(json) 上面这两个方法是ES5中提供的。 我们要记住，我们通常说的“json字符串”，只有两种：json对象、json数组。 typeof json字符串的返回结果是string。 Object的扩展ES5给Object扩展了一些静态方法，常用的有2个，我们接下来讲解。 方法一1Object.create(prototype, [descriptors]) 作用: 以指定对象为原型，创建新的对象。同时，第二个参数可以为为新的对象添加新的属性，并对此属性进行描述。 举例1：（没有第二个参数时） 12345var obj1 = &#123;username: 'smyhvae', age: 26&#125;;var obj2 = &#123;address:'shenzhen'&#125;;obj2 = Object.create(obj1);console.log(obj2); 打印结果： 我们发现，obj1成为了obj2的原型。 举例2：（有第二个参数时） 第二个参数可以给新的对象添加新的属性。我们修改上面的代码，尝试给obj2添加新属性sex： 12345678910111213var obj1 = &#123;username: 'smyhvae', age: 26&#125;;var obj2 = &#123;address: 'shenzhen'&#125;;obj2 = Object.create(obj1, &#123; sex: &#123;//给obj2添加新的属性`sex`。注意，这一行的冒号不要漏掉 value: '男', //通过value关键字设置sex的属性值 writable: false, configurable: true, enumerable: true &#125;&#125;);console.log(obj2); 上方代码中，我们通过第5行的sex给obj2设置了一个新的属性sex，但是要通过value来设置属性值（第6行）。 设置完属性值后，这个属性值默认是不可修改的，要通过writable来设置。总而言之，这几个关键字的解释如下： value：设置属性值。 writable：标识当前属性值是否可修改。如果不写的话，默认为false，不可修改。 configurable：标识当前属性是否可以被删除。默认为false，不可删除。 enumerable：标识当前属性是否能用 for in 枚举。 默认为false，不可。 单独设置属性123456Object.defineProperty(obj2, &apos;sex&apos;, &#123; value: &apos;cc&apos;, writable: true, configurable: true, enumerable: true, &#125;); 方法二 这个方法有点难理解。 1Object.defineProperties(object, descriptors) 作用：为指定对象定义扩展多个属性。 代码举例： 12345678910111213141516171819202122var obj2 = &#123; firstName : 'smyh', lastName : 'vae'&#125;;Object.defineProperties(obj2, &#123; fullName : &#123; get : function () &#123; return this.firstName + '-' + this.lastName &#125;, set : function (data) &#123; //监听扩展属性，当扩展属性发生变化的时候自动调用，自动调用后将变化的值作为实参注入到set函数 var names = data.split('-'); this.firstName = names[0]; this.lastName = names[1]; &#125; &#125;&#125;);console.log(obj2.fullName);obj2.firstName = 'tim';obj2.lastName = 'duncan';console.log(obj2.fullName);obj2.fullName = 'kobe-bryant';console.log(obj2.fullName); get ：用来获取当前属性值的回调函数 set ：修改当前属性值得触发的回调函数，并且实参即为修改后的值 存取器属性：setter,getter一个用来存值，一个用来取值。 Object的扩展（二）obj对象本身就自带了两个方法。格式如下： 123get 属性名()&#123;&#125; 用来得到当前属性值的回调函数set 属性名()&#123;&#125; 用来监视当前属性值变化的回调函数 举例如下： 123456789101112131415var obj = &#123; firstName : 'kobe', lastName : 'bryant', get fullName()&#123; return this.firstName + ' ' + this.lastName &#125;, set fullName(data)&#123; var names = data.split(' '); this.firstName = names[0]; this.lastName = names[1]; &#125;&#125;;console.log(obj.fullName);obj.fullName = 'curry stephen';console.log(obj.fullName); 数组的扩展 下面讲的这几个方法，都是给数组的实例用的。 下面提到的数组的这五个方法，更详细的内容，可以看《03-JavaScript基础/15-数组的常见方法.md》 方法1： 1Array.prototype.indexOf(value) 作用：获取 value 在数组中的第一个下标。 方法2： 1Array.prototype.lastIndexOf(value) 作用：获取 value 在数组中的最后一个下标。 方法3：遍历数组 1Array.prototype.forEach(function(item, index)&#123;&#125;) 方法4： 1Array.prototype.map(function(item, index)&#123;&#125;) 作用：遍历数组返回一个新的数组，返回的是加工之后的新数组。 方法5： 1Array.prototype.filter(function(item, index)&#123;&#125;) 作用：遍历过滤出一个新的子数组，返回条件为true的值。 函数function的扩展：bind() ES5中新增了bind()函数来改变this的指向。 1Function.prototype.bind(obj) 作用：将函数内的this绑定为obj, 并将函数返回。 面试题: call()、apply()和bind()的区别： 都能改变this的指向 call()/apply()是立即调用函数 bind()：绑定完this后，不会立即调用当前函数，而是将函数返回，因此后面还需要再加()才能调用。 PS：bind()传参的方式和call()一样。 分析： 为什么ES5中要加入bind()方法来改变this的指向呢？因为bind()不会立即调用当前函数。 bind()通常使用在回调函数中，因为回调函数并不会立即调用。如果你希望在回调函数中改变this，不妨使用bind()。","updated":"2020-05-17T12:48:08.606Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"ES6","slug":"ES6","permalink":"https://lifei-2019.github.io/tags/ES6/"}]},{"title":"ES5中的严格模式","date":"2020-05-10T14:13:45.000Z","path":"ES6-2/","text":"ES的几个重要版本 ES5 : 09年发布。 ES6(ES2015) : 2015年发布，也称为ECMA2015。 ES7(ES2016) : 2016年发布，也称为ECMA2016 (变化不大)。 严格模式的理解 概念理解：除了正常运行模式(混杂模式)，ES5添加了第二种运行模式：”严格模式”（strict mode）。 顾名思义，这种模式使得Javascript在更严格的语法条件下运行。 目的： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 消除代码运行的一些不安全之处，为代码的安全运行保驾护航 为未来新版本的Javascript做好铺垫 使用 针对整个脚本文件：将use strict放在脚本文件的第一行，则整个脚本文件将以严格模式运行。 针对单个函数：将use strict放在函数体的第一行，则整个函数以严格模式运行。 PS：如果浏览器不支持，则这句话只解析为一条简单的语句, 没有任何副作用。 脚本文件的变通写法：因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。 语法和行为改变 必须用var声明变量 禁止自定义的函数中的this指向window 对象不能有重名的属性 严格模式和普通模式的区别 下面列举几条严格模式的内容。 全局变量显式声明在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。 禁止this关键字指向全局对象：12345var foo = function () &#123; console.log(this);&#125;foo(); 上方代码中，普通模式打印的是window。严格模式下打印的是undefined。 构造函数必须通过new实例化对象构造函数必须通过new实例化对象，否则报错。因为this为undefined，此时无法设置属性。 比如说： 12345var Cat = function (name) &#123; this.name = name;&#125;Cat(&apos;haha&apos;); 上方代码中，如果在严格模式下，则会报错。 属性相关普通模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。 普通模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，多个重名的参数属于语法错误。 比如下面这样的代码： 1234var obj = &#123; username: 'smyh'; username: 'vae'&#125; 上面的代码，在严格模式下属于语法错误，因为有重名的属性。 函数必须声明在顶层将来Javascript的新版本会引入”块级作用域”。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。 新增关键字为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。","updated":"2020-05-17T12:47:55.976Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"ES6","slug":"ES6","permalink":"https://lifei-2019.github.io/tags/ES6/"}]},{"title":"ES6-1","date":"2020-05-08T13:15:13.000Z","path":"ES6-1/","text":"主要是一些ES6基础知识，代码已上传至我的github地址 ES6EcmaScript，是一个制定脚本语言标准的组织 let、const和var的区别let可以重新赋值，const不行 let和const var 能否重复声明变量 不可以 可以 作用域范围 块作用域 函数作用域 块作用域就是大括号内部 在函数里想引用外面的只能用window.变量值 实际写代码时主要用const 箭头函数特点 能够使函数的写法更简洁（一行写完一个函数） 函数返回值可以被隐式返回（不需要写return） 不重新绑定this的值 123456789101112131415&lt;script&gt; const companies = [&quot;google&quot;,&quot;IBM&quot;,&quot;HUAWEI&quot;] const result = companies.map( item =&gt; &quot;我想去&quot;+item ) console.log(result) const ages =[14,19,21] const result2=ages.filter(item=&gt;&#123; const nextYearAge = item+1 return nextYearAge&gt;18 &#125; ) console.log(result2)&lt;/script&gt; 普通的function函数this会重新绑定，但是箭头函数不会重新绑定 123456789101112131415161718192021222324252627282930&lt;style&gt; #wrap&#123; width:100% &#125; #the-button &#123; display:block; margin:50% auto &#125; .bigger&#123; padding:20px; transition: padding 1s; &#125; &lt;/style&gt; &lt;div id=\"wrap\"&gt; &lt;button id=\"the-button\"&gt;click me&lt;/button&gt; &lt;/div&gt; &lt;script&gt; document.getElementById(\"the-button\") .addEventListener(\"click\",function()&#123; // console.log(this) //此时this仍然是window所以会报错,如果想使用需要改回原先的function函数 this.classList.add(\"bigger\") setTimeout(()=&gt;&#123; // console.log(this) //这里如果是原本的function的this是window，用箭头函数则不然 this.innerHTML= \"重置\" &#125;,1000) &#125;)&lt;/script&gt; 模版字符串``两个反引号 1.反引号中用${person.hobby}形式引用数组 2.在console.log时用反引号可以直接换行 Set和Mapset可以保证数组里每个元素都是唯一的 增加用add，删除用delete，遍历用forEach map添加用set，删除用delete，判断是否有用has 解构数值1.已有数组 1234567891011121314const person =&#123; name: &quot;lf&quot;, age:&quot;24&quot;, city: &apos;nanjing&apos;, social:&#123; bilibili:&apos;Ts&apos;, qq:&apos;94&apos; &#125; &#125; const &#123;name: personName = &apos;guest&apos;, //若没有则赋值默认值 social:&#123;bilibili&#125; &#125; = person 2.字符串=》数组 1234const info = &apos;lf,23,nanjing&apos;const person1 = info.split(&apos;,&apos;)const [name1,age1,city1]= person1console.log(name1,age1,city1,person1) 3.两个值互换 1[b,a]=[a,b] 剩余和扩展函数牵扯到把多个变量合并成一个数或者把一个数组拆成多个变量的，可以在前面加... 函数默认函数值、字符串方法和for of函数定义有参数，但引用时未传值时返回的是undefined 字符串方法includes,startswith,endswith for of感觉可以用map替代 forEach、for in、for of三者区别 forEach更多的用来遍历数组 for in 一般常用来遍历对象或json for of数组对象都可以遍历，遍历对象需要通过和Object.keys() for in循环出的是key，for of循环出的是value 使用class 手写一个promise123456789101112131415161718192021222324252627282930313233343536373839//创建一个Promise的类 class Promise&#123; constructor(executer)&#123;//构造函数constructor里面是个执行器 this.status = 'pending';//默认的状态 pending this.value = undefined//成功的值默认undefined this.reason = undefined//失败的值默认undefined //状态只有在pending时候才能改变 let resolveFn = value =&gt;&#123; //判断只有等待时才能resolve成功 if(this.status == pending)&#123; this.status = 'resolve'; this.value = value; &#125; &#125; //判断只有等待时才能reject失败 let rejectFn = reason =&gt;&#123; if(this.status == pending)&#123; this.status = 'reject'; this.reason = reason; &#125; &#125; try&#123; //把resolve和reject两个函数传给执行器executer executer(resolve,reject); &#125;catch(e)&#123; reject(e);//失败的话进catch &#125; &#125; then(onFufilled,onReject)&#123; //如果状态成功调用onFufilled if(this.status = 'resolve')&#123; onFufilled(this.value); &#125; //如果状态失败调用onReject if(this.status = 'reject')&#123; onReject(this.reason); &#125; &#125; &#125; 如何使用Set去重123let arr = [12,43,23,43,68,12];let item = [...new Set(arr)];console.log(item);//[12, 43, 23, 68] 将下面for循环改成for of形式12345let arr = [11,22,33,44,55];let sum = 0;for(let i=0;i&lt;arr.length;i++)&#123; sum += arr[i];&#125; 答案： 12345let arr = [11,22,33,44,55];let sum = 0;for(value of arr)&#123; sum += value;&#125; 理解 async/await以及对Generator的优势 async await 是用来解决异步的，async函数是Generator函数的语法糖使用关键字async来表示，在函数内部使用 await 来表示异步async函数返回一个 Promise 对象，可以使用then方法添加回调函数当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句async较Generator的优势：（1）内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样 （2）更好的语义。async 和 await 相较于 * 和 yield 更加语义化 （3）更广的适用性。yield命令后面只能是 Thunk 函数或 Promise对象，async函数的await后面可以是Promise也可以是原始类型的值（4）返回值是 Promise。async 函数返回的是 Promise 对象，比Generator函数返回的Iterator对象方便，可以直接使用 then() 方法进行调用 JavaScript 在发展过程中，共经历了回调函数、Promise 对象、Generator 函数，async 函数来处理异步。我们接下来就来看一下 async 函数如何更优雅的处理异步。 假设我们需要分别读取 a、b、c 三个文件，具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const fs = require('fs');// 对 fs 模块进行 Promise 封装const readFile = function(src) &#123; return new Promise((resolve,reject) =&gt; &#123; fs.readFile(src,(err,data) =&gt; &#123; if(err) reject(err); resolve(data); &#125;) &#125;)&#125;// Promise 的写法readFile('./a.txt').then(data =&gt; &#123; console.log(data.toString()); return readFile('./b.txt');&#125;).then(data =&gt; &#123; console.log(data.toString()); return readFile('./c.txt');&#125;).then(data =&gt; &#123; console.log(data.toString());&#125;)// Generator 函数写法function * ascReadFile() &#123; yield readFile('./a.txt'); yield readFile('./b.txt'); yield readFile('./c.txt');&#125;let g = ascReadFile();g.next().value.then(data =&gt; &#123; console.log(data.toString()); return g.next().value;&#125;).then(data =&gt; &#123; console.log(data.toString()); return g.next().value;&#125;).then(data =&gt; &#123; console.log(data.toString());&#125;)// async 函数写法async function asyncReadFile() &#123; let a = await readFile('./a.txt'); console.log(a.toString()); let b = await readFile('./b.txt'); console.log(b.toString()); let c = await readFile('./c.txt'); console.log(c.toString());&#125;asyncReadFile(); 说一下es6的导入导出模块 导入通过import关键字 123456// 只导入一个import &#123;sum&#125; from \"./example.js\"// 导入多个import &#123;sum,multiply,time&#125; from \"./exportExample.js\"// 导入一整个模块import * as example from \"./exportExample.js\" 导出通过export关键字 12345678910111213141516171819//可以将export放在任何变量,函数或类声明的前面export var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958;//也可以使用大括号指定所要输出的一组变量var firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;;//使用export default时，对应的import语句不需要使用大括号let bosh = function crs()&#123;&#125;export default bosh;import crc from 'crc';//不使用export default时，对应的import语句需要使用大括号let bosh = function crs()&#123;&#125;export bosh;import &#123;crc&#125; from 'crc';","updated":"2020-09-06T11:54:06.691Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"ES6","slug":"ES6","permalink":"https://lifei-2019.github.io/tags/ES6/"}]},{"title":"react-扩展 immutable+mobx","date":"2020-05-07T15:45:12.000Z","path":"react16/","text":"这部分主要介绍了react-immutable和mobx，由于本人前面所学还为完全弄懂，此处仅做了解。 扩展：Immutable的使用再讲immutable之前，先要明白浅拷贝和深拷贝的概念。 浅拷贝：只拷贝最浅的一层，不改变内存地址，优点是节约内存 深拷贝：此时内存地址也发生改变 123456789101112131415161718192021222324import &#123;cloneDeep&#125; from &apos;lodash&apos;const state=&#123; name:&apos;lf&apos;, skills:[&apos;js&apos;,&apos;react&apos;]&#125;//方法一：const newState=cloneDeep(state)//方法二：const newState=JSON.parse(JSON.stringify(state))//测试一下console.log(newState === state)//返回falsenewState.skills.push(&apos;UI&apos;)console.log(newState,state)//此时两个数组不同，newState被改变，state不被改变 此处学习参见关于immutable的一篇文章 npm i immutable -S map是用来做对象的 123456789101112131415161718import &#123;Map&#125; from &apos;immutable&apos;const state=&#123; name:&apos;lf&apos;, skills:[&apos;js&apos;,&apos;react&apos;]&#125;const imState = Map(state)console.log(state.name,imState.name)//返回lf undefinedconsole.log(state.name,imState.get(&apos;name&apos;))//返回 lf lfconst newImState=imState.set(&apos;name&apos;,&apos;lff&apos;)console.log(imState.get(&apos;name&apos;),newImState.get(&apos;name&apos;))//返回lf lff list用来做数组 fromJS ….(此处博主学识上前，暂时不做深入了解) mobx官网地址 主要流程","updated":"2020-05-08T12:43:36.748Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-项目（5）页面级的权限管理","date":"2020-05-03T13:34:28.000Z","path":"react15/","text":"我的项目源码地址 页面级的权限管理 新建views/NoAuth.js,并配置view/index.js 新增routes actions里return的要新增一个role 修改App.js 12const hasPermission =route.roles.includes(this.props.role) return hasPermission?&lt;route.component &#123;...routerProps&#125; /&gt;:&lt;Redirect to=&quot;/admin/noauth&quot; /&gt; 此时发现如果在ajax尚未返回数据时就点击别的会报错，可以加如下代码进行优化（多console） 1if(!this.updater.isMounted(this)) return 个人设置界面view-&gt;routes-&gt;frame tips: hashRouter有#，BrowserRouter没有#但是要加try_files 上传图片实际上保存的是url 贴图库（新用户注册可以免费上传7张） antd官网关于Upload组件的介绍根据里面的示例写views/Profile.js 上传完后自动同步到状态栏 actionTypes添加修改头像操作 actions/user里写change函数 reducers/user里添加case情况 views/profile界面connect函数联结","updated":"2020-05-08T12:43:32.605Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-项目（4）基于redux的通知中心+登录+持久化存储","date":"2020-04-28T14:47:56.000Z","path":"react14/","text":"我的项目源码地址 redux1npm i redux react-redux redux-thunk -S 参考之前我的文章 创建store.js reducers/notifications和reducers/index.js 在根目录index.js中添加Provider组件 store={store} 在views/Notifications/index.js中引入connect，console看一下this.props里有没有dispatch，编写mapState函数，编写connect(mapState)，修改form的dataSource actions=&gt;完善reducers=&gt;完善view界面里的标为已读的功能 在过程中发现下拉菜单的dot属性不能及时更新，发现是因为之前把下拉菜单写成menu数组，如果想实时更新的话需要把他改成函数即可，可以理解为构造了一个组件。 完善loading 登录页UI的实现这里主要采用Card+Form的布局，在设置less的时候遇到transform: translate3d(-50%,-50%,0)设置后页面显示模糊，原因是计算的结果并非整数的像素点，解决方法参见csdn上的一篇文章。 redux实现登陆页逻辑 在rap2里mock模拟数据，并在requests里新建对应的axios请求 在reducers里新建users： 写initState：id,displayyName,avatar,role,isLoading(如果有token就改为true，但是token本身要存在storage里) 写函数 123456export default(state=initState,action)=&gt;&#123; switch(action.type)&#123; default: return state &#125;&#125; 整合到reducers/index.js里 修改index.js里以前遗留的问题：需要权限登录才能访问/admin，修改Route里的render，用component={App}代替，具体的权限跳转转到App组件里设置 修改App.js：引入connect 1234const mapSate=state=&gt;(&#123; isLogin:this.props.isLogin&#125;)@connect(mapState) ​ 修改return里的 12345this.props.isLogin?里面的内容:&lt;Redirect to=&quot;/login&quot; /&gt; 添加actions里面的状态：LOGIN、START_LOGIN、LOGIN_SUCCESS、LOGIN_FAILED 新建actions/user.js 123456789101112131415161718192021222324252627282930import actionTypes from &apos;./actionTypes&apos;import &#123;loginRequest&#125; from &apos;../requests&apos;const startLogin=()=&gt;&#123; return&#123; type:actionTypes.START_LOGIN &#125;&#125;const loginSuccess=()=&gt;&#123; return&#123; type:actionTypes.LOGIN_SUCCESS &#125;&#125;const loginFailed=()=&gt;&#123; return&#123; type:actionTypes.LOGIN_FAILED &#125;&#125;export default login =(userInfo)=&gt;&#123; return dispatch=&gt;&#123; dispatch(startLogin()) loginRequest(userInfo) .then(resp=&gt;&#123; console.log(resp) &#125;) &#125;&#125; 只有同步的东西才能定义actionTypes 修改login/index.js界面 写mapState函数，使用connect函数联结 引入action/user里的login方法 修改onFinish函数，在onFinish里引用login函数 修改actions/user.js loginSuccess要加参数，login函数的完善 做完之后可以去reducers/user里console一下action看是否显示LOGIN_SUCCESS 修改reducers/user switch语句分别对应三种情况：开始登陆，登陆成功，登陆失败 修改Login/index.js Redirect，在render时判断isLogin的状态，true则redirect到admin界面，false则仍返回登录界面 细节部分：在input、checkout组件可以设置disabled={this.props.isLoading}，在button组件里可以设置loading属性，即在提交时表单会进入短暂loading状态，更为真实 Storage持久化存储1.在actions/user.js里 在login里对获取到的数据进行存储loaclstorage/sessionstorage 在loginFailed里清除存储的authToken 2.在reducers/user里，重新定义isLogin的值 1const isLogin = Boolean(window.localStorage.setItem(&apos;authToken&apos;)) || Boolean(window.sessionStorage.setItem(&apos;authToken&apos;)) 3.frame组件里 mapstate函数里多返回avatar和displayName 在合适的地方加上{this.props.avatar}等等 4.发现上面步骤的头像和名字尚未显示，因为在actions里面只传递了authToken，要加上 123window.localStorage.setItem(&apos;userInfo&apos;,JSON.stringify(userInfo))window.localStorage.removeItem(&apos;userInfo&apos;) 退出登录1.actions/user 写logout函数 2.frame 在onDropdownMenuClick函数里加logout 3.reducers 修改loginFailed函数","updated":"2020-05-06T02:38:21.038Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-项目（3）编辑页面+编辑器+echarts+UI通知中心","date":"2020-04-22T15:24:33.000Z","path":"react13/","text":"我的项目源码地址 编辑页面的跳转ArticleList里 1this.props.history.push(`/admin/article/edit/$&#123;record.id&#125;`) 注意此处在react里要用到@withRouter装饰器否则取不到this.props.history Frame里 由于上述路径和之前的Frame里规定的不同，所以左侧编辑栏中选中会消失，此时可以善用split和join函数 123456const selectedKeyArr = this.props.location.pathname.split(&apos;/&apos;) selectedKeyArr.length=3 selectedKeys=&#123;[selectedKeyArr.join(&apos;/&apos;)]&#125; 编辑器这里使用wangeditor，也可以用editormd 1npm i wangeditor -S wangEditor3使用手册 里面有结合react、vue等等的Demo 表单antd4.0官网 在表单方面，4.0和3.0区别暂时发现以下： 取消了Form.create() 对Form.Item内部Input、Button等等组件的设置改为在Form.Item上 本着实用的原则建议大家还是学习新版本，多读源码。 随机颜色的生成方法参考简书上的一篇文章 Material-UI 当下流行的 React UI 框架 网页上图表的技术1.canvas 位图 （不能无限放大） 2.svg 矢量图 （可以无限放大） 3.三维 webgl echarts highcharts（收费） 数据可视化 d3 dataV（收费） 游戏 白鹭引擎egret 更早的 antv、p5、raphael、vml等等 这里用echarts 1npm i echarts -S 右上角UIDropDown组件 下拉框 Avatar组件 头像 Badge组件 消息提示多少条 display:flex 关于flex的一些资料","updated":"2020-05-02T13:42:47.438Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-项目（2）Frame组件+mock数据+表格的基本渲染、分页、删除以及一些细节","date":"2020-04-16T12:34:57.000Z","path":"react12/","text":"我的项目源码地址 微软bing搜索 引入icon由于antd4中移除了之前的&lt;Icon /&gt;的方法，可以改为下面两种方法 1.antd4和iconfont的结合使用 2.采用antd的兼容包（但不太推荐，最好用新版本） 123import &#123; Icon &#125; from &apos;@ant-design/compatible&apos;;&lt;Icon type=&#123;item.icon&#125;/&gt; 表格使用官网教程 使用RAP2模拟数据RAP2官网 时间戳 new Date().getTime()获取现在 new Date(1999999999999).getFullYear()转换成年份 Postman 模拟接口，把刚刚RAP中的地址粘贴到Postman软件里进行post。 Ajax参考前面我的文章 npm i axios -S JS时间格式化npm i moment -S 123window.moment=momentmoment()moment(这里写时间戳).format(&apos;YYYY年MM月DD日 hh:mm:ss&apos;) 导出Excelnpm i xlsx -S 官网github示例在上面找自己需要的 这里我用的是react的示例 在线画流程图 ProcessOn 举例：如果画一个删除文章的功能 和visio功能相似，但是好在可以在线编辑 Tooltip在文字上方显示 12&lt;Tooltip title=&#123;amount&gt;200 ? &apos;超过200&apos; : &apos;没超过200&apos;&#125;&gt;&lt;/Tooltip&gt;","updated":"2020-04-23T07:38:45.566Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-项目（1）配置环境+基本页面及外层路由+内层路由","date":"2020-04-12T14:46:12.000Z","path":"react11/","text":"我的项目源码地址 配置项目开发环境 基于cra添加react-app-rewired 和customize-cranpm i react-app-rewired customize-cra -D 配置config-overrides.js 配置lessnpm i less less-loader -D 配置config-overrides.js 配置Antdnpm i antd -S npm i babel-plugin-import -D 配置lessVar.js 个性化操作参见Ant Design官网 装饰器模式查看customize-cra 需要在config-overrides里添加addDecoratorsLegacy方法 npm i @babel/plugin-proposal-decorators -D 此处遇到问题，应该是ES7中装饰器语法的问题，查阅资料后发现可以在项目根目录下添加jsconfig.js，代码如下 123456&#123; \"compilerOptions\": &#123; \"experimentalDecorators\": true, \"allowJs\": true &#125;&#125; 在App.js里面尝试一下 1234567891011121314const testHOC = (WrappedComponent) =&gt;&#123; return class HOCComponent extends Component&#123; render() &#123; return( &lt;&gt; &lt;WrappedComponent /&gt; &lt;div&gt;这是高阶组件里的信息&lt;/div&gt; &lt;/&gt; ) &#125; &#125;&#125;@testHOC 每一步配置完最好写段代码测试一下** 【在vscode中ctrl+shift+L对相同字符同时进行操作】 基本页面及外层路由基本界面分为：-Login -404 -admin ​ -dashboard ​ -article ​ -List ​ -edit ​ -settings 外层路由：这里主要指 在routes里分为mainRouter(login和404)和adminRouter(其余一些功能) 在src/index.js里： 当路径是/admin时，返回App组件 mainRouter的遍历，返回mainRouter路由名对应的组件 对/和其余路径的重定向 内层路由的配置以及路由的懒加载1.结合前面的教程配置react-router ​ 这里主要是对/admin后面的路径进行细的划分 ，思路和之前的外层路由类似，看个人喜好进行配置 2.参考react-loadable进行配置路由的懒加载 ​ npm i react-loadable -S 3.编写一个Loading组件便于测试 运行后发现在控制台会warning 参考@前端瓶子君在csdn上的文章 可以运行一个自动重命名它们的 codemod 脚本 npx react-codemod rename-unsafe-lifecycles","updated":"2020-04-13T14:59:49.631Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（8）redux-router","date":"2020-04-10T13:56:23.000Z","path":"react10/","text":"源码在我的github地址react-tuts-06 react-router官网 npm i react-router-dom -S &lt;Router /&gt; 必须在最外层，只能写一次，写了之后下面的每一层都可以用。 &lt;Route /&gt; 可以通过component方法来渲染component={组件名}，也可以用render方法render={(routeprops)=&gt; return{&lt;组件名 {…routeprops} 其他参数 &gt;}，render可以传递参数，但是component不行。并且这两个是互斥的。 &lt;Link /&gt; 1.通过query。 2.可以通过动态路由来传参 /path/:param=&gt;params 3.to里面用state进行隐式传参 其中第三种 可以埋点 发送数据常用的方法： 1.ajax 2.img 用图片带上一些参数后端就可以获取到 12const img = newImage()img.src=&quot;https://www.domainname.com/button-01.gif?x=1&amp;y=2&quot; 3.sendBeacon ​ 兼容性差但是成功率高，ie不行，但是移动端可以用 &lt;Redirect /&gt; 自动跳转界面 &lt;withRouter /&gt; 只有使用组件包裹的才能用routeRouter的api，不然要用withRouter进行export","updated":"2020-04-17T03:44:02.596Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（7）react-redux和异步action","date":"2020-04-09T14:00:23.000Z","path":"react9/","text":"源码在我的github地址react-tuts-05 在线写js代码 提供免费的在线REST API React-redux流程 npm i react-redux –save 创建store，createStore是redux提供的一个用于创建store的方法；引入合并后的reducer；createStore的第一个参数必须输一个reducer，如果是多个，要在reducers目录下先试用combineReudcer进行合并之后再导出。 在实际的项目中，由于只有单一的store，但是状态会有很多分类，所以我们需要划分reducer，但是createStore的参数只接收一个reducer，所以，redux比较聪明的提供了一个用于合并多个reducer的方法。 导出后在外部就可以通过store.getState().cart来获取cartReducer里面的state 为了避免actionType重复，一般会把actionType放在一个文件里统一进行管理，也可以避免写错actionType。 创建购物车的reducer，reducer的固定写法是两个参数，第一个state并且有初始值，第二个是action。根据不同的action.type，做不同的处理，每次返回一个新的state，返回的类型一样。一定要有default，当actionType不对的时候，不作任何处理，返回上一次的default。 action有两种写法：第一种写成一个对象，是一个标准的action，但是传递不了参数。实际情况常用是使用actionCreator，它是一个方法返回一个对象，这个对象才是真正的action。 Provider是react-redux提供的一个组件，一般直接把这个组件放在应用程序的最顶层，这个组件必须有一个store属性，这个store属性的值就是创建的store。只要在最外层包裹了这个Provider，那么所有后代组件都可以使用Redux.connect作连接。 connect方法执行之后是一个高阶组件，导入actionCreators；connect方法有四个参数，常用的就是前面两个。第一个参数是mapStateToProps，作用是从store注入到当前组建的props上 第二个参数可以使mapDispatchToProps，这个得主要作用是把action生成的方法注入到当前组件的props 但是第二个参数可以直接传递一个对象，这里的对象就是actionCreators，只要传入了actionCreators，在组件内部通过this.props.actionCreator来调用，这样的话，在调用之后，actionCreator会自动帮你把她内部的action dispatch出去。 PS：此处还可以用装饰器模式。 异步action普通 actionCreator =&gt;自动dispatch(actionCreator()) =&gt; reducer =&gt;store =&gt; view 异步 actionCreator =&gt;middleware处理生成新的action =&gt; 手动dispatch(action) =&gt; reducer =&gt;store npm install –save redux-thunk 修改store.js 1234export default createStore( rootReducer, applyMiddleware(thunk) ) 修改action具体的组件 12345export const decrementAsync =id =&gt;dispatch =&gt;&#123; setTimeout(()=&gt;&#123; dispatch(decrement(id)) &#125;,2000)&#125; 关于middleware 标准的redux工作模型这里借用blog的发布流程来理解建立一个react-redux的过程。个人理解： store.js=&gt;容器组件和展示组件=&gt;reducers=&gt;actions=&gt;完善reducers=&gt;编写根目录下index.js 在过程中发现下拉菜单的dot属性不能及时更新，发现是因为之前把下拉菜单写成menu数组，如果想实时更新的话需要把他改成函数。","updated":"2020-05-01T04:13:34.301Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（6）状态管理以及redux","date":"2020-04-04T13:56:23.000Z","path":"react8/","text":"概念源码在我的github地址react-tuts-04 Redux把Flux与函数式编程结合在一起 redux官网 如果UI层很简单，就不用Redux 需要Redux的项目： 不同身份的用户有不同的使用方式（用户和管理员） 多个用户之间可以协作 与服务器大量交互，或者使用了WebSocket View要从多个来源获取数据 从组件层面考虑： 某个组件状态需要共享 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态 一般来说流程是这样的： 用户触发页面上的某种操作，通过 dispatch 发送一个 action。 Redux 接收到这个 action 后通过 reducer 函数获取到下一个状态。 将新状态更新进 store，store 更新后通知页面重新渲染。 从这个流程中不难看出，Redux 的核心就是一个 发布-订阅 模式。一旦 store 发生了变化就会通知所有的订阅者，view 接收到通知之后会进行重新渲染。 自制Redux因此我们可以自己实践一下 新建redux-principle.html，！+Tab新建网页，添加buttom按钮，静态网页界面。 获取界面上的数字，设置countState；同时编写changeState(state,action)函数，其中state由createStore(changeState)创建，createStore会return三个值getState, dispatch,subscribe，getState是为了返回当前state的状态，（第一次的话就是初始化时候是null）dispatch是为了获changeState执行后state的值，subscribe是为了增加监听器里的数据。 dispatch 和 action 是息息相关的，只有通过 dispatch 才能发送 action。而发送 action 之后才会执行 subscribe 监听到的那些方法。所以 dispatch 做的事情就是将 action 传给 reducer 函数，将执行后的结果设置为新的 store，然后执行 listeners 中的方法。 编写renderCount()，通过每个store.getState()获取state，再渲染数字的数值。执行renderCount()，如果有多个 action 同时发送，这样很难说清楚最后的 store 到底是什么样的，所以需要加锁。在 Redux 中 dispatch 执行后的返回值也是当前的 action，所以还需要store.subscribe(renderCount)。 源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;自制redux&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;button onclick=\"store.dispatch(&#123;type:'JIAN',n:2&#125;)\"&gt;-&lt;/button&gt; &lt;span id=\"countDisplay\"&gt;10&lt;/span&gt; &lt;button onclick=\"store.dispatch(&#123;type:'JIA',n:3&#125;)\"&gt;+&lt;/button&gt; &lt;/div&gt; &lt;script&gt; const countDisplay = document.querySelector('#countDisplay') const countState = &#123; count:5 &#125; const changeState = (state,action) =&gt;&#123; if(!state)&#123; return countState &#125; switch(action.type) &#123; case 'JIAN': return&#123; ...state, count: state.count - action.n &#125; case 'JIA': return&#123; ...state, count: state.count + action.n &#125; default: return state &#125; &#125; const createStore = (changeState) =&gt; &#123; let state = null const getState = () =&gt; state const listeners = [] const subscribe = (listener) =&gt; listeners.push(listener) const dispatch= (action) =&gt; &#123; state = changeState(state,action) listeners.forEach(listener =&gt;listener()) &#125; dispatch(&#123;&#125;) return&#123; getState, dispatch, subscribe &#125; &#125; const store = createStore(changeState) const renderCount = () =&gt;&#123; countDisplay.innerHTML= store.getState().count &#125; renderCount() store.subscribe(renderCount) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用Redux组件 npm i redux -S 建立reducers文件夹，用combineReducers统一导出reducers里的组件； 每个组件首先要定义一个初始的状态，然后export default｛state,action｝，包括default以及各种情况。 把状态导入store，把store引入组件 创建action，把actionType定义好，统一导出actions里的组件； 一般是一个方法，这样在视图里调用时候可以写参数，在哪里用action直接在components的组件里引用store.dispatch(方法名)。 如果想修改数据时候同时修改视图层，那么需要在reducers里完善步骤2里的各种情况。 如果步骤5里设置完没有响应，那可能是没有设置监听器subscribe PS：无副作用修改原数组 12345678var obj = &#123;x:1,y:2,z=2&#125;//方法一var obj1=Object.assign(&#123;&#125;,obj,&#123;z:4,a:5&#125;)//方法二var obj2=&#123;...obj,z:44,a:55&#125;//方法三var arr=&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;arr2=arr.slice()","updated":"2020-04-09T14:04:47.912Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（5）HOC、装饰器模式","date":"2020-03-31T15:03:37.000Z","path":"react7/","text":"vue生态更官方化，react更加社区化 源码在我的github地址react-tuts-03 HOC高阶组件Higher-Order Component 举例： 12345678910var add = (x) =&gt; &#123; return (y) =&gt; &#123; return x+y &#125;&#125;用的时候add(1)(2)//柯里化 装饰器让cra支持@装饰器写法 1.不管你是要配置什么，最好的方式是使用react-app-rewired这个包来对cra创建的项目进行轻微的配置调整 npm install react-app-rewired –save-dev 2.安装好之后，把package.json里的scripts里的react-scripts换成react-app-rewired 3.在根目录下创建一个config-overrides.js 1234module.exports= (config) =&gt; &#123; //如果没有使用customize-cra，在这个里面可以对config进行配置 return config&#125; 4.当然如果想要方便，可以先安装customize-cra，然后修改config-overrides.js npm install customize-cra –save-dev npm i @babel/plugin-personal-decorators -D 12345const &#123;override, addDecoratorsLegacy&#125; = require('customize-cra')module.exports = override( addDecoratorsLegacy()) 项目目录 src/Another.js12345678910111213141516import React, &#123; Component &#125; from 'react'import withCopyright from './withCopyright'@withCopyrightclass Another extends Component &#123; render() &#123; return ( &lt;div&gt; Another &#123;this.props.name&#125; &lt;/div&gt; ) &#125;&#125;export default Another src/App.js12345678910111213141516import React, &#123; Component &#125; from 'react'import withCopyright from './withCopyright'import Another from './Another' class App extends Component &#123; render() &#123; return ( &lt;div&gt; App &lt;Another name='组件' /&gt; &lt;/div&gt; ) &#125;&#125;export default withCopyright(App) src/index.js12345678import React from 'react'import &#123; render &#125; from 'react-dom'import App from './App'render( &lt;App /&gt;, document.querySelector('#root')) withCopyright.js12345678910111213141516import React,&#123;Component&#125; from 'react'const withCopyright = (YourComponent) =&gt; &#123; return class withCopyright extends Component &#123; render()&#123; return( &lt;&gt; &lt;YourComponent &#123;...this.props&#125;/&gt; &lt;div&gt;&amp;copy; 2020 &amp;emsp;raphael&amp;nbsp;哈哈哈&lt;/div&gt; &lt;/&gt; ) &#125; &#125;&#125;export default withCopyright config-overrides.js12345const &#123;override, addDecoratorsLegacy&#125; = require('customize-cra')module.exports = override( addDecoratorsLegacy())","updated":"2020-04-06T15:11:09.428Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（4）hooks和context","date":"2020-03-31T15:03:37.000Z","path":"react6/","text":"源码在我的github地址react-tuts-02 React HooksReact Hooks是react 16.8新增的一项功能。可以在不编写class的情况下使用state。 两个常见的api，useState和useEffect，需要先引入 useState是一个方法，方法参数是默认值，结果是一个数组，数组的第一个就是state，第二个相当于setState（不一样的地方在于参数，这里的参数是一个新值即可），解构出来数组中的两个值。 useEffect的参数是一个回调，不管是组件挂载还是更新，都会触发这个回调方法，类似于componentDidMount和componentDidUpdate的结合 1234567891011121314151617181920212223242526272829import React ,&#123;useState, useEffect&#125; from 'react'import &#123; render &#125; from 'react-dom'const Counter = () =&gt; &#123; const [count,setCount] = useState(0) //console.log(useState(10)) // 可以使用多次 // const [title,setTitle] = useState('abc') //console.log(title) useEffect(() =&gt; &#123; console.log('渲染了') document.title=`当前的数量为$&#123;count&#125;` &#125;) return( &lt;div&gt; &lt;p&gt;当前的数量为&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123;setCount(count - 1)&#125;&#125;&gt;-&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; &#123;setCount(count + 1)&#125;&#125;&gt;+&lt;/button&gt; &lt;/div&gt; )&#125;render( &lt;Counter /&gt;, document.querySelector('#root')) context具体介绍 createContext是react提供的一个用于跨组件传值的方法，这个方法的结果是一个对象，里面有两个组件Provider和Consumer。 Provider用于提供状态 Consumer用于接受状态， 项目目录 src/components/Count1/index.js123456789101112131415161718import React, &#123; Component &#125; from 'react'import &#123; CounterConsumer &#125; from '../../counterStore'//定义一个Count1组件export default class Count1 extends Component&#123; render()&#123; return( //使用CounterConsumer来接受count， &lt;CounterConsumer&gt; &#123; //注意！！！Consumer的children必须是一个方法，这个方法有一个参数，这个参数就是Provider的value (&#123;count&#125;)=&gt;&#123; return &lt;span&gt;&#123;count&#125;&lt;/span&gt; &#125; &#125; &lt;/CounterConsumer&gt; )&#125; &#125; src/components/CountBtn/index.js123456789101112131415import React, &#123; Component &#125; from 'react'import &#123; CounterConsumer &#125; from '../../counterStore'export default class CountBtn extends Component&#123; render() &#123; return &lt;CounterConsumer&gt; &#123; (&#123;onincrementCount, ondecrementCount&#125;)=&gt;&#123; const handler = this.props.type === 'increment' ? onincrementCount : ondecrementCount return &lt;button onClick=&#123;handler&#125;&gt;&#123;this.props.children&#125;&lt;/button&gt; &#125; &#125; &lt;/CounterConsumer&gt; &#125; &#125; src/components/Counter/index.js1234567891011121314151617181920212223import React, &#123;useState, useEffect &#125; from &apos;react&apos;export default function Counter() &#123; const [count,setCount] = useState(0) //console.log(useState(10)) // 可以使用多次 // const [title,setTitle] = useState(&apos;abc&apos;) //console.log(title) useEffect(() =&gt; &#123; console.log(&apos;渲染了&apos;) document.title=`当前的数量为$&#123;count&#125;` &#125;) return( &lt;div&gt; &lt;p&gt;当前的数量为&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123;setCount(count - 1)&#125;&#125;&gt;-&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onClick=&#123;() =&gt; &#123;setCount(count + 1)&#125;&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ) &#125; src/components/index.js123export &#123; default as Counter &#125; from './Counter'export &#123; default as Count1 &#125; from './Count1'export &#123; default as CountBtn &#125; from './CountBtn' src/App.js12345678910111213141516171819import React, &#123; Component &#125; from &apos;react&apos;import&#123; CountBtn, Count1, Counter &#125; from &apos;./components&apos;export default class App extends Component&#123; render () &#123; return( &lt;&gt; &lt;Counter /&gt; &lt;br&gt;&lt;/br&gt; &lt;CountBtn type=&quot;decrement&quot;&gt;-&lt;/CountBtn&gt; &lt;Count1 /&gt; &lt;CountBtn type=&quot;increment&quot;&gt;+&lt;/CountBtn&gt; &lt;/&gt; )&#125;&#125; src/counterStore.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React,&#123;Component,createContext&#125; from &apos;react&apos;//console.log(createContext())const&#123; Provider, Consumer: CounterConsumer //结构出来重新赋值给一个CounterConsumer的组件 &#125; = createContext() //封装一个基本的Provider，因为直接使用Provider不方便管理状态class CounterProvider extends Component&#123; constructor()&#123; super() //这里的状态就是共享的，任何CounterProvider的后代组件，都可以通过CounterProvider来接受这个值 this.state=&#123; count: 100 &#125; &#125; //这里的方法也会继续通过Provider共享下去 incrementCount = ()=&gt;&#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; decrementCount = ()=&gt;&#123; this.setState(&#123; count: this.state.count -1 &#125;) &#125; render()&#123; return( //使用Provider这个组件，它必须要有一个value，value里可以传递任何的数据，一般还是传递一个比较合理。 &lt;Provider value=&#123;&#123; count: this.state.count, //这两个括号意义不同，可以简单的理解为： //外面的花括号是说：我这里面写的是js语句 //内部的花括号是说：我里面的不是要显示的文字，而是变量，我要把变量的值解析放在这 onincrementCount:this.incrementCount, ondecrementCount:this.decrementCount &#125;&#125; &gt; &#123;this.props.children&#125; &lt;/Provider&gt; ) &#125; &#125; export &#123; CounterProvider, CounterConsumer &#125; src/index.js123456789101112131415import React from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;import&#123; CounterProvider &#125; from &apos;./counterStore&apos;import App from &apos;./App&apos; render( &lt;CounterProvider&gt; &lt;App /&gt; &lt;/CounterProvider&gt;, document.querySelector(&apos;#root&apos;))","updated":"2020-04-06T15:10:45.492Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（3）生命周期和ajax","date":"2020-03-28T06:34:26.000Z","path":"react5/","text":"生命周期 生命周期图谱 挂载当组件实例被创建并插入DOM中，生命周期调用顺序如下** construstor() 只执行一次。初始化，在super之后构建 static getDerivedStateFromProps() render() 负责渲染，即合成虚拟DOM componentDidMount() 获取真实DOM比如ajax 更新当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下： static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 卸载当组件从 DOM 中移除时会调用如下方法： componentWillUnmount() 错误处理（不常用，一般用console.log）当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法： static getDerivedStateFromError() componentDidCatch() `是ES6新增的模版字符串“hello” + str + “world !” ``hello ${str} world ! 减少更新次数方法一：把Component改成PureComponent，但这种只做了第一层，方法二是更深层的。 方法二：第一个判断123shouldComponentUpdate(nextProps,nextState)&#123; return (nextProps.isCompleted !== this.props.isCompleted)||(nextProps.xxx != this.props.xxx)&#125; 第二个判断老版本的坑：constructor里面通过props来初始化一个state，在props修改之后，这个state不会再次更新。需要借助于componentWillReceiveProps来做一次修正 新版本：123456789101112constructor()&#123; super() this.state = &#123; completedText: &apos;&apos; &#125; &#125; static getDerivedStateFromProps(props)&#123; return&#123; completedText: props.isCompleted ? &apos;wancheng&apos;:&apos;weiwancheng&apos; &#125; &#125; Ajaxjson官网 前后端接口 npm install axios -S 新建 src/services/apis.js12345export default&#123; baseURL: 'https://jsonplaceholder.typicode.com', //获取todos的接口 todos: '/todos'&#125; 新建src/services/index.js12345678910111213import axios from 'axios'import apis from './apis'const ajax = axios.create(&#123; baseURL: apis.baseURL&#125;)//在这里还回去做一些全局的拦截器处理export const getTodos = ()=&gt;&#123; return ajax.get(apis.todos)&#125; 在App.js中引入1import &#123; getTodos &#125; from './services' 同时 12345678910111213141516171819202122232425262728293031323334353637constructor() &#123; super() this.state = &#123; title: &apos;待办事情&apos;, desc:&apos;有点多&apos;, article: &apos;&lt;div&gt;123456 &lt;i&gt;654321&lt;/i&gt;&lt;/div&gt;&apos;, todos:[], isLoading: true &#125; &#125; getData = () =&gt; &#123; getTodos() .then(resp =&gt; &#123; //console.log(resp) if (resp.status === 200) &#123; this.setState(&#123; todos: resp.data &#125;) //setTimeout(() =&gt; &#123;这里具体操作&#125;,5000) &#125;else &#123; //处理错误 &#125; &#125;) .catch(err =&gt;&#123; console.log(err) &#125;) .finally(() =&gt; &#123; this.setState(&#123; isLoading: false &#125;) &#125;) &#125; componentDidMount ()&#123; this.getData() &#125;","updated":"2020-03-29T09:48:30.535Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（2）项目目录以及组件","date":"2020-03-24T14:41:16.000Z","path":"react4/","text":"源码在我的github地址react-tuts TodoHeader1.在App.js中设置值传到组件，props向下传递的方法，注意要用花括号。 2.在TodoHeader/index.js中，模版渲染语法 （类组件前面要加this.props 函数用props） 3.prop-types的使用 npm install –save prop-types 判定数据类型 TodoList在TodoList/index.js中 1.通过PropTypes验证todos组件中各个部分的类型 2.用两种方法写出（注意要设置key值） Like（点赞功能）1.设置state里面islike的属性 2.创建handleClick方法（这里用到setState，是异步的，在其内部还可以用到prevState表示点击之前的state的状态） 3.emoji网站 Input输入框1.未输入时默认state的InputValue为空 2.handleInputChange输入时同步显示在输入框中 3.handelAddClick：点击添加按钮时，调用App.js里的addTOdo函数，同时清空输入框 4.添加回车事件，通过keyup（keycode 13 = Enter） 5.添加完成之后获取焦点，用createRef 添加checkbox1.在App.js中新建函数onCompletedChanged函数，并且在里面标注 2.在TodoList里面的index.js里添加onCompletedChange={this.props.onCompletedChange} 3.在TodoItem.js里面添加handelCheckboxChange函数，它是onChange的方法 4.新增知识点const noop = ()=&gt; {} 各个文件具体代码src/App.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import React, &#123; Component, Fragment &#125; from 'react'import&#123; TodoHeader, TodoInput, TodoList, Like&#125; from './components'export default class App extends Component &#123; // state = &#123; // title: '待办事情' // &#125; //不知道props还是state就用props constructor() &#123; super() this.state = &#123; title: '待办事情', desc:'有点多', article: '&lt;div&gt;123456 &lt;i&gt;654321&lt;/i&gt;&lt;/div&gt;', todos: [ &#123; id: 1, title: '看视屏', assignee: 'Leo', isCompleted: false &#125;, &#123; id: 2, title: '实践', assignee: 'Xiao', isCompleted: true &#125;] &#125; &#125; addTodo = (todoTitle) =&gt; &#123; //这样写不对，TODOTitle不是一个数组 // this.setState(&#123; // todos: this.state.todos.push(&#123; // id: Math.random, // title: todoTitle, // isCompleted: false // &#125;) // &#125;) // 这个代码是对的 // this.setState(&#123; // todos: this.state.todos.concat(&#123; // id: Math.random(), // title: todoTitle, // isCompleted: false // &#125;) // &#125;) // const newTodos = this.state.todos.slice() const newTodos = [...this.state.todos] newTodos.push(&#123; id: Math.random(), title: todoTitle, isCompleted: false &#125;) this.setState(&#123; todos: newTodos &#125;) &#125; onCompletedChange = (id) =&gt;&#123; this.setState((prevState) =&gt;&#123; return&#123; todos: prevState.todos.map(tod =&gt;&#123; if(tod.id === id)&#123; tod.isCompleted = !tod.isCompleted &#125; return tod &#125;) &#125; &#125;) &#125; render() &#123; return ( &lt;Fragment&gt; &#123;&lt;div dangerouslySetInnerHTML=&#123;&#123;__html: this.state.article&#125;&#125; /&gt;&#125; &#123;this.state.todos[0].isCompleted ? '完成' : '未完成'&#125; &#123; this.state.todos.map(todo =&gt;&#123; return &lt;div key=&#123;todo.id&#125;&gt;&#123;todo.title&#125;&lt;/div&gt; &#125;) &#125; &lt;TodoHeader desc=&#123;this.state.desc&#125; x=&#123;1&#125; y=&#123;2&#125;&gt; &lt;i&gt;待办事项列表&lt;/i&gt; &lt;br&gt;&lt;/br&gt; &#123;this.state.title&#125; &lt;/TodoHeader&gt; &lt;TodoInput addTodo=&#123;this.addTodo&#125; /&gt; &lt;TodoList todos=&#123;this.state.todos&#125; onCompletedChange=&#123;this.onCompletedChange&#125; /&gt; &lt;Like /&gt; &lt;/Fragment&gt; // &lt;&gt; // &lt;TodoHeader /&gt; // &lt;TodoInput /&gt; // &lt;TodoList /&gt; // &lt;/&gt; //两种方法都可以 ) &#125;&#125; src/index.js123456789import React from 'react'import &#123; render &#125; from 'react-dom'import App from './App'render( &lt;App /&gt;, document.querySelector('#root')) src/components/index.js12345678910111213141516//负责导出所有的组件，下面两种方法都可以// import TodoHeader from './TodoHeader'// import TodoInput from './TodoInput'// import TodoList from './TodoList'// export &#123;// TodoHeader,// TodoInput,// TodoList// &#125;export&#123; default as TodoHeader&#125; from './TodoHeader'export&#123; default as TodoInput&#125; from './TodoInput'export&#123; default as TodoList&#125; from './TodoList'export&#123; default as Like&#125; from './Like' src/components/Like/index.js123456789101112131415161718192021222324252627282930313233343536373839404142import React, &#123; Component &#125; from 'react'export default class Like extends Component &#123; constructor()&#123; super() this.state = &#123; isliked: false &#125; &#125; handleLikedClick = () =&gt;&#123; //使用这种方式在react里是不允许的，可以修改数据，但界面不会重新渲染 //this.state.isLiked = !this.state.isLiked //要修改数据，就要使用setState方法，setState方法有两种情况 //第一个参数又有两种情况，第一种情况是一个对象 // this.setState(&#123; // isliked: !this.state.isliked // &#125;) //第二种情况是一个方法 this.setState((prevState,props)=&gt;&#123; console.log('setState内部的状态',this.state.isliked) return&#123; isliked: !prevState.isliked &#125; &#125;,() =&gt;&#123; //由于setState是异步的，如果要获取到最新的state，应该在这个回调里获取 console.log(this.state.isliked) &#125;) console.log('setState外部的状态',this.state.isliked) &#125; render() &#123; return ( &lt;div&gt; &lt;span onClick=&#123;this.handleLikedClick&#125;&gt; &#123; this.state.isliked ? '取消❤️' : '喜欢🖤' &#125; &lt;/span&gt; &lt;/div&gt; ) &#125;&#125; src/components/TodoHeader/index.js123456789101112131415161718192021222324252627import React from 'react'import PropTypes from 'prop-types'export default function TodoHeader(props) &#123; //console.log(props) return ( &lt;&gt; &lt;h1&gt; &#123;props.children&#125; &lt;/h1&gt; &lt;h3&gt; &#123;props.desc&#125; &lt;/h3&gt; &lt;p&gt;&#123;props.x+props.y&#125;&lt;/p&gt; &lt;/&gt; )&#125;TodoHeader.propTypes = &#123; desc: PropTypes.string.isRequired, x: PropTypes.number.isRequired, //是否是数据以及是否必要 y: PropTypes.number&#125;TodoHeader.defaultProps = &#123; desc: '明天会更好'&#125; src/components/TodoInput/index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//react里面通过ref来获取组件或者dom元素，要使用ref之前必须先调用React.createRef创建一个refimport React, &#123; Component, createRef &#125; from 'react'import PropTypes from 'prop-types'//类组件前面要加this.props 函数用propsexport default class TodoInput extends Component &#123; static propTypes = &#123; btnText: PropTypes.string &#125; static defaultProps = &#123; btnText: '添加TODO' &#125; constructor()&#123; super() this.state = &#123; inputValue: '' &#125; //this.handelAddClickCopy = this.handelAddClick.bind(this,124) //在constructor里来创建Ref this.inputDom = createRef() &#125; handleInputChange = (e) =&gt; &#123; this.setState(&#123; inputValue: e.currentTarget.value &#125;) &#125; handleKeyUp = (e) =&gt;&#123; if(e.keyCode ===13)&#123; this.handelAddClick() &#125; &#125; handelAddClick = () =&gt; &#123; //console.log(this.state) //实际的项目中，这里还需要区队this.state.inputValue做验证，如果验证通过在执行 if(this.state.inputValue === '')&#123; return &#125; this.props.addTodo(this.state.inputValue) this.setState(&#123; inputValue: '' &#125;, () =&gt; &#123; this.inputDom.current.focus() &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange&#125; onKeyUp=&#123;this.handleKeyUp&#125; ref=&#123;this.inputDom&#125; /&gt; &lt;button onClick=&#123;this.handelAddClick&#125;&gt;&#123;this.props.btnText&#125;&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; src/components/TodoList/index.js1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react'import TodoItem from './TodoItem'import PropTypes from 'prop-types'export default class TodoList extends Component &#123; static propTypes = &#123; todos:PropTypes.arrayOf(PropTypes.shape(&#123; id: PropTypes.number.isRequired, title: PropTypes.string.isRequired, isCompleted: PropTypes.bool.isRequired &#125;)).isRequired, onCompletedChange: PropTypes.func &#125; render() &#123; console.log(this.props) return ( &lt;ul&gt; &#123; this.props.todos.map(todo =&gt; &#123; return( // &lt;TodoItem // key=&#123;todo.id&#125; // id=&#123;todo.id&#125; // title=&#123;todo.title&#125; // isCompleted=&#123;todo.isCompleted&#125; // /&gt; &lt;TodoItem onCompletedChange=&#123;this.props.onCompletedChange&#125; key=&#123;todo.id&#125; &#123;...todo&#125; &gt;&lt;/TodoItem&gt; ) &#125;) &#125; &lt;/ul&gt; ) &#125;&#125; src/components/TodoList/TodoItem.js123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from 'react'const noop = ()=&gt; &#123;&#125;export default class TodoItem extends Component &#123; handelCheckboxChange = () =&gt;&#123; const &#123; onCompletedChange = noop, id &#125; = this.props onCompletedChange(id) &#125; render() &#123; const &#123; isCompleted, title &#125; = this.props //下面的this.props.isCompleted可以改成isCompleted return ( &lt;li&gt; &lt;input type=\"checkbox\" checked=&#123;isCompleted&#125; onChange=&#123;this.handelCheckboxChange&#125; /&gt; &lt;span&gt;&#123;title&#125;&#123;this.props.isCompleted ? '完成' : '未完成'&#125;&lt;/span&gt; &lt;/li&gt; ) &#125;&#125;","updated":"2020-04-06T15:09:40.241Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react-基础操作（1）使用cra","date":"2020-03-12T16:49:11.000Z","path":"react3/","text":"https://reactjs.org react官网 react不是一个框架，而是一个库！【详细可以看我之前的文章】 版本16后架构由diff变为fiber 特点：虚拟DOM、组件化、jsx 使用cra在新的文件夹下直接 npx create-react-app react-tuts npm run eject可以查看库 （推荐使用vscode，可以安装ES7 React插件，写起来会更加方便） 因为是初学建议把src下的删除，自己一点一点新建文件学习。 新建index.js 方法一 1234567891011121314151617181920212223242526272829303132333435import React from &apos;react&apos;import ReactDOM from &apos;react-dom&apos;//const app=&lt;h1&gt;Welcome React&lt;/h1&gt;// const createApp = (props) =&gt; &#123;// return (// &lt;div&gt;// &#123;/* 只要在jsx里插入js的代码，就加一层花括号即可，注释也是js，所以这里的注释加了一层花括号 */&#125;// &lt;h1&gt;welcome &#123;props.title&#125;&lt;/h1&gt;// &lt;p&gt;优秀的&#123;props.title&#125;&lt;/p&gt;// &lt;/div&gt;// )// &#125;// const app = createApp(&#123;// title: &apos;React 16.8&apos;// &#125;)//创建组建的第一种方式，使用箭头函数，但是这个名字要大写。下面render里面直接写app,就行const App = (props) =&gt; &#123; return ( &lt;div&gt; &#123;/* 只要在jsx里插入js的代码，就加一层花括号即可，注释也是js，所以这里的注释加了一层花括号 */&#125; &lt;h1&gt;welcome &#123;props.title&#125;&lt;/h1&gt; &lt;p&gt;优秀的&#123;props.title&#125;&lt;/p&gt; &lt;/div&gt; )&#125;ReactDOM.render( &lt;App title=&quot;2020&quot; /&gt;, document.querySelector(&apos;#root&apos;)) 方法二 12345678910111213141516171819202122232425262728import React from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;//定义组建的第二种方式，使用类继承React.Componentclass App extends React.Component&#123; render () &#123; console.log(this.props) return ( &lt;div&gt; &lt;h1&gt;类组件继承&lt;/h1&gt; &lt;p&gt;&#123;this.props.desc&#125;&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;//类组件渲染的原理// const app = new App(&#123;// desc: &apos;类组件是继承React.Component&apos;// &#125;).render//render是react dom提供的方法，通常只会用一次render( &lt;App desc=&quot;类组件是继承React.Component&quot; /&gt;, document.querySelector(&apos;#root&apos;)) 方法三（jsx原理） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import React,&#123; Component &#125; from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;// 表示一个虚拟DOM树的方式// const appVDom = &#123;// tag: &apos;div&apos;,// attrs: &#123;// className: &apos;app&apos;,// id: &apos;appRoot&apos;// &#125;,// children: [// &#123;// tag: &apos;h1&apos;,// attrs:&#123;// className: &apos;title&apos;// &#125;,// children: [// &apos;JSX原理&apos;// ]// &#125;,&#123;// tag: &apos;p&apos;,// attrs: null,// children: [// &apos;类组件是继承React.Component的&apos;// ]// &#125;// ]// &#125;// 所以react在真正的渲染的时候会把之前的代码编译成这样运行，这里的代码就是合法的js代码class App extends React.Component&#123; render () &#123; return ( //React.createElement是一个方法，用于创建元素，可以有很多的参数，但前两个是固定的 //第一个可以理解为标签名 //第二个可以理解为标签的属性 //剩下的，就继续写更多的子元素 React.createElement( &apos;div&apos;, &#123; className: &apos;app&apos;, id: &apos;appRoot&apos; &#125;, React.createElement( &apos;h1&apos;, &#123; className: &apos;title&apos; &#125;, &apos;jsx原理&apos; ), React.createElement( &apos;p&apos;, null, &apos;类组件是继承React.Component的&apos; ) ) ) &#125;&#125;render( &lt;App desc=&quot;类组件是继承React.Component&quot; /&gt;, document.querySelector(&apos;#root&apos;)) 组件中的样式 https://www.npmjs.com/package/classnames 参考官网 https://www.npmjs.com/package/styled-components 参考官网 npm i classnames -S npm i styled-components -S 123456789101112131415161718192021222324252627import React, &#123; Component &#125; from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;import classNames from &apos;classnames&apos;import styled from &apos;styled-components&apos;import &apos;./index.css&apos;const Title = styled.h1` color: #F00`class App extends Component&#123; render () &#123; const style = &#123; color: &apos;#F00&apos; &#125; return ( &lt;div&gt; &lt;h1&gt;元素中的样式&lt;/h1&gt; &lt;ol&gt; &lt;li style=&#123;style&#125;&gt;使用style内联&lt;/li&gt; &lt;li className=&quot;has-text-red&quot;&gt;使用class的方式，但是在react里class要写成className&lt;/li&gt; &lt;li className=&#123;classNames(&apos;a&apos;,&#123;&apos;b&apos;:true,&apos;c&apos;:false&#125;)&#125;&gt;要动态添加不同的className就可以使用第三方的包叫classNames,比如这个li上只有ab没有c&lt;/li&gt; &lt;Title&gt;style-components的使用&lt;/Title&gt; &lt;/ol&gt; &lt;/div&gt; ) &#125;&#125;","updated":"2020-03-29T13:32:03.938Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://lifei-2019.github.io/tags/webpack/"}]},{"title":"react-webpack基本配置（2）","date":"2020-03-07T14:45:27.000Z","path":"react2/","text":"css预处理和autoprefixernpm i less-loader less –save-dev 打包.less npm i postcss-loader autoprefixer -D 为了打包的css加前缀 webpack.config.js里module部分修改为 12345678910111213141516171819202122232425262728module: &#123; rules: [ &#123; test:/\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader' //后写的先执行,postcssloader一定要写在后面 ], exclude: /node_modules/ &#125;, &#123; test:/\\.less$/, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader' , &#123; loader:'less-loader', options:&#123; &#125; &#125; //和上面对比两种写法 ], exclude: /node_modules/ &#125;, ],&#125;, 创建postcss.config.js给css加前缀 123456789module.exports = &#123; plugins:[ require('autoprefixer') ]&#125; 在package.json里加入 123&quot;browserslist&quot;: [ &quot;cover 99.5%&quot;] 处理图片资源新建src/assets，放一张照片gundum.jpg。直接编译发现出错 npm i file-loader –save-dev npm install url-loader –save-dev url-loader包涵file-loader 在module的rules里添加 12345678910111213&#123; test: /\\.(png|jpe?g|gif)$/i, use: [ &#123; loader: &apos;url-loader&apos;, options: &#123; limit: 512, //小于512则放到css里，大于512以图片 name: &apos;images/[name].[ext]&apos;, publicPath: &apos;/&apos; &#125;, &#125;, ], &#125; 处理静态资源-copynpm install copy-webpack-plugin –save-dev 在webpack.config.js里的plugins里添加 1234567new CopyPlugin([ &#123; from: path.resolve(process.cwd(),&apos;src/static/&apos;), to: path.resolve(process.cwd(),&apos;dist/static/&apos;) &#125;, ]), 添加babelnpm install -D babel-loader @babel/core @babel/preset-env 在module的rules里添加 123456789101112&#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [ &apos;@babel/preset-env&apos; ] &#125; &#125;&#125; 此处要挖一个node的坑 可以建立一个test.js 1234export const add = (x,y) =&gt; &#123; console.log(x + y) console.log(`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`) //这里一定要用tab上面的反引号。&#125; 并且在index.js中引用test.js里的add 12import &#123;add&#125; from &apos;./test&apos;add(1,2) 测试完成后，复制一份webpack.config.js，分为dev和prod版本，同时修改package.json里的scripts里的路径。 这样做的目的是因为在dev版本里不需要css等静态资源的压缩。","updated":"2020-03-07T14:51:08.524Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://lifei-2019.github.io/tags/webpack/"}]},{"title":"react-webpack基本环境配置（1）","date":"2020-03-06T02:29:31.000Z","path":"react1/","text":"看官网源码很重要！！！！ www.npmjs.com npm官网 www.webpackjs.com webpack官网 入口 出口 loader 插件 npm i webpack webpack-cli -D npm i –save-dev css-loader npm i –save-dev webpack-dev-server npm i style-loader -D npm i -save-dev mini-css-extract-plugin 申请的CSS自动提取 package.json 修改scripts里 12345&quot;dev&quot;: &quot;webpack-dev-server --mode development --config scripts/webpack.config.js&quot;,&quot;build&quot;: &quot;webpack --mode production --config scripts/webpack.config.js&quot;,(dev保留代码) 默认入口是src下的index.js 这个很重要 因为如果不是index的话就会listing directory 修改webpack.config.js里的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const path = require('path')const HtmlWebPackPlugin = require('html-webpack-plugin')const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\") //创建一个插件的实例对象const htmlPlugin = new HtmlWebPackPlugin(&#123; template: 'public/admin.html', title: 'webpack', filename: 'index.html'&#125;)// const minicssPlugin = new MiniCssExtractPlugin(&#123;// filename: 'static/css/[name].[chunkHash:8].css',// &#125;)两种形式module.exports = &#123; entry: &#123; index: './src/index.js' &#125;, output: &#123; path: path.resolve(process.cwd(),\"dist\"), filename: 'static/js/[name].[hash:8].js' //可以用chunkHash同一次操作每个文件都不一样 &#125;, plugins: [ htmlPlugin, new MiniCssExtractPlugin(&#123; filename: 'static/css/[name].[hash:8].css', &#125;) ], module: &#123; rules: [ &#123; test:/\\.css$/, use: [ MiniCssExtractPlugin.loader, 'css-loader' //后写的先执行 ], exclude: /node_modules/ &#125;, ], &#125;, devServer: &#123; publicPath: \"/\", progress: true, //contentBase: \"./dist\", //服务启动在哪一个文件夹下 open: true, // 启动服务时，自动打开浏览器 port: 3000, // 端口号 hot: true, // devServer开启Hot Module Replacement的功能 与chunkhash冲突所以原先在此关闭 hotOnly: false, // 即便HMP的功能没有生效，浏览器也不能自动刷新 compress: true &#125;&#125; 运行npm run build或者npm run dev","updated":"2020-05-14T01:07:50.708Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://lifei-2019.github.io/tags/webpack/"}]},{"title":"webpack-03","date":"2020-03-03T10:28:31.000Z","path":"webpack-03/","text":"webpack-dev-server错误法则： ​ 前往项目根目录删除node_modules文件夹，然后在项目根目录路径下的终端运行”npm install”等待安装完之后，再次运行“npm run dev”，有些人的是马上就可以了，然而往往还会有人（譬如我）仍然报类似的错误，这个时候你只需要再次重复相同的操作即可，“一次不成再删再安装”！！！","updated":"2020-03-06T08:57:54.837Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"webpack","slug":"webpack","permalink":"https://lifei-2019.github.io/tags/webpack/"}]},{"title":"webpack-01","date":"2020-03-01T02:28:16.000Z","path":"webpack-01/","text":"看官网源码很重要！！！！ www.npmjs.com npm官网 www.webpackjs.com webpack官网 入口 出口 loader 插件 npm i webpack webpack-cli -D npm i –save-dev css-loader npm i –save-dev webpack-dev-server npm i style-loader -D npm i -save-dev mini-css-extract-plugin 申请的CSS自动提取 package.json 修改scripts里 12345&quot;dev&quot;: &quot;webpack-dev-server --mode development --config scripts/webpack.config.js&quot;,&quot;build&quot;: &quot;webpack --mode production --config scripts/webpack.config.js&quot;,(dev保留代码) 默认入口是src下的index.js 这个很重要 因为如果不是index的话就会listing directory 修改webpack.config.js里的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const path = require(&apos;path&apos;)const HtmlWebPackPlugin = require(&apos;html-webpack-plugin&apos;)const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;) //创建一个插件的实例对象const htmlPlugin = new HtmlWebPackPlugin(&#123; template: &apos;public/admin.html&apos;, title: &apos;webpack&apos;, filename: &apos;index.html&apos;&#125;)// const minicssPlugin = new MiniCssExtractPlugin(&#123;// filename: &apos;static/css/[name].[chunkHash:8].css&apos;,// &#125;)两种形式module.exports = &#123; entry: &#123; index: &apos;./src/index.js&apos; &#125;, output: &#123; path: path.resolve(process.cwd(),&quot;dist&quot;), filename: &apos;static/js/[name].[hash:8].js&apos; //可以用chunkHash同一次操作每个文件都不一样 &#125;, plugins: [ htmlPlugin, new MiniCssExtractPlugin(&#123; filename: &apos;static/css/[name].[hash:8].css&apos;, &#125;) ], module: &#123; rules: [ &#123; test:/\\.css$/, use: [ MiniCssExtractPlugin.loader, &apos;css-loader&apos; //后写的先执行 ], exclude: /node_modules/ &#125;, ], &#125;, devServer: &#123; publicPath: &quot;/&quot;, progress: true, //contentBase: &quot;./dist&quot;, //服务启动在哪一个文件夹下 open: true, // 启动服务时，自动打开浏览器 port: 3000, // 端口号 hot: true, // devServer开启Hot Module Replacement的功能 与chunkhash冲突所以原先在此关闭 hotOnly: false, // 即便HMP的功能没有生效，浏览器也不能自动刷新 compress: true &#125;&#125; 运行npm run build或者npm run dev","updated":"2020-03-06T08:57:43.800Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"webpack","slug":"webpack","permalink":"https://lifei-2019.github.io/tags/webpack/"}]},{"title":"国境以南","date":"2020-01-06T01:51:56.000Z","path":"国境以南/","text":"","updated":"2020-01-06T01:51:56.330Z","link":"","tags":[]},{"title":"沉默的大多数","date":"2020-01-06T01:51:31.000Z","path":"沉默的大多数/","text":"","updated":"2020-01-06T01:51:31.454Z","link":"","tags":[]},{"title":"剑桥倚天屠龙史","date":"2020-01-06T01:43:39.000Z","path":"剑桥倚天屠龙史/","text":"经历了漫长的复习周，终于有时间把之前读的书做一份书评。 先说说这本《剑桥倚天屠龙史》，源自知乎大佬推荐，其实记忆里对原著的印象已经不是很深，只记得张无忌以一己之力力克六大门派守护光明顶，然后与balabala过上了幸福的生活hhhh 这本书很合胃口的原因也正因为其各种“恶趣味”，例如将明教权利人士分为“降临派”和“拯救派”、少林的“面壁者”渡厄、渡难（此处借鉴三体）、《神圣的雕之罗曼史》（神雕侠侣）等等，可以说阅历越丰富越能get到作者的点。【此处对作者新垣平致以崇高的敬意，历史沉淀深厚，思维逻辑严谨，佩服！】 作者在考量故事时，侧重的更多是理性的政治利益和集体中对于夺权的心机，相较于原著更符合人之常情与利益争夺。好似美剧《纸牌屋》中党鞭弗兰克利用对于众议院和参议院中权利的制衡，一步步当上总统。权力是人类社会发展必然的产物，人人平等并非不可能实现，只是说在当下社会中，如《1984》里所言，位居统治阶级想的事情与位居solider想的可以说是天差地别，人类可考究的六千年历史中从独权到共和（权？），集体中的争权与争宠，已然融入到人的骨髓中，个人改变社会的欲望所对抗的不仅仅是统治阶级，也不仅是人民，而是几千年的统治经验。随着读书阅历的增长，我甚至有些佩服在中华民国诞生时生活的人们，突然告诉一个人你从小接受的教育都是错误的，是奴性的，就好似告诉你见到人行礼是错的，无论你愿不愿意都要改，也更佩服孙中山先生在改变奴性的同时给人们灌入了新的“奴性”，《走向共和》里有一幕令我印象十分深刻，在经历袁世凯复辟后，孙中山怒不可遏当下就要修改入党宣言：第一条便是要忠于他，此时好友李大钊顿时翻脸：共和象征着平等自由，如果一定要忠于您的话，您与专制有什么区别？两人说罢大打出手，最终不欢而散。其实从根本上说，两人都没错，李大钊更多的是一种读书人的思想，比较理想化，换作旧社会信息交流不那么发达时或许可以完全控制人的思想，可惜当时虽没有网络，已然有了电话，可以走出国门看世界，想要个个忠于理想，以身作则践行信仰实则难事（更不用说如今）；而孙先生也是迫不得已，自小接受的教育让他感到愤怒与震惊，一个人怎么能违背自己的信仰呢？一定是在传道时没有说的清楚明白，殊不知千人前面。","updated":"2020-03-12T08:59:59.245Z","link":"","tags":[{"name":"读书","slug":"读书","permalink":"https://lifei-2019.github.io/tags/读书/"}]},{"title":"react-04","date":"2019-12-09T12:11:09.000Z","path":"react-04/","text":"7.在项目中使用React1.运行cnpm i react react-dom -S安装包* react: 专门用于创作组件和虚拟DOM，同时组件的生命周期都在这个包里 * react-dom：专门进行DOM操作，最主要的应用场景，就是ReactDOM.render()2.在index.html里，创建容器：1&lt;div id=\"app\"&gt;&lt;app&gt;&lt;/div&gt; 3.导入包：12import React from 'react' //创建组件、虚拟DOM元素，生命周期import ReactDOM from 'react-dom' //把创建好的组件和虚拟DOM放到页面上展示 4.创建虚拟DOM元素123456789//2.创建虚拟DOM元素//参数1： 创建的元素的类型，字符串，表示元素的名称//参数2： 是一个对象或null，表示当前这个DOM元素的属性//参数3： 子节点（包括其他虚拟DOM获取文本子节点）//参数n： 其他子节点// &lt;h1 id=\"myh1\" title=\"this is h1\"&gt;&lt;/h1&gt;//const myh1 = React.cloneElement('h1',null,'这是一个大大的h1')const myh1 = React.createElement('h1',&#123;id: 'myh1',title: 'this is h1'&#125;,'这是一个大大的h1') 5.渲染：1ReactDOM.render(myh1,document.getElementById('app')) 配置webpack可以看 传送门 8.JSX语法 符合xml规范的JS语法；（语法格式上来说，要比HTML严谨） 1.启用jsx语法 安装bable插件 运行 cnpm i @babel/core babel-loader babel-plugin-transform-runtime @babel/runtime -D 运行cnpm i @babel/preset-env -D (语法) 安装能够识别转换jsx语法的包babel-preset-react （JSX变成能识别的react） 运行cnpm i @babel/preset-react -D 添加.babelrc配置文件 1234567891011&#123; &quot;presets&quot;:[ //语法 &quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot; ], &quot;plugins&quot;:[ //插件 &quot;@babel/plugin-transform-runtime&quot;, &quot;@babel/plugin-proposal-class-properties&quot; ] &#125; 2.JSX语法本质：并不是直接把jsx渲染到页面上，而是在内部转换成createElement形式再渲染的。 3.jsx中混合写入js表达式：要把js代码写在{}中 4.注释 推荐使用｛/* 这是注释 */｝ 5.为元素添加class类名： 需要用className来替代class；htmlFor替换label的for属性 6.在JSX创建DOM时，所有的节点，必须有唯一的根元素进行包裹 7.在JSX语法中，标签必须成对出现，如果是单标签要自闭和（比如&lt;hr/&gt;分割线） 编译过程&lt;就把它当作HTML编译，碰到{}就当作普通JS代码。 Tips： 用([+-/开头的上一段结尾要加分号。 React中需要把key添加给 forEach或map或for循环直接控制的元素 9.React中创建组件方法一 使用构造数。如果需要接受外界传递的数据，需要在狗在函数的参数列表中使用props来接收；必须要向外return一个合法的JSX创建的虚拟DOM； 创建组件： 1234function Hello()&#123; //return null return &lt;div&gt;Hello zujian&lt;/div&gt;&#125; 为组件传递数据 123456789101112//使用组件并未组件传递props数据&lt;Hello name=&#123;dog.name&#125; age=&#123;dog.age&#125; gender=&#123;dog.gender&#125;&gt;&lt;/Hello&gt;//在构造函数中，使用props形参，接收外界传来的数据function Hello(props)&#123; //如果在一个组件中return一个null，则表示此组件是空的，什么都不会渲染 //return null console.log(props) //props.name = 'zs' //组件中的props都是只读的，不能被重新赋值。 return &lt;div&gt;zheshige hello &lt;/div&gt;&#125; 方法二","updated":"2019-12-10T02:56:19.275Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"【踩坑】babel二三事","date":"2019-12-02T02:17:39.000Z","path":"babel/","text":"babel再次教会除了python有很多是更新后不和上一代兼容的。 简单讲 Babel 是 Javascript 编译器 ,将 ES6,ES7 ,ES8 转换成 浏览器都支持的ES5 语法,并提供一些插件来兼容浏览器API的工具。是怎么实现的勒, Babel 会将源码转换 AST(抽象语法树)之后，通过便利AST树，对树做一些修改，然后再将AST转成code，即成源码,通俗讲就是整了个容，浏览器觉得挺漂亮的,让代码在浏览器上耍撒 写在前言：随着越来越多的人投身互联网行业，“老师”层出不穷，没有对前辈不尊敬的意思，只是每个人遇到的情况不同，很多时候更需要自己去读控制台的错误信息，而不是单纯的复制下来去百度。 昨晚在学习babel的时候，因为视屏是在去年录制的，过了一年很多配置更新了，于是参照b站视屏下面的带佬的教程，也有很多人表示方法很好用 可是到了我这里就成了 反复重装了@babel/core、@babel/preset-env、@babel/runtime、@babel/plugin-transform-runtime、@babel/preset-react，又开始报错babel-loader版本不对，应该对应@babel/core7，弄了一晚上没弄出来，@生生如弈的教程在用loader7替换8的时候babel-core的6和7同时存在也会发生冲突。 扯远了，回到正题，学习任何一个框架、语言、库，最好的方法都是先去啃它的官方文档。传送门-&gt; 建议都安装最新的版本。（哪怕和视屏教程不符，毕竟现在技术更新换代，真的很快） 简单的说，昨晚一晚上的错误在于 升级到babel7后，所有的babel-core都变成了@babel/core形式 如果硬要像上述截图中一定要使用babel-loader7不安装最新的话，那安装的所有插件都要用-形式的。 下面是我最终的配置 @babel/core AST转换的核心 @babel/cli 打包工具 @babel/plugin* Babel 插件机制，Babel基础功能不满足的时候,手动添加些 @babel/preset-env 把许多 @babel/plugin 综合了下，减少配置 @babel/polyfill 把浏览器某些不支持API，兼容性代码全部导入到项目,不管你是不是用到,缺点是代码体积特别大 @babel/runtime 把你使用到的浏览器某些不支持API，按需导入,代码少 学前端千万不要怕麻烦！","updated":"2020-09-08T12:22:20.337Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"babel","slug":"babel","permalink":"https://lifei-2019.github.io/tags/babel/"}]},{"title":"devDependencies和dependencies的区别","date":"2019-11-30T01:45:41.000Z","path":"vscode-02/","text":"devDependencies辅助开发，用于本地环境开发。没有项目照样运行，有了更好。 12比如安装浏览器同步测试工具Browsersync它可以让浏览器实时、快速响应您的文件更改（html、js、css、sass、less等）并自动刷新页面。更重要的是 Browsersync可以同时在PC、平板、手机等设备下进项调试。这个工具是为了方便我们浏览调试的，所以有了更好没有也不影响项目的运行. dependencies核心依赖，用于用户发布环境。少了项目没法正常运行，必须要有。 npm install -D到devDependencies npm install –save到dependencies","updated":"2019-12-02T02:18:06.308Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"vscode","slug":"vscode","permalink":"https://lifei-2019.github.io/tags/vscode/"}]},{"title":"react-03","date":"2019-11-28T01:39:42.000Z","path":"react-03/","text":"DOM树的概念：一个网页呈现的过程： 1、浏览器请求服务器获取页码HTML代码 2、浏览器要先在内存中，解析DOM结构，并在浏览器内存中，渲染一棵DOM树 3、浏览器把DOM树呈现到页面上 如何实现页面按需更新？获取内存中的新旧两个DOM，进行对比，获得需要被按需更新的DOM元素 但是浏览器没有直接提供获取DOM树的API，因此无法拿到浏览器内存中的DOM树； 这需要我们手动模拟DOM树 1234&lt;div id=\"mydiv\" title=\"加油\" data-index=\"0\"&gt; 春风十里不如你 &lt;p&gt;哈哈哈&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718var div = &#123; tagName:'div' attrs:&#123; id:'mydiv', title:'努力', data-index='0' &#125;, childrens:[ '春风十里不如你', &#123; tagName:'p', attrs:&#123;&#125;, childrens:[ “哈哈哈” ] &#125; ]&#125; 虚拟DOM：框架中的概念。用JS对象的形式来模拟页面上的DOM嵌套关系，为了实现页面元素的高效更新。 diff算法 treediff：新旧两颗DOM树逐层对比 component：在进行treediff时，每一层中，组件级别的对比 如果对比前后组件类型相同，则暂时认为此组件不需要被更新； 如果对比前后组件类型不同，则需要移除旧组件，创建新组建，并追加到页面上； element diff：组件类型相同，则需要进行元素级别的对比 创建基本的webpack4.X项目1.新建文件夹，运行npm init -y初始化 2.在根目录创建src源代码目录和dist产品目录 3.在src创建index.html 4.使用npm安装 webpackcnpm i webpack webpack-cli -D * 如果用cnpm需要用`npm i cnpm -g` 此处是在项目里安装webpack，我个人觉得可以全局安装webpack毕竟很常用。 5.注意：webpack 4.x提供了约定大于配置的概念；目的是为了尽量减少配置文件的体积 * 默认约定了： * 打包的入口是：`src` -&gt;`index.js` * 打包的输出文件是：`dist` -&gt;`main.js`，可以在webpack.config.js里修改entry * 4.x中新增了mode选项（必写），可选的值为：development和production6.为了每次更新后不用重新打包，提高效率，用cnpm i webpack-dev-server -D，在package.json里添加&quot;dev&quot;: &quot;webpack-dev-server&quot;，在此打包时可以直接在控制台输入npm run dev 同时可以在地址栏输入http://localhost:8080/可以看到 ES6中的特性 chrome支持哪些，则Node.js就支持哪些。Babel支持所有。 自己踩得大坑： package.json文件的格式问题。 检查属性名称喝属性值是否都用 “”括起来； 还有最后一个依赖的末尾不需要加 “，”；以及冒号问题。 “dev”: “webpack-dev-server –open firefox（通过火狐浏览器打开） –port 3000（修改端口号） –hot –progress（过程） –compress（网络压缩） –host 127.0.0.1（域名）” 内存比磁盘存储更快，webpack-server存在内存里不显示在目录上，所以要引用的时候路径要改成”\\main.js” cnpm i html-webpack-plugin -D","updated":"2019-11-28T01:41:21.070Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"前端开发环境搭建vscode+node.js","date":"2019-11-25T04:54:21.000Z","path":"vscode-01/","text":"1.安装及环境变量配置 vscode 请到官网下载对应版本 node.js 请到官网下载对应版本 目前安装好像都自动配置环境变量，但是我尝试下载包的时候发现路径不对 发现还需要在cmd里进行如下配置 12&gt;npm config set prefix “E:\\nodejs\\node_global”&gt;npm config set cache “E:\\nodejs\\node_cache” 然后打开安装目录的node_modules\\npm\\npmrc 打开之后进行如下配置 新建NODE_PATH 1D:\\nodejs\\node_modules 在系统Path变量里添加 1D:\\nodejs\\node_modules 配置完成后可以通过安装一个集成几个翻译平台的命令行工具作测试： 注意此处的路径，这个路径是设置的全局保存的路径，如果路径不对，则是上述的npmrc没有生效。 看下效果： 2.YARN包管理器 如果说npm是皇家正统，那么yarn就是爵士大将军！yarn基于node，并且速度更快，能自动缓存你下载过的包，让你在离线、重复下载时不需要通过去网上拉取文件，直接在本地就可以安装你需要的包！并且，yarn分离的各个包的安装过程，合理排队，不产生高频请求，单个包安装失败并不影响其他包的安装，有效的重试机制等！ yarn有多个类别的包提供安装 官网下载 或者使用npm安装： 12345D:\\nodejs&gt;npm install -g yarnD:\\nodejs\\node_global\\yarnpkg -&gt; D:\\nodejs\\node_global\\node_modules\\yarn\\bin\\yarn.jsD:\\nodejs\\node_global\\yarn -&gt; D:\\nodejs\\node_global\\node_modules\\yarn\\bin\\yarn.js+ yarn@1.19.2added 1 package in 1.112s yarn的教程参照官网 3.VSCode插件之前出过 Sublime的使用教程，有兴趣的可以康康。 言归正传，开始介绍VSCode的插件。 1.Chinese（Simplified） language语言插件，vscode默认语言英语，需要安装其他语言插件；如果安装重启vscode没哟起效，在 locale.json 中添加 “locale”: “zh-cn”，即可载入中文（简体）语言包。要修改 locale.json，你可以同时按下 Ctrl+Shift+P 打开命令面板，之后输入 “config” 筛选可用命令列表，最后选择配置语言命令。 2.Auto Rename Tag 标签自动重命名（当然如果你使用的是pug语法可以忽略） 3.代码美化工具 Beautify该插件支持js、josn、css、sass和html的代码美化 css快速预览与修改工具 CSS Peek,支持css的快速跳转 如果你对思考怎么写一个css的名称很苦恼的话还可以装个IntelliSense for CSS class names in HTML插件 4.图标库 Material Icon Theme 对当前流星雨烟和后缀名进行单独匹配好看又丰富的图标 view in Browser 静态网页可以支持直接在默认浏览器预览 5.基于技术栈的插件 关于Vue、React的 vue-beautify、Vue VSCode Snippets、Vue Peek，ES7 React/Redux/GraphQL/React-Native snippets、React Native Tools等，涵盖代码美化、Vue代码补全、组件跳转预览等功能，同时你也可以安装一些UI库的代码提示补全，如vscode-element-helper、Ant Design Snippets不过这些插件并没有兼容html的语法，如果你使用了类似pug这样的语法，那么久会有很多功能受到限制！ 关于css Beautify css/sass/scss/less、language-stylus、Sass、Sass Lint、Sass Lint等根据需要选择。 关于html 非常推荐使用Pug的语法，不需要成对标签，特点明确，格式要求严格，可以让代码非常规范而且易读性很高！推荐插件，Pug (Jade) snippets。 Pug的语法简单易学，没有了尖尖角角看起来也很整洁！ 文档 关于js Quokka.js支持js文件内的部分代码直接计算并返回计算结果 JavaScript (ES6) code snippets支持最新的ES6语法，支持很多代码快捷公式。 6.代码管理插件 GitLens - Gitsupercharged、Git History 支持快速预览提交历史： 支持版本查看： 支持当前行修改记录查看： 支持修改差距对比： 安装git后自动支持一键化代码提交操作： 推荐安装 Markdown All in One插件，支持所有markdown语法，同时支持快捷键操作进行修改！ 7.Setting Sync(强推)安装后ctrl+shift+P输入Sync，选择How to configure打开网页帮助 1.登录github，在设置里开启Github Token和Github GIST ID，绑定后可以上传当前VSCode 2.重新设置同步功能参见简书Aweber用户的文章 8.vscode-icons显示文件夹图标 4.VSCode设置Ctrl + Shift + P 打开vscode命令行控制台，输入setting，可以选择进入设置(UI)界面和setting.json setting.json只会显示你更改的设置！而UI界面你得慢慢的去找！ vscode 支持安装其他软件的快捷键命令：Sublime Text（Sublime Text Keymap and Settings Importer）等，不一一列举，输入 keymap即可搜索到所有的快捷键替换插件： 最近临近考试周，先凑活着用，考完继续！","updated":"2020-03-25T03:55:25.741Z","link":"","tags":[{"name":"tools","slug":"tools","permalink":"https://lifei-2019.github.io/tags/tools/"}]},{"title":"1984|我们将会在黑暗中相见","date":"2019-11-17T12:12:24.000Z","path":"1984/","text":"《1984》给我带来的深刻意义在于他对人类社会整体意识形态的描述，1948年的乔治奥威尔所写下不是发生在1984年的预言，时至今日， 老大哥仍然在各个角落看着我们。网络警察、思想控制、学xi强国、微博上因为美色泻露国家秘密罪而被蒸发。永远都有一小撮妄图颠覆我伟大民族的坏分子。永远都是被暴徒煽动的人民群众。永远都是痛哭着扑向党啊母亲怀抱幡然悔悟的羊羔们。（以前读到这种文字我会觉得这只是愤青的煽动之词罢了，不曾想到自己也会写下这些“胡言乱语“。罪过。每个人的路各不相同，但是交流是无罪的。） 书的封面只有一句话“自由是说二加二等于四的自由。如果这是允许的，其他的一切都随之而来。” 初读第一遍时有些疑惑，二加二等于四，在我们现阶段的教育里可以算上是公理，是不需要证明的，然而读到第三部分时：“如果我想，我甚至可以让水滴悬空，什么是事实？映射到脑海里你相信的是事实”； 古人云：以史为鉴，可以知兴替。中华民族近代史被侵略的历史告诉我们，我们的土地可能被侵略，我们的人民可能被奴役，我们的文化可能被遮盖，但是爱国精神不止，你可以剥夺我的自由，剥夺我去追求美好，但是有些东西你剥夺不了，比如我爱一个人、爱一个国家的心，然而《1984》好像一记响亮的巴掌把我打醒，当温斯顿被戴上装满他最怕的老鼠的头套后，他嘶吼着“做什么都可以，让它们去咬查莉娅”成了压垮读者心里的最后一棵稻草。 再次见到查莉娅时，老大哥没有监视这场会面，或许说，不需要监视，说过的话已经在他们的心中划开一道口子，流血不止。 除此之外，此处的“史”是历史学家所说的历史，是唐朝贞观之治后又一个太平盛世的“史”，但是《1984》里作者用冷冰冰的文字发表了他的观点“谁控制了过去，谁就控制了未来；谁控制了现在，谁就控制了过去”（感谢github不会被百度seo）在下不过一届皮民，舞台留给各位自己脑补。 书中还有贯穿始终的一句话： “战争即是和平” “自由即是奴役” “无知即是力量” 第一句话与之前的《战争之王》中的情节相似， 电影结尾，尤里被正义的杰克抓住后，只是冷静的讲了一番话，告诉他自己的存在是一个必须，即使是那些看上去很正义的人也需要他的工作。因为这件事，总要有人去做。【看了别人的书评还有另一种解释： 不断塑造外敌来转化内部矛盾。】 第二句话可以用《动物庄园》里的一句话来解释： 激烈的批评被消灭了，他们再来消灭温和的批评，等到温和的批评都没有的时候，他们就消灭那些保持独立不赞美的人了，到最后，如果鼓掌不起劲，都会被消灭。 自由其实只是一种希望，一个指引我们一直向更美好的生活奋斗的目标。正因为它一直不能完全实现，所以它能一直吸引我们前进。从这点来看，我们是被自由奴役了，当然，这种奴役的身份也是大家都欣喜担当的。 第三句话：无知则易教化，民顺则邦兴。 这本书没在中国被禁，确实应了查建英说的，党的身段比她哥哥想象的灵活多了，老大哥绝不总板着脸，他偶尔流露出的慈爱眼光我们望一眼就会痛哭流涕，这关怀像求雨得逞一样让我们对天愈加崇拜和无法抗拒，忘记对自由的渴望曾经带来同样强烈的情绪反应。所以恐怕感动是不够的，什么时候，就会有一颗子弹秘而不宣地射中我们充满光明幻想的后脑勺。所以，或者吧。要么变成一个吃喝拉撒性欲充足的动物，要么就像豆瓣网友说的那样，多一个人看Orwell，多一份自由的保障，多一个为我们无从选择的命运而痛苦的人。“她很清楚的知道自己在遭遇什么——同我一样清楚的知道——在严寒中跪在贫民窟后院的脏石块上捅一条发臭的排水管，是一种多么不幸的命运”。所以，不论未来或者将来将怎么样，至少我们能够清楚地知道自己在遭遇什么，我们的命运带领我们而去的并不都是我们的未来。 最后感谢民族团结、国家独立，能让我们有机会用汉语交流，哪怕只是“新话”，能够与人沟通是一件多么美好的事。 下一本想看《狂热分子》，也想看《魔山》，算了还是好好弄期末考试好了。","updated":"2019-11-25T02:06:56.825Z","link":"","tags":[{"name":"读书","slug":"读书","permalink":"https://lifei-2019.github.io/tags/读书/"}]},{"title":"github-api（v3）","date":"2019-11-12T02:54:54.000Z","path":"github-api/","text":"分享几个常用的github-api。 1.查询项目最新提交信息 以我的github项目为例，api完整链接如下。 https://api.github.com/repos/lifei-2019/react-demos/commits?per_page=10&amp;sha=master 可选参数 per_page 查询条数 sha 查询分支 想要查询你自己的项目，只需将lifei-2019替换成你要查询的用户id，react-demos替换成你要查询的该用户的项目即可。 2.查询用户基本信息依旧是以我的github账户为例，可查看用户的详细信息，返回信息如下json。 https://api.github.com/users/lifei-2019 123456789101112131415161718192021222324252627282930313233&#123; &quot;login&quot;: &quot;lifei-2019&quot;, &quot;id&quot;: 54241633, &quot;node_id&quot;: &quot;MDQ6VXNlcjU0MjQxNjMz&quot;, &quot;avatar_url&quot;: &quot;https://avatars1.githubusercontent.com/u/54241633?v=4&quot;, &quot;gravatar_id&quot;: &quot;&quot;, &quot;url&quot;: &quot;https://api.github.com/users/lifei-2019&quot;, &quot;html_url&quot;: &quot;https://github.com/lifei-2019&quot;, &quot;followers_url&quot;: &quot;https://api.github.com/users/lifei-2019/followers&quot;, &quot;following_url&quot;: &quot;https://api.github.com/users/lifei-2019/following&#123;/other_user&#125;&quot;, &quot;gists_url&quot;: &quot;https://api.github.com/users/lifei-2019/gists&#123;/gist_id&#125;&quot;, &quot;starred_url&quot;: &quot;https://api.github.com/users/lifei-2019/starred&#123;/owner&#125;&#123;/repo&#125;&quot;, &quot;subscriptions_url&quot;: &quot;https://api.github.com/users/lifei-2019/subscriptions&quot;, &quot;organizations_url&quot;: &quot;https://api.github.com/users/lifei-2019/orgs&quot;, &quot;repos_url&quot;: &quot;https://api.github.com/users/lifei-2019/repos&quot;, &quot;events_url&quot;: &quot;https://api.github.com/users/lifei-2019/events&#123;/privacy&#125;&quot;, &quot;received_events_url&quot;: &quot;https://api.github.com/users/lifei-2019/received_events&quot;, &quot;type&quot;: &quot;User&quot;, &quot;site_admin&quot;: false, &quot;name&quot;: &quot;LF&quot;, &quot;company&quot;: null, &quot;blog&quot;: &quot;https://lifei-2019.github.io/&quot;, &quot;location&quot;: null, &quot;email&quot;: null, &quot;hireable&quot;: null, &quot;bio&quot;: &quot;不带评论的观察是人类智力的最高形式&quot;, &quot;public_repos&quot;: 12, &quot;public_gists&quot;: 0, &quot;followers&quot;: 2, &quot;following&quot;: 2, &quot;created_at&quot;: &quot;2019-08-18T14:23:37Z&quot;, &quot;updated_at&quot;: &quot;2019-11-08T06:00:44Z&quot;&#125; 3.获取用户followers列表https://api.github.com/users/lifei-2019/followers 想查看其他用户的只需将lifei-2019替换成你需要查看的用户id即可。 4.获取用户following列表https://api.github.com/users/lifei-2019/following 想查看其他用户的只需将lifei-2019替换成你需要查看的用户id即可。 5.获取用户stared项目列表https://api.github.com/users/lifei-2019/starred 想查看其他用户的只需将lifei-2019替换成你需要查看的用户id即可。 6.列出观察者返回一个数组，包含每一个对该项目watch的用户列表。 1.语法GET /repos/:owner/:repo/subscribers 完整api为https://api.github.com拼接上文档中给出的url。 2.关键参数:owner 替换为项目作者 :repo 替换为项目名称 3.demohttps://api.github.com/repos/lifei-2019/react-demos/subscribers 7.其他SolomonXie的文章","updated":"2019-11-12T04:39:05.588Z","link":"","tags":[{"name":"github","slug":"github","permalink":"https://lifei-2019.github.io/tags/github/"}]},{"title":"hexo 常见问题汇总","date":"2019-11-12T02:53:21.000Z","path":"hexo4/","text":"泄露（Escape）内容Hexo 使用 Nunjucks 来解析文章（旧版本使用 Swig，两者语法类似），内容若包含 `{{ }}` 或 `{% %}` 可能导致解析错误，您可以用 raw 标签包裹来避免潜在问题发生。 1&#123;% raw %&#125;Hello &#123;&#123; sensitive &#125;&#125;&#123;% endraw %&#125; 更多可查看hexo文档","updated":"2019-11-12T04:39:42.904Z","link":"","tags":[{"name":"hexo","slug":"hexo","permalink":"https://lifei-2019.github.io/tags/hexo/"}]},{"title":"react_this","date":"2019-11-11T11:37:28.000Z","path":"react-this/","text":"函数的this指向是在进入执行上下文的时候才确定的，它并不是静态绑定的。 12345678910var x = 1;var obj = &#123; x: 2, getValue: function() &#123; return this.x &#125;&#125;var fn = obj.getValuefn() // 1obj.getValue() // 2 但是使用bind,可以返回一个新的函数，当这个函数调用的时候this指向的是传入值，例如把上一段代码稍加修改。 12var fn = obj.getValue.bind(obj)fn() // 2 在react中这样写，是为了让子组件在调用这个函数的时候this是指向父组件的。","updated":"2019-11-11T13:35:59.284Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react_constructor()、super()、super(props)","date":"2019-11-11T11:20:02.000Z","path":"react-constructor函数/","text":"使用es6的class定义react组件时，经常会看到下面的代码： 1234constructor(props) &#123; super(props); ...&#125; 通常会有两个疑问： 必须要调用super()吗？ super()与super(props)有什么不同? 一、第一个问题先说结论： 只要存在constructor就要调用super() 但是，不是每个react组件都需要constructor，比如下面的代码是可以正常运行的： 1234567class App extends React.Component &#123; render() &#123; return ( &lt;h1&gt;&#123;this.props.text&#125;&lt;/h1&gt; ); &#125;&#125; 很多时候需要在constructor中访问this： 123constructor() &#123; console.log(this); --- Syntax error: 'this' is not allowed before super()&#125; 这是因为当没有调用super()时，this还没有被初始化，所以不能使用；那如果我不使用this呢？ 123constructor() &#123;--- Syntax error: missing super() call in constructor&#125; es6会在语法层面强制你调用super()，所以得到的结论就是：只要存在constructor就必须调用super() 二、第二个问题第一个问题已经回答了什么时候调用super()，那什么时候必须要调用super(props)呢？先说结论： 当需要在constructor中访问this.props的情况下 从上面的代码可以看出，即使没有constructor，依然可以在render中使用this.props，这是因为react在初始化class后，会将props自动设置到this中，所以在任何地方都可以直接访问this.props，除了一个地方：constructor 1234constructor(props) &#123; super(); console.log(this.props); --- undefined&#125; 所以当你需要在constructor中访问this.props时，才需要设置super(props) 转自简书带佬","updated":"2019-11-12T04:57:03.496Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"react_02","date":"2019-11-11T10:47:05.000Z","path":"react-02/","text":"7.获取DOM代码根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff 。 组件 MyComponent 的子节点有一个文本输入框，用于用户输入，这时就必须获取真实的DOM节点，虚拟DOM是拿不到用户输入的数据的为了做到这一点，文本输入框必须有一个ref属性，然后this.ref.[refName]就会返回这个真实的DOM节点。 由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。 代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。 12345678910111213141516171819202122232425262728293031323334&lt;div id=\"example\"&gt;&lt;/div&gt;&lt;script type=\"text/babel\"&gt; class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.myTextInput = React.createRef(); this.handleMouseOver = this.handleMouseOver.bind(this) //我这里改成了当鼠标移到元素上和从鼠标上移开，ryf老师是点击元素 this.handleMouseOut = this.handleMouseOut.bind(this) &#125; handleMouseOver() &#123; this.myTextInput.current.focus(); &#125; handleMouseOut()&#123; this.myTextInput.current.blur(); &#125; //上面相当于js部分 //下面相当于虚拟的html render() &#123; return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;this.myTextInput&#125; /&gt; &lt;input type=\"button\" value=\"Focus the text input\" onMouseOver=&#123;this.handleMouseOver&#125; onMouseOut=&#123;this.handleMouseOut&#125; /&gt; &lt;/div&gt; ); &#125; &#125; //通过下面的render由虚拟的变成网页能够显示的html界面 ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById('example') ); 关于constructor()函数可以看我的另一篇文章 关于为什么要用this可以看我的另一篇文章 React 组件支持很多事件，除了 Click 事件以外，还有 KeyDown 、Copy、Scroll 等，完整的事件清单请查看官方文档。 8.this.state 状态改变渲染页面 上面代码是一个LikeButton组件，构造器函数定义 state 状态，这是一个对象，可以通过this.state属性读取，当用户点击组件时，状态改变，this.setState() 方法就修改状态值，每次修改以后，自动调用this.render方法，再次渲染组件。 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。 一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 class LikeButton extends React.Component { // 构造器创建 state constructor(props) { super(props) this.state = {liked: false} // p标签上的 方法 this.handleClick = this.handleClick.bind(this) } handleClick(event) { // state 下的 liked 状态改变 this.setState({ liked: !this.state.liked }); } render() { var text = this.state.liked ? &apos;like&apos; : &apos;haven\\&apos;t liked&apos;; return ( &lt;p onClick={this.handleClick}&gt; You {text} this. Click to toggle. &lt;/p&gt; ); } } ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById(&apos;example&apos;) ); 9.表格this.state描述组件的状态，并通过用户交互进行变异，以及this.props描述组件的属性，并且是稳定的和不可变的。 除此之外，value表单组件的属性(如、和)不受任何用户输入的影响。如果要访问或更新响应用户输入的值，可以使用onChange事件。 class Input extends React.Component { constructor(props) { super(props) this.state = {value: &apos;Hello!&apos;} this.handleChange = this.handleChange.bind(this) } handleChange(event) { this.setState({value: event.target.value}); } render() { var value = this.state.value; return ( &lt;div&gt; &lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt; &lt;p&gt;{value}&lt;/p&gt; &lt;/div&gt; ); } } ReactDOM.render( &lt;Input/&gt;, document.getElementById(&apos;example&apos;) ); 10.组件的生命周期组件的生命周期分为三个状态： Mounting: 一插入真实的DOM Updating: 正在被重新渲染 Unmounting: 以移除真实 DOM React为每一个状态都提供了两种处理函数，will函数在进入状态之前调用，did函数在进入状态之后调用，三种状态共计五种处理函数。 componentWillMount() 组件挂载之前调用，render()之前调用 componentDidMount() DOM渲染完成后调用，可以用于加载后台数据 componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) 组件更新时触发该方法，初始渲染不调用 componentWillUnmount() 组件被销毁之前一般用于清理工作（定时器timer、网络请求、订阅事件） 此外，React 还提供两种特殊状态的处理函数。 1. componentWillReceiveProps(object nextProps) ：已加载组件收到新的参数时调用 2. shouldComponentUpdate(object nextProps, object nextState) ：组件判断是否重新渲染时调用 1234567891011121314151617181920212223242526272829303132class Hello extends React.Component &#123;constructor(props) &#123; super(props) this.state = &#123;opacity: 1.0&#125;;&#125;// 已插入真实 DOM 函数在进入状态之后调用componentDidMount() &#123; this.timer = setInterval(function () &#123; var opacity = this.state.opacity; // 将状态机的变量赋值给 opacity opacity -= .05; //以0.05为单位递减 if (opacity &lt; 0.1) &#123; opacity = 1.0; //重置opacity&#125;this.setState(&#123; opacity: opacity //重新赋值给opacity&#125;); &#125;.bind(this), 100); //定时器对应上面的setInterval&#125; render() &#123; return ( &lt;div style=&#123;&#123;opacity: this.state.opacity&#125;&#125;&gt; Hello &#123;this.props.name&#125; &lt;/div&gt; );&#125;&#125;ReactDOM.render( &lt;Hello name=&quot;world&quot;/&gt;, document.getElementById(&apos;example&apos;)); 如果不使用bind()而直接调用 setInterval 中定义的匿名函数，函数内部的 this 是指向 window 对象的。匿名函数内部显然需要 this 指向当前组件，才能读取state属性/调用setState()方法，所以使用bind()为匿名函数绑定当前执行环境的 this，即当前组件。 为组件添加外部css样式时，类名应该写成className而不是class;添加内部样式时，应该是 style={{opacity: this.state.opacity}}{% end%} 而不是{% raw %} style=\"opacity:{this.state.opacity};\"{% endraw %} 。 bind() this 11.Ajax 如何从服务器或API提供程序获取组件的数据？的事件处理程序中使用ajax获取数据。componentDidMount…当服务器响应到达时，使用this.setState()以触发UI的重新呈现。 class UserGist extends React.Component { constructor(props) { super(props) this.state = { username: &apos;&apos;, lastGistUrl: &apos;&apos; }; } componentDidMount() { $.get(this.props.source, function(result) { var lastGist = result[0]; this.setState({ username: lastGist.owner.login, lastGistUrl: lastGist.html_url }); }.bind(this)); } render() { return ( &lt;div&gt; {this.state.username}&apos;s last gist is &lt;a href={this.state.lastGistUrl}&gt;here&lt;/a&gt;. &lt;/div&gt; ); } } ReactDOM.render( &lt;UserGist source=&quot;https://api.github.com/users/lifei-2019/starred&quot; /&gt;, //看最后看的代码段 document.getElementById(&apos;example&apos;) );github的常用接口api","updated":"2019-11-12T02:44:24.596Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"ClustrMaps|支持生成访客地图的统计工具","date":"2019-11-11T10:27:32.000Z","path":"hexo3/","text":"如上图所示， ClustrMaps 是一个基于网站流量统计与数据分析的站点，其特色是可以按照你的网站访问者国家来分别计数，关键它还能生成一个标有你的访问者地理位置的世界地图，支持嵌入到网站上展示。","updated":"2019-11-11T10:42:00.715Z","link":"","tags":[{"name":"hexo","slug":"hexo","permalink":"https://lifei-2019.github.io/tags/hexo/"}]},{"title":"react_01","date":"2019-11-09T13:12:36.000Z","path":"react-01/","text":"本文主要看阮一峰老师的博客：react入门示例教程 亲测教程中的部分功能在react16后失效（除了python还有不向下兼容的….），欢迎交流，希望大家少走些弯路。 自己学习过程中做的react实例 一、react网页源码1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=\"../build/react.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/react-dom.js\"&gt;&lt;/script&gt; &lt;script src=\"../build/browser.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"example\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; // ** Our code goes here! ** &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1️⃣body可加入script标签，但type属性为text/babel，因为react是JSX，html和css都可以写在js里。 2️⃣用了三个库：react.js、react-dom.js、Browser.js，react.js核心库，react-dom提供DOM(文档对象类型Document Object Moodel)相关，Browser是把JSX转为JS（但消耗时间）。 1$ babel src --out-dir build 把src目录里的js进行转码后放在build目录。 二、ReactDOM.render()把模版转为HTML，插入DOM结点。（关于DOM可先看Java Script DOM编程艺术，讲的很基础） 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example')); ReactDOM.render(参数一, 参数二) 参数一：被渲染的标签 参数二：被插入的父元素 三、JSX语法123456789101112var names = ['Alice', 'Emily', 'Kate'];ReactDOM.render( &lt;div&gt; &#123; names.map(function (name) &#123; \\\\ map函数：遍历数组 ，此处会显示三行 return &lt;div&gt;Hello, &#123;name&#125;!&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById('example')); 在参数一中，{}中可以键入javascript代码，可以用来遍历数组，对象等；在其中可以使用return来返回标签。 JSX 的基本语法规则： 遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析； 遇到代码块（以 { 开头），就用 JavaScript 规则解析。 数组直接写在{}中就能遍历： 12345678910var arr = [&lt;h1&gt;Hello world&lt;/h1&gt;,&lt;h2&gt;React is awesome&lt;/h2&gt;,];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('example') \\\\找到id为example的元素节点); 四、组件React允许用React.createClass方法自己封装组件，然后像插入普通HTML元素节点一样在网页中插入。 12345678910var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;HelloMessage name=\"John\" /&gt;, document.getElementById('example')); 此时，HelloMessage就是一个组件类。 123456789var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt; Hello &#123;this.props.name&#125; &lt;/h1&gt;&lt;p&gt; some text &lt;/p&gt;; &#125;&#125;); 上述代码是错的，因为return了两个元素节点h1和p 组件类的第一个字母必须大写 组件类只能包含一个顶层标签 组件类必须有 / 结尾 所有组件类都必须有自己的 render 方法，用于输出组件 五、this.props.childrenthis.props.children：表示组件的所有子节点。（关于props） 把NotesList下的所有子节点渲染到 ol li中 12345678910111213141516171819202122232425262728&lt;div id=\"example\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; class NotesList extends React.Component &#123; render() &#123; return ( &lt;ol&gt; //有序序列表 &#123; React.Children.map (this.props.children , function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ol&gt; ); &#125; &#125; // this.props.children 表示组件上的子节点 ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;45645&lt;/span&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.getElementById('example') ); &lt;/script&gt; 上面的NoteList组件有三个span子节点 this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。 React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。更多的 React.Children 的方法，请参考官方文档。 6、PropTypes组件类的PropTypes属性，就是用来验证组件实例的属性是否符合要求 指定组件中的属性类型 如下代码验证组件实例属性是否符合要求 123456789var MyTitle = React.createClass(&#123; propTypes: &#123; title: React.PropTypes.string.isRequired, &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125;&#125;); 如下代码设置组件属性的默认值 12345678910111213141516var MyTitle = React.createClass(&#123; getDefaultProps : function () &#123; return &#123; title : 'Hello World' &#125;; &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;MyTitle /&gt;, document.body); React版本16以后不再支持createclass以及其内部的getDefaultProps！要改用下面的.component以及defaultProps方法！ 123456789101112131415161718&lt;div id=\"example\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; var data = 123; class MyTitle extends React.Component &#123; static propTypes = &#123; title: PropTypes.string.isRequired, // title的文本节点必须是字符串 &#125;， render() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125; &#125; ReactDOM.render( &lt;MyTitle title=&#123;data&#125; /&gt; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;, document.getElementById('example') ); &lt;/script&gt; 在浏览器中按F12看到开发者工具里因为默认title值是数字而报错。 加油。","updated":"2019-11-11T10:45:05.051Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"react","slug":"react","permalink":"https://lifei-2019.github.io/tags/react/"}]},{"title":"负能量","date":"2019-11-09T09:00:52.000Z","path":"down/","text":"人生就像玻璃窗上的苍蝇，前途一片光明，却找不到出路。","updated":"2019-11-12T04:56:52.954Z","link":"","tags":[]},{"title":"hexo中插入bilibili视频","date":"2019-11-09T08:38:27.000Z","path":"hexo2/","text":"1.原理使用iframe标签，更改其中src的aid和cid， 使其对应要插入的视频，即可在文章内插入bilibili视频 2.获取cid​ aid即为视频的av号，cid有两种获取方式，一是通过bilibili分享按钮直接可以看到嵌入代码，将代码内的cid复制即可（推荐），二是通过网页源代码查看（之前没有注意到到还能直接从分享按钮里看）。 这里简单介绍一下通过网页源代码看的方法： 右键，查看网页源代码（不能F12，F12看不到cid） ctrl+f 搜索cid，即可找到对应的cid。 3.插入方法使用tinymce编辑器，选择编辑html原代码，插入以下代码即可 12&lt;iframe src=\"//player.bilibili.com/player.html?aid=对应aid&amp;amp;cid=对应cid&amp;amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"95%\" height=\"450\"&gt;&lt;/iframe&gt; 4.示例示例使用《我的英雄学院》。所谓英雄，就是无论何时都能打破困境之人，希望每个人能成为自己的英雄！","updated":"2019-11-09T10:10:26.844Z","link":"","tags":[{"name":"hexo","slug":"hexo","permalink":"https://lifei-2019.github.io/tags/hexo/"}]},{"title":"前端概念","date":"2019-11-08T06:38:15.000Z","path":"前端概念/","text":"昨天看了知乎@陈龙的一篇文章，对前端有了一个系统化的认识。 首先，必须分清六个基本概念：Library，Toolkit，Framework，Design，Boilerplate，Scaffolding。在很多人（包括我）脑子里都只有框架这一个概念，啥都是框架。 Library就是库，而且分为两类。 一类是方法库，用来实现特定需求的一组API集合。最常见的就是jQuery，它是一系列操作DOM和AJAX的API组成的方法库。除了jQuery，还有早期的Prototype，Dojo，Mootools，后面这三个在当时也被称为三大前端工具库。 操作Data的有UnderScore和Lodash，操作Event的有现在流行的RxJS，他们都是Library，在需要的时候，正确调用他们提供的方法就可以。 一类是UI组件库，满足特定业务需要的高可复用的常见UI组件集合。例如Ant Design of React/Ant Design of Angular(NG-ZORRO)，Element UI，LayUI，EasyUI。早期的Yahoo UI，Extjs，jQuery UI。 Bootstrap是一个Toolkit(工具箱)，给你提供创建现代响应式页面所需要的工具，包含一套完整的响应式CSS类库，字体，同时还有一套很完整的UI组件。只是这些组件原生是用jQuery写的，不适用于现在主流的前端。所以产生了很多衍生UI库，例如Angular实现的ng-bootstrap和ngx-bootstrap，React实现的react-bootstrap，Vue实现的bootstrap-vue。 Framework是框架，用来构建一个应用的主体结构。然后你在这个主体结构上添砖加瓦，实现自己的需求。Web服务器端的框架基本实现的都是MVC设计模式，你在Model、View、Controller层分别去添加代码。Web前端，Angular(以及它的前身Angularjs)实现的都是MVP模式，是Model、View、Presenter三层。老一辈的其他前端框架，例如Backbone、Ember，实现的是所谓MVVM。 当前所谓的前端三大框架，只有Angular算作严格意义上的Framework，而且是一个Opinionated Framework，其他两个不算。 Vue官网首页最大的字说： The ProgressiveJavaScript Framework 但是，在Guide页面说： Vue (pronounced /vjuː/, like view) is a progressive framework for building user interfaces.The core library is focused on the view layer only, and is easy to pick up and integrate with other libraries or existing projects. 所以，Vue(法文View的意思)本质上是一个解决View层的Library React官网就没这么遮遮掩掩了，首页最大的字： A JavaScript library for building user interfaces 所以，Vue和React都是关注于View这一层的Library。也正因如此，用React或Vue搭建项目就还需要一系列其他周边库做补充支持。例如React本身没有实现路由导航，就需要react-router。等等，还有很多，俗称全家桶。 Design是设计语言。当说到xxx Design的时候，前端应该经常听到Material Design和Ant Design，分别是Google和阿里的推出的两种前端UI设计语言。 设计语言(或者说设计风格)，是指导UI设计需要遵循的一些约束。这些约束包括：色彩、布局、层次、交互反馈等等。就像我们说建筑，有哥特式的、中国古典式的、希腊式的。买衣服，我们知道韩版、英伦风格、波斯米亚风格。 Design和具体实现是松耦合的，没有直接必然关联。规范只规定这种设计语言的风格是什么样子的，从来不指定具体实现，谁都可以实现。就是Specification和Implementation的关系。就好像中国古典建筑，古时候多用木材，现在用钢筋混凝土一样可以建造出同样的风格。就好像程序员喜欢的格子衫(一种风格)，可以用法兰绒的，也可以棉麻的。 Material Design起初是指导Andoid界面的，但是也存在很多Web UI的实现，例如基于Bootstrap开源的有Bootstrap Material。 Ant Design也是一样。只是最开始只有React的实现Ant Design of React。阿里团队后期发布了Angular的实现Ant Design of Angular(NG-ZORRO)。 Boilerplate是模板、样板的意思。一般程序员很少了解这个概念，而是Library和Framework知道的多一些。上面说过了，当你用React开发的时候，React本身不能满足全部需求，就需要周边辅助的项目。如何把这些全家桶用最佳实践(Best Practice)的方式组合在一起？就需要有人给一个样板，Ant Design Pro就产生了。所以Ant Design是设计语言、Ant Design of React是遵循这门设计语言并且用React实现的UI组件库，Ant Design Pro就是模板。 Scaffolding是脚手架工具。前端的脚手架工具一般都是用cli提供的，cli是(Command Line Interface的缩写)，不是Client的前三个字母。例如ng-cli, create-react-app, vue cli，以及用Yeoman(YO)做出来的许多generator。 脚手架这个词看似陌生，但其实大家都见过。就是建筑工地大楼施工时候外面那一层钢管搭建的架子，还有很多绿色的网起到保护作用。Scaffolding的作用就是辅助你快速搭建项目。但是Scaffolding不是最终成果物的一部分！ 不管用了jQuery也好，用了Vue也好，用了Bootstrap也好，这些东西的代码都会成为你最终编译成果的一部分，而Scaffolding不会。所以大楼建成以后，外面的脚手架是要被拆掉的，不会和大楼一起交付给业主！","updated":"2019-11-09T09:06:56.695Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"}]},{"title":"Stay hungry,Stay foolish.【持续更新】","date":"2019-11-05T01:10:39.000Z","path":"sentences/","text":"《致橡树》我如果爱你——绝不象攀援的凌霄花，借你的高枝炫耀自己；我如果爱你——绝不学痴情的鸟儿，为绿荫重复单调的歌曲；也不止象泉源，常年送来清凉的慰藉；也不止象险峰，增加你的高度，衬托你的威仪。甚至日光。甚至春雨。不，这些都还不够！ 我必须是你近旁的一株木棉，作为树的形象和你站在一起。根，紧握在地下，叶，相触在云里。每一阵风过，我们都互相致意，但没有人，听懂我们的言语。你有你的铜枝铁干，象刀，象剑，也象戟；我有我红硕的花朵，象沉重的叹息，又象英勇的火炬。我们分担寒潮、风雷、霹雳；我们共享雾霭、流岚、虹霓。仿佛永远分离，却又终身相依。这才是伟大的爱情，坚贞就在这里：爱——不仅爱你伟岸的身躯，也爱你坚持的位置，足下的土地。 《春风十里不如你》美国著名摇滚诗人鲍勃·迪伦曾经说过一句话，这个世界上只有两种人，一种是还幸存的，一种是已迷失的，我们的身体虽然被囚禁在这里，可是我们的灵魂永远不会迷失。同学们，请不要再想家了，让我们继续发扬摇滚精神，那些无法将我们消灭的，会使我们变得更加强大 学习时的痛苦是暂时的 未学到的痛苦是终生的。 《海边的卡夫卡》我告诉我喜欢你，并不是一定要和你在一 起，只是希望今后的你，在遭遇人生低谷的时候，不要灰心，至少曾经有人被你的魅力所吸引，曾经是，以后也会是。 《挪威的森林》不要同情自己，同情自己是卑劣懦夫干的勾当。 每个人都有属于自己的一片森林，也许我们从来不曾去过，但它一直在那里，总会在那里。迷失的人迷失了，相逢的人会再相逢。 哪里会有人喜欢孤独，不过是不喜欢失望罢了。 死并非生的对立面，而作为生的一部分永存。 少年时我们追求激情，成熟后却迷恋平庸，在我们寻找，伤害，背离之后，还能一如既往的相信爱情，这是一种勇气。 如果你掉进了黑暗里，你能做的，不过是静心等待，直到你的双眼适应黑暗。 最最喜欢你，像喜欢春天的熊一样。春天的原野里，你一个人正走着，对面走来一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说到：‘你好，小姐，和我一块打滚玩好么？’接着，你就和小熊抱在一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一大天。你说棒不棒？” 喜欢到全世界森林里的老虎都融化成黄油。 我喜欢你，如同全世界的细雨落在全世界的草坪上 不要因为寂寞随便牵手，然后依赖上，人自由自在多好，纵使漂泊，那种经历也好过牢狱般的生活，所以我刻意不让自己对网络太依赖，对失去的人也保持淡然的态度，数千个擦肩而过中，你给谁机会谁就和你有缘分，纵没有甲，也会有乙。 绅士就是：所作的，不是自己想做之事，而是自己应做之事。 饼干罐不是装有各种各样的饼干，喜欢的和不大喜欢的都在里面吗？如果先一个劲儿挑你喜欢的吃，那么剩下的就全是不大喜欢的。每次遇到麻烦我就总这样想：先把这个应付过去，往下就好办了。人生就是饼干罐 People are strange when you are a stranger. 这所大学里的男男女女差不多都是江湖骗子，都怕自己不学无术的真面目被人看穿，惶惶不可终日。于是都看同样的书，喷涂同样的话，都听约翰·科尔特伦，看帕索里尼的电影，还觉得津津有味。 日常生活中有什么用处到谈不上多少，不过我想，与其说具体有什么用处，莫如说它是一种训练，训练我们更加系统的把握事物，就像乌鸦往树洞里贮藏玻璃片一样。 1984人类社会长久以来一直可以分为3个阶层的人，上等人，中等人，下等人。上等人统治社会，中等人管理社会，下等人被控制。上等人推崇的思想无不是稳定，安于受苦，随遇而安。而中等人为了推翻上等人的统治，往往喊出自由、民主的口号，博取下等人的同情。 谁控制了过去，谁就控制了未来；谁控制了现在，谁就控制了过去 “战争即是和平” “自由即是奴役” “无知即是力量” 其他白月光和朱砂痣。从张爱玲的比喻中我想到林徽因和陆小曼，对于徐志摩而言，能够和他在精神层面交流互通的也就是林徽因吧？而在红尘中行走，风流成绝色的陆小曼，是不是更带给他新鲜生动的感觉呢？而这两种往往是不可兼得，只能取其一而已。总有一个要退出，巧的是，在渡边和徐志摩的人生剪影中，留下的都是朱砂痣。 “在德国，起初他们追杀共产主义者，我没有说话──因为我不是共产主义者；接著他们追杀犹太人，我没有说话──因为我不是犹太人； 后来他们追杀工会成员，我没有说话──因为我不是工会成员； 此后他们追杀天主教徒，我没有说话── 因为我是新教教徒；最后他们奔我而来，却再也没有人站起来为我说话了。”这是美国波士顿犹太人屠杀纪念碑上铭刻着的一首短诗，作者是一位叫马丁·尼莫拉(Martin Niemoller)的德国新教牧师。","updated":"2019-11-17T13:30:42.698Z","link":"","tags":[{"name":"读书","slug":"读书","permalink":"https://lifei-2019.github.io/tags/读书/"}]},{"title":"挪威的森林","date":"2019-11-04T08:40:50.000Z","path":"挪威的森林/","text":"连着一周看完《挪威的森林》，心里有许多话想说，但又无从说起。 相比于《海边的卡夫卡》，《挪威的森林》里的故事少了些隐喻，却给我留下了更深的印象，压抑感从最初的“献给许许多多的祭日”开始贯穿全文，读书的魅力莫过于此，人生苦短，22岁的我没有直面死亡的经历，然而书中村上村树用文字叙述了成长或者说活下去必须付出的代价，直击内心深处； 木月死了、直子死了、初美死了、直子的姐姐死了、绿子的父亲死了，用书中的话来说“死并非生的对立面，而作为生的一部分永存”，死会给生者留下只有通过死才能够学到的东西，然而任何哲理都不可能治愈失去所爱之人造成的悲伤，生的人最终只能靠自己从悲哀中解脱出来并砥砺前行。 阅读量的匮乏，加上只读了一遍，实在很难写出很好的书评，这次就站在巨人的肩膀上吧，这篇书评是个人认为比较有深度的，希望自己以后也能写出这样的文章。 以下内容均为转载 日本的许多作家在小说里会表达“徒劳”的主题。 川端康成写的是对抗人生虚无主义本质的徒劳，三岛由纪夫写的是解决人物认识与行为的二律背反的徒劳，大江健三郎写的是试图满足无法被满足的人性欲望的徒劳。 村上春树在《挪威的森林》里写的，是寻求人与人之间相互理解的徒劳。 1 渡边对直子毫无保留的爱，全身心的付出，甚至让她在二十岁那天体会到了前所未有的欲望和高潮，可是，他仍然无法进入她的内心。 直子始终如一地爱着木月，木月死了，她的心就封闭了，不愿意任何人进去她的里面，无论是精神还是身体。她彻底锁住了自己。这把锁，没有人能打开，也屏蔽了理解的机会。 渡边一直不愿意放弃直子。他本身并不是一个顽强的人，但他试图变得顽强；他本身并不算是个很成熟的人，但他为了直子而用力成长。但这一切的努力，都被阻隔在“理解”的鸿沟之外。 虽然直子知道，”死了的人就一直死了，可我们以后还要活下去”，但她仍执着于死去的木月；直子知道她需要“肩膀放松，身体变轻”，但她没有办法做到，因为只要一放松就会土崩瓦解。 自身的“知”和“行”之间尚且存在着巨大的距离，又谈何与他人的理解呢？他人的安慰、体贴、认同，又能对自己产生多大的影响呢？ 这是《挪威的森林》所表达的意义之一——“人，人生，在本质上是孤独的”，相互理解，是“宿命式”的不可能。 2村上春树在很多场合提过他最爱的三个作家：雷蒙德·钱德勒、菲茨杰拉德、雷蒙德·卡佛。 不少人读雷蒙德·卡佛，都感觉云里雾里，不知道卡佛写的那些所谓极简主义的枯燥文字、看似随意截取的生活片断，到底表达了什么。 我读过卡佛的《大教堂》和《当我们谈论爱情时我们在谈论什么》，在我看来，卡佛勾勒的是每个人生命中都可能出现的一种荒凉的、令人感到空落落的大片大片的苍白。这种苍白来不仅来自于无趣的生活，也来自于人与人之间沟通的困境。 《当我们谈论爱情时我们在谈论什么》 在卡佛的作品里，人们在沟通和表达上的缺陷随处可见。我们在阅读时感觉到书中人物的前言不搭后语，或是对话的支离破碎，其实都是真实生活的精确反应——人其实在很多时候都不能明确地表达自己。 当沟通的起点——自己想要表达的内容——都出现问题时，更不用提沟通的其它环节——对方是否能听清、是否愿意听、听了是否能听懂了。 在读《挪威的森林》时，能感觉到村上春树对卡佛的致敬。 渡边和直子无法相互理解，永泽和初美无法相互理解，玲子和外界无法相互理解，即使是敢死队，我们在阅读时大多只会对他报以嘲笑，很少能与他达成理解。 无法理解的原因，可能来自于个人的经历、理念或心态，但起主要作用的，还是沟通和表达。脱离了沟通和表达来追求理解，是纸上谈兵、一厢情愿的尝试。因此，在相互理解的徒劳里，沟通和表达的本质缺陷起到了明显的作用。 书中多次提到这种缺陷，比如说直子，“她无法在诉诸语言之前在心里把握它，惟其如此才无法诉诸语言”，比如说渡边在思考死亡问题时，“诉诸语言之后确很平凡，但当时的我并不是将其作为语言”——可以看出，这种缺陷，既在于内心对于感受的定位误差，也在于语言体系的不完善。 这种缺陷，与口才无关，和尝试的次数无关。这是由沟通和表达的属性和载体所决定的，试图解决的努力是徒劳的。但大多数人并不会意识到这样的努力是徒劳，人们在产生孤独感和疏离感时，仍会本能地寻求与他人的交流，试图以交流获得相互理解，来应对孤独。 不可否认，这种与他人交流的尝试，或多或少会起到一些作用，会让人有机会产生“被理解”的感受，但这样的理解，更偏重于表象，而无法解决根本问题。就好像是被火灼伤后，用凉水浇伤口，碰到水的那一刹那，感受是舒服的，但这种舒服是短暂的，是表面的，真正的伤口，仍然在疼。 这种徒劳的努力，同样表现在书中所描写的年轻一代对性的态度上。泡吧、一夜情，在书中是很普遍的社会现象，很显然，对于性的放纵，同样是人们试图解决孤独感的一种方式—— 既然无法相互理解，就至少让彼此的身体结合在一起吧。但这种尝试同样是失败的，渡边的感受是：“和素不相识的女孩睡觉，睡得再多也是徒劳无益。” 3在牢不可破的徒劳面前，村上春树给出了一种应对的方式： “与其勉强通过与人交往来消灭孤独，化解无奈，莫如退回来把玩孤独，把玩无奈。” 在书里，这是渡边和永泽的态度。永泽说：“我同渡边的相近之处，就在于不希望别人理解自己。这点与其他人不同，那些家伙无不蝇营苟且地设法让周围人理解自己。” 但渡边和永泽选择这种态度的成因是不同的。对渡边来说，他并非不渴望他人的理解，只是在遇到徒劳的迎头痛击时，钻回自己的壳里，喘口气让自己缓一缓。而对永泽来说，他试图以执拗的姿态彰显自己对抗孤独的勇气，用激烈的态度向徒劳发起正面挑战，即使伤害自己身边最亲最爱的人也在所不惜。 从结果来看，以否定问题本身来解决问题，并没有起到解决问题的作用。渡边仍在孤独的泥沼中气喘吁吁，永泽同样在孤寂的道路上找不到归宿。 村上春树给出的真正的答案，是绿子。 图片来自于网络 绿子的形象，类似于《雪国》里的叶子、《围城》里的唐晓芙、《罪与罚》里的索尼娅，他们是重重黑暗里的一丝光亮，是对抗徒劳和虚无的勇气来源。 绿子给渡边的感觉，和直子截然不同。绿子是立体的，是行走的、呼吸的、跳动的，她的一举一动都在让渡边感受到触动。 绿子的经历，其实并没有比直子和玲子好太多。她同样无依无靠。但在孤独里，她选择的是与她们截然不同的态度。她选择接受现实，选择追逐生活里的一个个看似微不足道的小目标，或者说得更简单些，她选择的是——活下去。 “我们是在活着，我们必须考虑的事只能是如何活下去。”——这是渡边在书的尾声处的想法。这个想法从模糊到清晰的转变，关键在于绿子。 4在《挪威的森林》里，村上春树把致敬同样献给了他的另一位偶像——菲茨杰拉德。 《了不起的盖茨比》，高居20世纪百部最佳英文小说排行榜第二名。小说和电影里，都有一个令人印象深刻的场景——盖茨比整夜整夜凝望着对岸的灯光，也就是黛西家码头的灯光。这束灯光，是整部小说的灵魂，有着丰富的隐喻和意向。 《挪威的森林》里有类似的光亮。 “我静止不动地呆呆凝视着那微小的光亮。那光亮使我联想到犹如风中残烛的灵魂的最后忽闪。我真想用两手把那光严严实实地遮住，守护它。我久久地注视着那若明若暗摇曳不定的灯光，就像盖茨比整夜整夜看守对岸的小光点一样。” 这束光亮，是渡边的寄托和追求，是他灵魂的方向，是他希望用生命为之守护的珍宝，也是他可望而不可及的遗憾。 在书中的大部分篇幅里，村上都让渡边和读者们以为，这束光亮，是渡边的最爱——直子。 直到全书的最后一句，当渡边在“哪里也不是的场所的正中央，不断地呼唤着绿子”时，我才意识到，这束光亮，是绿子。 虽然村上春树没有在书中提到这束光的颜色，但我们都知道，在《了不起的盖茨比》里，这束光，是绿色的。 图片来自于网络 绿光，绿子，或许这并不只是个巧合。 再想得更深一点，这束绿光，是幸福的终点吗？ 村上春树选择了开放式的结尾，没有给出答案。但答案是显而易见的，这束绿光并没有给盖茨比带来幸福的终点。在《了不起的盖茨比》的结尾，菲茨杰拉德写下了脍炙人口的一段话： “So we beat on, boats against the current, borne back ceaselessly into the past.” “我们继续奋力向前划，逆水行舟，不停地倒退，回到往昔。” 盖茨比相信的那盏绿灯，那个年复一年渐行渐远的令人沉醉的未来，为何努力向这个目标奋进的我们，是在“逆水行舟”，会“不停地倒退，回到往昔”呢？ 回到《挪威的森林》里来，绿子带来的这束光亮，是否也会让渡边陷入同样的境地？ 这才是这本小说最值得玩味的地方。","updated":"2019-11-04T11:50:10.739Z","link":"","tags":[{"name":"读书","slug":"读书","permalink":"https://lifei-2019.github.io/tags/读书/"}]},{"title":"亦是此间少年","date":"2019-11-01T13:01:42.000Z","path":"亦是此间少年/","text":"最开始做这个博客，一方面是因为考上计算机研究生，总得有点拿的出手的专业性的东西，另一方面自己的语文一直处于不及格的水平（让大家见笑了），就想着一点点写些东西，勤能补拙嘛 话有点扯远了，距离上次已经一周多没更新了，老实说，从开学到最近发生了不少事，家里、高中同学、舍友、教研室、图书馆遇见的种种….研究生的生活过得没有想象中那么好，但是，毕竟，那些使我们痛苦的，往往使我们进步。 研究生大体上分为两种（对于普通研究生来说），一种是老师带着看论文、做项目、打比赛的，一种是老师放任个人发展的，前者又分真正帮学生发展亦或是压榨的，其实从我个人看来，被压榨有时候也是一种幸福，代表着你有被压榨的资本（马总说的嘛，不是所有人都可以九九六的~）； 我属于后者，这或许也是我在此时有空写博客的原因吧，其实说到“放养”，我相信大多数同龄人的反应是“我要是能自己学，我花钱来上学干吗？”，这句话在整个本科阶段听了无数次，甚至越听越有道理，工作日每天早八点到晚五点，再加上周末节假日的补课，老师陪伴孩子的时间甚至比家长的时间都要多，要是不能让我学会东西，那一定是你老师的问题，大多数人往往碌碌无为平庸一生也皆因如此。（没有攻击任何人的意思，自己也长期处于此状态）只是，“放养”，真的是老师的错吗？ 其实不然，上研究生以来，遇到的牛人许多，学习氛围也很浓厚，大家都铆着一股劲，研一发论文，研二找实习，研三找工作，这是历任师兄师姐传下来的，刚开学那会，看着身边有人看老师发的论文，有人，有人参加比赛，有人跟着老师到处跑做项目，自己吧，本科就整了个著作权，Java web、linux学的都是个半吊子，要啥论文没有，要实习经历没有，要比赛经历也没有【打字的手微微颤抖 学！大数据？得学！java？得学！linux？得学！python？得学！cv？得学！不懂机器学习考什么研？得学！论文？得看！ 直到有天看到张有意思的图 当时也没注意，看的时候觉得不过又一碗鸡汤，晚上看GAN模型的时候，概率论基础实在太差，脑阔痛的时候想起来，划拉了几笔，开始神游：想到投名状里庞青云的一句话“我这一生，如履薄冰，你说，我能走到对岸吗？”，路选错了，走到对岸，等待他的，只是另一种死亡罢了。到对岸的方法有许多种，飞过去、走过去、甚至游过去，可彼岸那边是什么？中考、高考、研究生入学考试，我们都在努力，再往后，找到好工作，成家，一切都顺理成章。 可 再往后呢？ 十年？二十年？三十年？四十年？五十年？ 我从不排斥中国的教育体制，过去的二十年，人口基数摆在这里，为了公平，必须要有选拔制度的存在，我们努力的目标就是升学，只是在这二十二岁的年纪，要让一个一直在框架里成长的少年去自己书写以后的人生，他有拿黑色圆珠笔的力气，却无从下手，他的思想已经被体制“矫正“到正确的、拥挤的道路上，甚至不敢去碰水彩笔，去碰那雪白的纸面。 老实来说，到现在，自己虽然也没有像《致青春》里陈孝正盖一栋完美大楼的蓝图，但是总算由落笔的勇气。 借用最近读的《挪威的森林》里的一句话：学到的东西与其说具体有什么具体用处，莫如说它是一种训练，训练我们更加系统的把握事物；而要在某种程度上掌握系统考虑事物的方法，就要像乌鸦往树洞里贮存玻璃片一样。 感谢每个读到这里的人，愿你不辜负自己，亦是此间少年。 写于2019-11-1","updated":"2019-11-04T11:43:34.957Z","link":"","tags":[]},{"title":"新世界的大门【持续更新】","date":"2019-10-21T01:52:59.000Z","path":"treasure/","text":"自己日常搜集的一些软件和网站，希望能帮到大家。 图标下载easyicon(动漫卡通图标较多) font awesome（各大软件平台图标较多） 比特虫（制作icon图标） emoji（emoji表情下载） 热门JavaScript下载bootcsn（五花八门啥都有） 3D JS alteredqualia（有的有些猎奇） 编程相关软件Sublime Text3（编辑器 安装完插件如有神助 配置过程见我的SublimeText3插件安装） Typora（写博客，写知乎必备神器，MarkDown进阶版 配置过程见 Typora入门 ） Git Bash（同步GitHub必备） Notepad++（超轻量级编辑器 没有写代码提醒 但是用起来真的快） Navicat（连数据库的 非常好用 正版要购买） 论文相关Arxiv（学计算机的都懂） paper with code（论文附代码 机器学习的福音 配合arxiv使用更佳） Sci论文下载（Sci里找到标题来这下载 美滋滋） 谷粉学术（舍友推荐） 壁纸下载WallPaper AByss（无意间找着的，还挺好用） 编程教学廖雪峰老师的网站（看过Git和Python 都很不错） 力扣（神仙打架） 在线正则表达式 网站视频下载JiJiDown（B站视频下载！敲有用！） 优酷、爱奇艺等（有的会失效，可以试试） 二维码生成草料二维码（微信、网站等生成二维码） 在线 PS改图宝（证件照、修图应有尽有） Screen to gif因为写博客经常需要录制屏幕并制作gif图，下载后使用极佳，强推！“小而实用”，大小仅2M多（压缩后才几百K），但录制调帧导出一条龙。（网上资源一抓一大把就不放下载链接了） 会员优惠购迅雷、B站等会员优惠购（低至3元/月）（经济条件允许的话还是支持正版！） 远程控制软件 teamviewer（用过的都说好，算是远程控制电脑软件里不错的！） 各种网站 2uts和Oeasy,会玩才会学 国外视频教学网站，完全免费 （3d动画、游戏开发、视觉、音频 哪个男孩能不爱呢） 个人建的教学网站，完全免费，无广告，讲的也很良心，覆盖面很广（亲测好用，一顿爆吹就完事了！） 方方格子 Excel的综合练习，分为两个板块：Excel插件和工具箱+Excel学习教程（屯着以后学） Fugue 免费背景音乐的素材库，大部分是纯音乐，适合添加视屏背景音（等我学做视频再说哈哈哈哈） Wikihow 歪果仁建的How to ____ 网站，为各行各业解决问题（可我们有百度有知乎啊） 仿知网 模仿知网的一个平台，前期免费，收费1元/天，也可以换个邮箱注册（hai，提到论文就头疼，防止以后在外下论文） 即书keysuper 号称30秒选模版、1小时完工的ppt制作神器（咱也没用过，咱也不敢夸，咱也不敢喷） ProcessOn Web端的万能绘图工具，UML、StarUML都能画，只有你想不到，没有它办不到，甚至包括思维导图和简单UI设计，免费版可保存9张图，支持各种格式的导出。","updated":"2020-09-16T01:51:54.449Z","link":"","tags":[{"name":"新世界","slug":"新世界","permalink":"https://lifei-2019.github.io/tags/新世界/"}]},{"title":"人类群星闪耀时","date":"2019-10-17T12:36:03.000Z","path":"人类群星闪耀时/","text":"翻看全书，所有的故事大致可分为两类：第一类是从无到有，《不朽的逃亡者》、《亨德尔的复活》、《一夜天才》、《玛丽恩浴场里的哀歌》、《跨越大洋的第一句话》等等，这些故事的主人公为了探索世界，追求自己的理想，都付出了艰难的努力。这些创造文明的人经历了病痛、贫病、失恋等等痛苦，甚至有人还被全世界认为是骗子，可是他们坚韧不拔，没有背叛心中的理想与信念，最终幻化成人类星空中闪亮的一瞬。 相比创造，毁灭则容易的多，这就是全书第二类故事，比如《拜占庭的陷落》、《滑铁卢决定胜负的一瞬》、《壮丽的瞬间》、《黄金国的发现》等等，也许一秒钟的迟疑就能毁灭一个英雄、一个小时所发生的事足以毁灭千年的文明。与创造相比，毁灭简直是太容易了，容易到只需要一瞬。这些瞬间在星空中闪亮一下，就重归黑暗了。 说几个我印象比较深刻的 《不朽的逃亡者》描述的是1513年太平洋的发现。在哥伦布第一次发现美洲大陆归来后，由贪欲引发的黄金国之梦一度让许多人为之痴迷，最终落得破产的后果；努涅斯•巴尔博亚就是其中一名，但他精明在能够抓住生存的每一丝希望，在违抗西班牙国王的旨意后，他清楚地知道要么惨死在断头台上，要么为祖国占有尚未发现的海洋，逃遁到不朽的事业中去。他成功了，但是不久便死在妒忌它成就的心腹手里。 在《滑铁卢决定胜负的一瞬》里，法军元帅格鲁希因为在短短一秒钟内错判的形势，没有及时支援拿破仑，错失了良机，导致滑铁卢战役的失败。滑铁卢的失败让英雄拿破仑跌落凡尘，而毁灭英雄的正是一个庸人格鲁希。虽然格鲁希后来在每个职位上都表现出色，但他一生也不能弥补在滑铁卢所犯的错。茨威格在这篇文章里认为格鲁希是个庸人、畏首畏尾的人，作者慨叹：“命运鄙视地把畏首畏尾的人拒之门外。命运——这世上的另一位神灵，只愿意用热烈的双臂把勇敢者高高举起，送上英雄们的天堂。” 《拜占庭的陷落》里，奥斯曼帝国的苏丹穆罕默德二世攻占拜占庭，拜占庭得不到欧洲的援军帮助，但积极备战。最后仅仅因为一扇凯卡波尔塔小门没关，土耳其军队顺利进入君士坦丁堡，千年帝国拜占庭从此陷落了。城内百姓被劫掠了三天三夜，拜占庭帝国的文明也被毁灭。作者惋惜、感叹：“历史犹如人生，业已失去的瞬间，不会因为抱撼的心情而重返，仅仅一个小时所贻误的东西，用千年的时光也难以赎回。” 《亨德尔的复活》章节，亨德尔在半身瘫痪之后，以坚强的意志积极恢复身体，终于在几个月的温泉治疗之后重新站了起来，创造了奇迹。身体恢复之后，他不知疲倦的创作，至清唱剧《弥赛亚》创作完成之后，他将没睡的觉和没吃的饭都补了回来。《弥赛亚》是一部伟大的作品，亨德尔更是一位伟大的音乐家，伟大的音乐家创造伟大的乐曲，其中的过程是艰难的、忘我的，甚至是经历着病痛的折磨，克服一切的办法只有顽强的意志力。 《向上帝逃亡》，在我看来是作者通过剧本的形式，对战争进行了一番辩论，从托尔斯泰的口中说出暴力革命只会让强权变成另一个强权、压迫变成另一种压迫这样的观点。最后，托尔斯泰在人生的最后一刻摆脱了命运，从伯爵蜕变成了普通人，逝世于站长那寒酸的、不成样子的床上。 读完整本书，似乎有些理解在译序茨威格的反战思想——虽然有些战争是正义的，可它们同样都会带来毁灭。那么多伟大的人呕心沥血的创造了我们的文明，却要因为一场战争、在一瞬间被毁灭，而那些本该闪耀在我们人类星空上的人，却因为一瞬间的失误而遗失在历史的长河中。这一瞬间就成了永恒，即使用千年的时光也难以赎回。 同时，茨威格的死亡在那个时代似乎也是必然的。在遭到纳粹驱逐八年后，第二次世界大战发生后三年，1942年2月23日，他选择服毒自杀，遗书中说：“我的母语世界已经沉沦，我的精神家园，欧洲，已经自我毁灭。（the world my own language having disappeared from me and my spiritual home,Europe,having destroyed itself.）”一个人，精神故乡由于自己的祖国而分崩离析，导致自己浪迹天涯、无家可归，那还不如及时的不失尊严的结束自己的生命为好。 PS: 自己收藏的一些常识，与君共享。 哈利路亚：犹太教和基督教的欢呼语，意思赞美上帝 ==西俗：在主显节，一月六日耶稣出现的日子，得到馅中有豆的人称为豆王== 耐基 希腊神话里的胜利女神 ==萨梯儿 希腊神话里的林神：醉鬼或色鬼同义词== 六翼天使：《圣经》里最高阶天使。 巴别塔：《圣经》里未建成的通天塔 ==祖特尔在加利福利亚发现“黄金国”== 1837年电报机第一次使用 居鲁士•弗•菲尔德 跨洋通信 ==挪威阿蒙森发现南极 第二个英国斯科特== 赫克托 希腊神话特洛伊战争的英雄 安德洛马赫 赫克托的妻子，美貌钟爱丈夫 ==美国记者约翰•里德目睹十月革命，著有《震撼世界的十天》== 当强烈的个人意志与历史宿命碰撞之际，犹如耀眼的星光在夜空中闪现，那样的时刻足以照亮人类文明的天空。","updated":"2019-11-03T07:01:03.708Z","link":"","tags":[{"name":"读书","slug":"读书","permalink":"https://lifei-2019.github.io/tags/读书/"}]},{"title":"真相捕捉【含剧透】","date":"2019-10-15T02:36:33.000Z","path":"真相捕捉/","text":"在bilibili上偶然看到@蔡老板家的长工解说英剧《真相捕捉》，看了几分钟深知这部剧值得看原剧，自此一发不可收拾，两天追完了。（PS：感觉最近的英剧都不错） BBC 的这部六集迷你剧《真相捕捉》（The Capture）是一个由虚假视频引出的故事。豆瓣评分：9.1 以下内容含剧透！！！！ 剧情反转较多。概括的来说，真相捕捉说的是几个律师和英帝、美帝用一个小士兵当牺牲品，互相较量。故事的背景是美帝、英帝利用修改监控画面来逮捕恐怖分子，而几个律师认为这种行为有碍司法公正。于是律师们自导自演了一出修改监控画面，构陷一名士兵绑架，意图在案件进入司法程序后放出原本视频，证明监控是可以被修改的。希望以此来推翻美帝和英帝此前利用伪造监控进行的不公正审判。 首先谈谈剧中的AI换脸技术。早在2017年底，国外论坛就出现了通过计算机学习来更换视频中人脸的AI算法，那个时候，AI算法的使用门槛还很高，需要编译代码和高性能的显卡做信息的运算处理。 2019年8月，”ZAO”APP的出现，再次让AI换脸，火遍了大街小巷。人们只需上传一张照片，运用APP自带的AI换脸功能，就可以将短视频中的演员的脸换成自己的脸。 相比之前高门槛的AI编程算法，“ZAO”把AI换脸的视频制作运算放到了服务器上，用户不再需要高性能的手机配置，用户体验效果极其良好。 因AI换脸“出演”《射雕英雄传》的杨幂 ==换脸技术已经不再是科幻小说中的桥段，而是真实存在的事实。== 再来谈谈司法。百度百科上对于第一手材料的定义是—— 从亲身实践或调查中直接获得的材料； 第一手材料是直接的证据，是未经过任何修饰的信息 ,意思是最原始，未经改动的 ，通常也比喻最真实的信息。 未来，实时监控录像、视频录像是否可以作为第一手材料，对于司法部门来说是个巨大的槛。人们对于常识的局限性，也影响着人们的判断。 技术的爆炸发展，不仅让监控视频成为了铁证，同时也让我们步入了「后真相时代」。如果，铁证也有被篡改的一天，我们究竟还能相信什么呢？ 「后真相」一词是用来形容一种不正常的舆论生态，主要指媒体传播起到的是煽动情感、强化偏见的作用，其所产生的影响超过了客观事实对人们的影响，人们只在意情绪或主张，而不管事实和道理。 于我个人而言看完这部剧，印象最深刻的是第五集结尾处瑞秋的上司由于某些原因告诉瑞秋所有的真相后，事情的难题变为我们应该为了保护两千人而把有潜在犯罪危险的人陷害入狱还是还未犯罪的人一个清白然后向上帝祈祷他的犯罪危险只是潜在的？ 911以后《爱国者法案》被推行，“在国家遭遇威胁时，执法部门总是借机以「国家安全」为名，扩大部门权力…政府掌握任意性权力隐含巨大威胁，因为它既可以用来打击恐怖主义，也可以被用来镇压不同意见者”（王希《原则与妥协——美国宪法的精神与实践》）。 说的明白些，便是国家安全与个人权利谁更重要？ 更新于10/15 看完有些影评，发现自己思想的深度还是不够。 如果只从上述角度来看这部剧，似乎有些浅显。除了美帝、英帝的霸道行为，这部剧的另一叙事主题就是那些律师们。通过修改监控实时画面，构陷无辜者入狱来达成自己的目的。不论律师们如何弘扬自己的目的多么高尚，也无法掩盖这种行为的卑劣。 有计划性的通过特定案件来冲击现有体系，希望借此来改变社会。这部剧里的行为，美帝早在50/60年代甚至更早以前就已经不是新鲜事了。甚至联邦最高法院的大法官瑟古特·马歇尔早年就是职业干这行的，他们组成团体将热点种族案件带入各州和联邦法院，利用十四修正案挑战现有种族歧视与隔离政策。 当然不能否认这些人的“宏大目标”的正面意义，不然今天的美帝大概也没法宣传自己的“普世价值”了。 我只是很好奇，瑟古特·马歇尔这样的律师和《真相捕捉》里的这批律师有什么区别呢？从目的来看，二者都是为了宏大理想社会公正，匡正司法体系而奋斗。微观来说，二者出发点又都是被一个个个体遭遇的不公正触动。那么问题到底出在哪里呢？ 作为一个理想主义者，我有时会拷问自己，“理想”要实现付出的代价是什么？你又是否有权力让别人为了自己的理想而付出代价？答案当然是不唯一的。秦晖老师很多年前有篇文章讲我们的左派和右派都在讨论假问题，说的很在理，虽然他说的左右和大多数人理解的左右不是一回事。秦文章里有个观点，他觉得极左与极右看似极端对立，实际上只是一步之遥。我的理解里，左派右派讲的大多时候关注的是right的问题，而极左极右则扩展到了power上去。 作为个体的人，当然是没有资格要求他人为自己的理想而牺牲的，不论这个理想多么的“正确”。尊重他人的自由和自由的选择，应该算是一种常识（当然这个常识未必人人能懂）。但是有自己的理想蓝图并有power为之护航时，情况就大不相同了。 英剧里的律师当然是没有power的，但是他所追逐的理想，在实现过程里必然要依傍现有体系，并通过体系来实现自己的理想。这一过程里，如果缺乏对个体生命和自由的尊重，漠视个体的人的利益，铁定要走到自己理想的对立面上去。 所以，日常生活中当我碰到那些有宏大理想口若悬河的人，大概率是要离他们远一点的。倒不是怀疑他们实现理想的能力，只是害怕他们的理想未来里没有我。 深秋已过，凛冬将至，看个《真相捕捉》，雪上加霜吧。","updated":"2019-11-11T10:32:17.292Z","link":"","tags":[{"name":"英剧","slug":"英剧","permalink":"https://lifei-2019.github.io/tags/英剧/"}]},{"title":"python小技巧","date":"2019-10-15T00:49:07.000Z","path":"python小技巧/","text":"1. 反转字符串采用切片操作实现字符串的反转： 1234567# Reversing a string using slicingmy_string = \"ABCDE\"reversed_string = my_string[::-1]print(reversed_string)# Output# EDCBA 2. 实现首字母大写这个小技巧是让字符串中每个单词的首字母变为大写，通过方法 title() 实现： 123456my_string = \"my name is chaitanya baweja\"# using the title() function of string classnew_string = my_string.title()print(new_string)# Output# My Name Is Chaitanya Baweja 3. 查找字符串中唯一元素这个技巧是查找字符串中不重复的元素有哪些，通过集合 set 来实现： 123456789my_string = \"aavvccccddddeee\"# converting the string to a settemp_set = set(my_string)# stitching set into a string using joinnew_string = ''.join(temp_set)print(new_string) 4. 打印 n 次字符串或者列表这个技巧通过乘法即可实现打印多次的操作： 123456789n = 3 # number of repetitionsmy_string = \"abcd\"my_list = [1,2,3]print(my_string*n)# abcdabcdabcdprint(my_list*n)# [1,2,3,1,2,3,1,2,3] 这个技巧比较有趣的应用是定义一个包含 n 个重复的常数元素的列表，如下所示： 123n = 4my_list = [0]*n # [0, 0, 0, 0] 5. 列表推导式列表推导式是一种非常优雅的基于其他列表来创建新列表的方法，示例如下所示： 123456original_list = [1,2,3,4]new_list = [2*x for x inoriginal_list]print(new_list)# [2,4,6,8] 6. 交换两个变量Python 中交换两个变量的数值是非常简单的，完全不需要第三个变量作为中间值。示例如下所示： 12345a = 1b = 2a, b = b, aprint(a) # 2print(b) # 1 7. 字符串分割为一串子字符串列表采用 split() 方法可以将字符串分割为一个包含其子字符串的列表，示例如下所示： 12345678910string_1 = \"My name is Chaitanya Baweja\"string_2 = \"sample/ string 2\"# 默认分割符 ' 'print(string_1.split())# ['My', 'name', 'is', 'Chaitanya', 'Baweja']# 自定义分割符 '/'print(string_2.split('/'))# ['sample', ' string 2'] 8. 合并多个字符串为一个字符串采用 join() 方法可以将多个字符串合并为一个字符串。这相当于上一条技巧的反向操作。示例如下所示： 123456list_of_strings = ['My', 'name', 'is', 'Chaitanya', 'Baweja']# Using join with the comma separatorprint(','.join(list_of_strings))# Output# My,name,is,Chaitanya,Baweja 9. 判断字符串是否回文通过反转字符串，再和原字符串比较，可以判断是否为回文，示例如下： 1234567my_string = \"abcba\"if my_string == my_string[::-1]: print(\"palindrome\")else: print(\"not palindrome\")# Output# palindrome 10. 统计列表元素的个数有多种方式可以实现这个技巧，但我最喜欢的是采用 Counter 类。 Counter 可以统计给定列表中每个元素的个数，返回一个字典格式。示例如下，其中most_common()方法可以返回列表中数量最多的元素 1234567891011121314# finding frequency of each element in a listfrom collections import Countermy_list = ['a','a','b','b','b','c','d','d','d','d','d']count = Counter(my_list) # defining a counter objectprint(count) # Of all elements# Counter(&#123;'d': 5, 'b': 3, 'a': 2, 'c': 1&#125;)print(count['b']) # of individual element# 3print(count.most_common(1)) # most frequent element# [('d', 5)] 11. 判断两个字符串是否是字谜(Anagrams)字谜(Anagrams)是指将一个单词打乱其字母顺序，重新排列为一个新的单词。 Counter正好可以用于解决这个问题，因为如果两个字符串的 Counter 对象相等，就表示它们就是字谜，因为包含相同元素且元素数量都相同。 示例如下： 1234567from collections import Counterstr_1, str_2, str_3 = \"acbde\", \"abced\", \"abcda\"cnt_1, cnt_2, cnt_3 = Counter(str_1), Counter(str_2), Counter(str_3)if cnt_1 == cnt_2: print('1 and 2 anagram')if cnt_1 == cnt_3: print('1 and 3 anagram') 12. 采用 try-except-else 语句Python 中处理错误异常可以简单采用 try-except 语句，而再添加一个 else 语句会更加有帮助，它是在没有发生异常时，执行完 try 语句后运行的语句。 此外，如果需要运行是否发现异常的都需要执行的代码，可以采用 finally ，示例如下： 12345678910a, b = 1,0try: print(a/b) # exception raised when b is 0except ZeroDivisionError: print(\"division by zero\")else: print(\"no exceptions raised\")finally: print(\"Run this always\") 13. 采用 Enumerate 来获取索引值在迭代列表的时候，可以采用 enumerate 来得到索引值，示例如下： 12345678my_list = ['a', 'b', 'c', 'd', 'e']for index, value in enumerate(my_list): print('&#123;0&#125;: &#123;1&#125;'.format(index, value))# 0: a# 1: b# 2: c# 3: d# 4: e 注意，这里还可以指定索引开始的范围，只需要在调用 enumerate() 时候，添加一个参数，如下所示： 123my_list = ['a', 'b', 'c', 'd', 'e']for index, value in enumerate(my_list, 1): print('&#123;0&#125;: &#123;1&#125;'.format(index, value)) 14. 检查一个对象的内存使用量可以采用 sys.getsizeof() 检查，示例如下： 12345678import sysnum = 21print(sys.getsizeof(num))# In Python 2, 24# In Python 3, 28 15. 合并两个字典在 Python2 版本的时候可以采用 update() 方法实现合并字典的操作，但在 Python3.5 后的版本，可以采用新的方式实现，操作更加简单，如下所示： 12345678dict_1 = &#123;'apple': 9, 'banana': 6&#125;dict_2 = &#123;'banana': 4, 'orange': 8&#125;combined_dict = &#123;**dict_1, **dict_2&#125;print(combined_dict)# Output# &#123;'apple': 9, 'banana': 4, 'orange': 8&#125; 16. 计算代码执行时间采用 time 模块来计算一段代码的执行时间，例子如下： 1234567891011import timestart_time = time.time()# Code to check followsa, b = 1,2c = a+ b# Code to check endsend_time = time.time()time_taken_in_micro = (end_time- start_time)*(10**6)print(\" Time taken in micro_seconds: &#123;0&#125; ms\").format(time_taken_in_micro) 17. 展平元素为列表的列表有时候并确定一个列表中的深度有多深，所以你只想简单的将所有元素都放在一个列表中，实现技巧代码如下所示： 123456789101112131415from iteration_utilities import deepflatten# 列表只有一层深度的情况，采用这个函数def flatten(l): return [item for sublist in l for item in sublist]l = [[1,2,3],[3]]print(flatten(l))# [1, 2, 3, 3]# 不知道列表的深度的情况l = [[1,2,3],[4,[5],[6,7]],[8,[9,[10]]]]print(list(deepflatten(l, depth=3)))# [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 如果是数组的话，可以采用 Numpy 方式。 18. 从列表中采样采用 random 模块可以对一个列表随机采样 n 个元素，示例如下所示： 1234567import randommy_list = ['a', 'b', 'c', 'd', 'e']num_samples = 2samples =random.sample(my_list,num_samples)print(samples)# [ 'a', 'e'] this will haveany 2 random values 另外，在 Python 3 中推荐采用 secrets 模块，基于密码学的目的来随机生成样本，示例如下： 12345678910import secrets # imports secure module.secure_random = secrets.SystemRandom() # creates a secure random object.my_list = ['a','b','c','d','e']num_samples = 2samples = secure_random.sample(my_list, num_samples)print(samples)# [ 'e', 'd'] this will have any 2 random values 19. 数字化下面是一个例子，将一个数字转换为一个数字列表的形式： 123456num = 123456list_of_digits = list(map(int, str(num)))print(list_of_digits)# [1, 2, 3, 4, 5, 6] 20. 检查唯一性下面的代码是用于判断一个列表的所有元素是否都是唯一没有重复的： 1234567def unique(l): if len(l)==len(set(l)): print(\"All elements are unique\") else: print(\"List has duplicates\")unique([1,2,3,4])#Allelementsareuniqueunique([1,1,2,3])# List has duplicates","updated":"2019-11-03T07:03:24.865Z","link":"","tags":[{"name":"python","slug":"python","permalink":"https://lifei-2019.github.io/tags/python/"}]},{"title":"SublimeText3插件安装","date":"2019-10-12T05:57:47.000Z","path":"SublimeText3插件安装/","text":"一、下载安装sublime Text3​ 到官网下载安装包（根据你的电脑系统下载对应的version）： ​ 下载好st3后，然后不断的点击next，然后blablabla……就可以安装好了。 二、汉化sbulime Text3（看个人需要）2.1下载汉化安装包 ​ 地址：链接: https://pan.baidu.com/s/1y0c_SJdFMea-tWWruO5YmQ 提取码: rprd 2.2安装汉化包(将汉化包拷到 Installed Packages 文件夹中) ​ 进入：D:\\Sublime Text3\\Data\\Installed Packages（根据你的安装目录去寻找Installed Packages，本文是安装在D盘），将刚刚下载的汉化包解压，得到的文件Default.sublime-package 拷贝到 Installed Packages 文件夹中，这个时候就会发现汉化成功啦！ 三、安装Package Control（重要）​ 关系到很多插件的安装，非常重要！ 3.1 通过工具栏面板 ​ ①点击工具栏的“view”-&gt;”show console”(快捷键 是”ctrl+`”)， ​ ②到https://packagecontrol.io/installation官网，将对应的代码拷贝到显示面板中，然后回车。如果安装成功，那么就显示Package Settings 和Package Control 这两个项。 sublime 3： 1import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) ​ 如果没有安装成功，那么建议用手动安装 3.2通过手动安装 ​ 到https://packagecontrol.io/installation官网，右边有一个“Package Control.sublime-package”，点击下载，然后将文件拷贝到 Installed Packages文件夹中 四、安装st3常用的插件​ 对于sublime text3,它之所以轻巧，是因为它设计就是为了让你按需加载，根据自己的需要，去下载对应的插件，所以才不会像其他的IDE那样笨重。（虽然我当时整了半小时【微笑） ​ 安装插件步骤是：“Preferences -&gt; Package Control”(快捷键是：shift+ctrl+p),然后执行“Package Control: Install Package”,接在就是输入你要安装的插件就可以，下面就说一下你个人常用的插件： 1、ChineseLocalizations 汉化插件 —— 可进行语言切换 2、Emmet（原名 Zen Coding） ——- 可快速编写代码 例如：输入“!”或“html:5”，然后按Tab键，就会将html5基本标签显示出来，其他还有很多快捷方式，想了解的可以去查阅一下Emmet 3、BracketHighlighter ——– 类似于代码匹配，可以匹配括号，引号等符号内的范围 4、cssrem ——- 自动将CSS的px值转rem值 在wepapp开发时,使用rem进行移动端适配的时候，非常好用，省下很多计算的时间。 5、Alignment ——- 自动对齐代码，包括PHP、CSS、JavaScript语言。使得代码看起来更整齐美观，更具可读性 默认快捷键为ctrl + alt + a,如果跟某IM截图的快捷键冲突，可在Preferences-&gt;Package Settings-&gt;Alignment-&gt;Key Bindings - User中自定义快捷键，写法参照Key Bindings - Default 6、Css Format —– css格式化 很快捷的将css的格式进行切换，Expand（标准格式化），Compact（css一行行显示），Compressed（css压缩成一行） 7、DocBlockr —— 观察函数需要的变量名和类型，并创建文档块，只要在函数的上面输入/**，按Tab就可以了 8、SublimeCodeIntel ——- 一个全功能的 Sublime Text 代码自动完成引擎 支持的语言挺多的（JavaScript, Mason, XBL, XUL, RHTML, SCSS, Python, HTML, Ruby, Python3, XML, Sass, XSLT, Django, HTML5, Perl, CSS, Twig, Less, Smarty, Node.js, Tcl, TemplateToolkit, PHP.） 9、AutoFileName ——- 自动补全文件路径 10、Autoprefixer ——- 应用css的浏览器兼容书写，自动分析你的css文件，解析出新的css文件 11、JavaScript Completions ——- js最基本的api快查片段 12、minify ——- 压缩和美化html,css,js文件 因为minify利用的是nodejs进行的，所以使用minify需要安装nodejs,同时需要全局安装如下： 1npm install -g clean-css-cli uglifycss js-beautify html-minifier uglify-js minjson svgo","updated":"2019-11-25T01:59:33.347Z","link":"","tags":[{"name":"tools","slug":"tools","permalink":"https://lifei-2019.github.io/tags/tools/"}]},{"title":"Typora入门","date":"2019-10-12T01:49:26.000Z","path":"typora/","text":"简介​ Typora删除了预览窗口，以及所有其他不必要的干扰。取而代之的是实时预览。​ Markdown的语法因不同的解析器或编辑器而异，Typora使用的是GitHub Flavored Markdown。 下载Typora下载。 常用快捷键 加粗： Ctrl/Cmd + B 标题： Ctrl/Cmd + H 插入链接： Ctrl/Cmd + K 插入代码： Ctrl/Cmd + Shift + C 行内代码： Ctrl/Cmd + Shift + K 插入图片： Ctrl/Cmd + Shift + I 无序列表： Ctrl/Cmd + Shift + L 撤销： Ctrl/Cmd + Z 一级标题：快捷键为Crtl + 1，以此类推 块元素换行符在markdown中，段落由多个空格分隔。在Typora中，只需回车即可创建新段落。 标题级别 # 一级标题， 快捷键为Crtl + 1## 二级标题，快捷键为Crtl + 2###### 六级标题，快捷键为Crtl + 6 引用文字 &gt; + 空格 + 引用文字 清单输入 *列表内容 将创建一个无序列表，该*符号可以替换为+或-。 输入1. 列表内容 将创建一个有序列表，其markdown源代码如下： 无序列表* AA* BB* CC 有序列表 AA BB CC 任务列表 - [ ] 不勾选- [x] 勾选 代码块在Typora中输入””” + 回车，并在后面选择一个语言名称即可语法高亮。 语法高亮:\\ 12&gt; &gt; def helloWorld():&gt; print &apos;hello, world&apos;&gt; \\&gt; 数学表达式输入$$，然后按“回车”键，如下：$$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\end{vmatrix}$$ $$\\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix}\\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\end{vmatrix}$$ 表输入| 表头1 | 表头2 |并回车。即可将创建一个包含两列的表，然后就像操作Word文档一样设置表格即可，没必要知道Markdown的复杂语法，因为这些语法会由Typora自动生成。效果如下： First Header Second Header 脚注 你可以创建一个脚注，像这样^1. 你可以创建一个脚注，像这样^1. 注意：该例子脚注标识是1，脚注标识可以为字母数字下划线，但是暂不支持中文。脚注内容可为任意字符，包括中文。 分割线输入***或--- 再按回车即可绘制一条水平线，如下： YAML Front MatterTypora支持YAML Front Matter， 在文章开头输入---，然后按回车即可。 目录（TOC）输入[toc]然后回车，即可创建一个“目录”。TOC从文档中提取所有标题，其内容将自动更新。 跨度元素跨度元素即图片，网址，视频等，在Typora中输入后，会立即载入并呈现。 链接内部链接 这是一个带有标题属性的[链接](http://example.com/ “标题”).这是一个没有标题属性的链接. 效果如下： 这是一个带有标题属性的链接.这是一个没有标题属性的链接. 参考链接 这是一个[参考链接]id。[id]: http://example.com/ “标题” 这是一个参考链接。 网址Typora允许用&lt;括号括起来&gt;, 把URL作为链接插入。输入[td_940915122@qq.com](mailto:940915122@qq.com) 即 td_940915122@qq.com。Typora还会自动链接标准网址。例如：https://lifei-2019.github.io/。 图片 *单个星号*_单下划线_ 效果如下：单个星号 单下划线 加粗 *两个星号*_双下划线_ 效果如下：两个星号双下划线 代码标记标记代码使用反引号，即在英文输入法下，ESC键下面和1键左边的符号——`效果如下：使用该printf()功能。 删除线 ~删除线 效果如下： 删除线 下划线&lt;u&gt;下划线 效果如下： 下划线 表情符号:smile: ：smile ：（注意为：是英文的冒号） :smile: 下标 H~2~O H2O (需在设置中打开该功能) 上标 X^2^ X^2^ (需在设置中打开该功能) 高亮 ==高亮== ==高亮==(需在设置中打开该功能) HTML支持HTML 嵌入内容支持iframe-based嵌入代码， &lt; iframe height=’265’ scrolling=’no’ title=’Fancy Animated SVG Menu’ src=’http://codepen.io/jeangontijo/embed/OxVywj/?height=265&amp;theme-id=0&amp;default-tab=css,result&amp;embed-version=2&#39; frameborder=’no’ allowtransparency=’true’ allowfullscreen=’true’ style=’width: 100%;’&gt; 视频 &lt; video src=”xxx.mp4” /&gt; :call_me_hand:常用字体及颜色设置 :call_me_hand:修改Typora默认样式 总结： 建议打开大纲视图（快捷键ctrl + shift + 1）。 插入表格需要顶格写，不然显示不出来。 以上语法不用刻意记，在Typora中的右键菜单都有， 常用功能基本上都有快捷键。 学计算机真让人掉发。","updated":"2019-11-25T02:00:22.078Z","link":"","tags":[{"name":"-tools","slug":"tools","permalink":"https://lifei-2019.github.io/tags/tools/"}]},{"title":"hexo+github建站","date":"2019-10-10T11:18:47.000Z","path":"hexo1/","text":"前言 欢迎在文末留言，觉得有帮助的话可以请作者喝杯咖啡。 本文采用 CC BY-NC-SA 4.0 许可协议，转载请注明出处！ 博客搭建准备环境 Node.js 下载，并安装。 Git 下载，并安装。（强烈推荐廖雪峰老师教程） 安装Hexo，在命令行（即Git Bash）运行以下命令： npm install -g hexo-cli 初始化Hexo，在命令行（即Git Bash）依次运行以下命令即可： 以下，即存放Hexo初始化文件的路径， 即站点目录。 1$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，在路径下，会产生这些文件和文件夹： 12.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 注： hexo相关命令均在站点目录下，用Git Bash运行。 站点配置文件：站点目录下的_config.yml。 路径为&lt;folder&gt;\\_config.yml 主题配置文件：站点目录下的themes文件夹下的，主题文件夹下的_config.yml。 路径为&lt;folder&gt;\\themes\\&lt;主题文件夹&gt;\\_config.yml 4.启动服务器。在路径下，命令行（即Git Bash）输入以下命令，运行即可： hexo server 5.浏览器访问网址： http://localhost:4000/ ​ 至此，您的Hexo博客已经搭建在本地。 实施方案方案一：GithubPages 创建Github账号 创建仓库， 仓库名为：&lt;Github账号名称&gt;.github.io 将本地Hexo博客推送到GithubPages 3.1. 安装hexo-deployer-git插件。在命令行（即Git Bash）运行以下命令即可： 1$ npm install hexo-deployer-git --save 3.2. 添加SSH key。 创建一个 SSH key 。在命令行（即Git Bash）输入以下命令， 回车三下即可： 1$ ssh-keygen -t rsa -C &quot;邮箱地址&quot; 添加到 github。 复制密钥文件内容（路径形如C:\\Users\\Administrator\\.ssh\\id_rsa.pub），粘贴到New SSH Key即可。 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 1$ ssh -T git@github.com$ yes 3.3. 修改_config.yml（在站点目录下）。文件末尾修改为： 1# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master 注意：上面仓库地址写ssh地址，不写http地址。 3.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 1$ hexo g$ hexo d 等待1分钟左右，浏览器访问网址： https://&lt;Github账号名称&gt;.github.io 至此，您的Hexo博客已经搭建在GithubPages, 域名为https://&lt;Github账号名称&gt;.github.io。 方案二：GithubPages + 域名在方案一的基础上，添加自定义域名（您购买的域名）。 域名解析。 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为&lt;Github账号名称&gt;.github.io； 解析线路，TTL 默认即可。 仓库设置。 2.1. 打开博客仓库设置：https://github.com/&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io/settings 2.2. 在Custom domain下，填写自定义域名，点击save。 2.3. 在站点目录的source文件夹下，创建并打开CNAME.txt，写入你的域名（如www.simon96.online），保存，并重命名为CNAME。 等待10分钟左右。 浏览器访问自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io依然可用。 方案三：GithubPages + CodingPages + 域名GithubPages 在国内较慢，百度不收录，而CodingPages 在国外较快。所以在方案二的基础上，添加CodingPages 。 创建Coding账号 创建仓库， 仓库名为：&lt;Coding账号名称&gt; 进入项目里『代码』页面，点击『一键开启静态 Pages』，稍等片刻CodingPages即可部署成功。 将本地Hexo博客推送到CodingPages 4.1. 鉴于创建GithubPages 时，已经生成过公钥。可直接复制密钥文件内容（路径形如C:\\Users\\Administrator\\.ssh\\id_rsa.pub）， 粘贴到新增公钥。 4.2. 测试是否添加成功。在命令行（即Git Bash）依次输入以下命令，返回“You’ve successfully authenticated”即成功： 1$ ssh -T git@git.coding.net$ yes 4.3. 修改_config.yml（在存放Hexo初始化文件的路径下）。文件末尾修改为： 1# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git branch: master- type: git repo: git@git.dev.tencent.com:&lt;Coding账号名称&gt;/&lt;Coding账号名称&gt;.git branch: master 4.4. 推送到GithubPages。在命令行（即Git Bash）依次输入以下命令， 返回INFO Deploy done: git即成功推送： 1$ hexo g$ hexo d 域名解析 添加 CNAME 记录指向 &lt;Coding账号名称&gt;.coding.me 类型选择为 CNAME； 主机记录即域名前缀，填写为www； 记录值填写为&lt;Github账号名称&gt;.coding.me； 解析线路，TTL 默认即可。 添加 两条A 记录指向 192.30.252.153和192.30.252.154 类型选择为 A； 主机记录即域名前缀，填写为@； 记录值填写为192.30.252.153和192.30.252.154； 解析线路，境外或谷歌。 在『Pages 服务』设置页（https://dev.tencent.com/u/&lt;Coding账号名称&gt;/p/&lt;Coding账号名称&gt;/git/pages/settings）中绑定自定义域名。 至此，您的Hexo博客已经解析到自定义域名，https://&lt;Github账号名称&gt;.github.io和https://&lt;Coding账号名称&gt;.coding.me依然可用。 主题优化选择主题Hexo默认的主题是landscape，推荐以下主题： snippet Hiero JSimple BlueLake 详见：https://github.com/search?q=hexo-theme 应用主题 下载主题 将下载好的主题文件夹，粘贴到站点目录的themes下。 更改站点配置文件_config.yml 的theme字段，为主题文件夹的名称： 1# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: &lt;主题文件夹的名称&gt; 主题优化以上主题都有比较详细的说明文档，本节主要解决主题优化的常见问题。 主题优化一般包括： 设置「RSS」 添加「标签」页面 添加「分类」页面 设置「字体」 问题：引用国外字体镜像较慢。 解决：可以改用国内的。将\\themes*\\layout_partials\\head external-fonts.swig文件中fonts.google.com改成fonts.lug.ustc.edu.cn。 设置「代码高亮主题」 侧边栏社交链接 问题：图标哪里找？ 解决：Font Awesome 开启打赏功能 问题：微信支付宝二维码不美观，规格不一。 解决：在线生成二维码 设置友情链接 腾讯公益404页面 站点建立时间 订阅微信公众号 设置「动画效果」 问题：慢，需要等待 JavaScript 脚本完全加载完毕后才会显示内容。解决：将主题配置文件_config.yml中，use_motion字段的值设为 false 来关闭动画。 设置「背景动画」 主题优化还包括： 添加背景图在 themes/*/source/css/_custom/custom.styl 中添加如下代码： 1body&#123; background:url(/images/bg.jpg); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:center;&#125; 修改Logo字体在 themes/*/source/css/_custom/custom.styl 中添加如下代码： 1@font-face &#123; font-family: Zitiming; src: url(&apos;/fonts/Zitiming.ttf&apos;);&#125;.site-title &#123; font-size: 40px !important; font-family: &apos;Zitiming&apos; !important;&#125; 其中字体文件在 themes/next/source/fonts 目录下，里面有个 .gitkeep 的隐藏文件，打开写入你要保留的字体文件，比如我的是就是写入 Zitiming.ttf ，具体字库自己从网上下载即可。 修改内容区域的宽度编辑主题的 source/css/_variables/custom.styl 文件，新增变量： 1// 修改成你期望的宽度$content-desktop = 700px// 当视窗超过 1600px 后的宽度$content-desktop-large = 900px 网站标题栏背景颜色打开 themes/*/source/css/_custom/custom.styl ,在里面写下如下代码： 1.site-meta &#123; background: $blue; //修改为自己喜欢的颜色&#125; 自定义鼠标样式打开 themes/*/source/css/_custom/custom.styl ,在里面写下如下代码： 1// 鼠标样式 * &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important &#125; :active &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important &#125; 文章加密访问打开 themes/*/layout/_partials/head.swig文件,在 ``之前插入代码： 1&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 写文章时加上password: *： 1---title: 2018date: 2018-10-25 16:10:03password: 123456--- 实现点击出现桃心效果 在/themes/*/source/js/src下新建文件click.js，接着把以下粘贴到click.js文件中。代码如下： 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\\themes\\*\\layout\\_layout.swig文件末尾添加： 1&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt; 静态资源压缩在站点目录下： 1$ npm install gulp -g 安装gulp插件： 1npm install gulp-minify-css --savenpm install gulp-uglify --savenpm install gulp-htmlmin --savenpm install gulp-htmlclean --savenpm install gulp-imagemin --save 在 Hexo 站点下新建 gulpfile.js文件，文件内容如下： 1var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);var imagemin = require(&apos;gulp-imagemin&apos;);// 压缩css文件gulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩html文件gulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩js文件gulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src([&apos;./public/**/.js&apos;,&apos;!./public/js/**/*min.js&apos;]) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public/demo 目录内图片gulp.task(&apos;minify-images&apos;, function() &#123; gulp.src(&apos;./public/demo/**/*.*&apos;) .pipe(imagemin(&#123; optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级） progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片 interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染 multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化 &#125;)) .pipe(gulp.dest(&apos;./public/uploads&apos;));&#125;);// 默认任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;,&apos;minify-images&apos;]); 只需要每次在执行 generate 命令后执行 gulp 就可以实现对静态资源的压缩，压缩完成后执行 deploy 命令同步到服务器： 1hexo ggulphexo d 修改访问URL路径默认情况下访问URL路径为：domain/2018/10/18/关于本站,修改为 domain/About/关于本站。 编辑 Hexo 站点下的 _config.yml 文件，修改其中的 permalink字段： 1permalink: :category/:title/ 博文置顶 安装插件 $ npm uninstall hexo-generator-index –save$ npm install hexo-generator-index-pin-top –save 然后在需要置顶的文章的Front-matter中加上top即可： 1---title: 2018date: 2018-10-25 16:10:03top: 10--- 设置置顶标志 打开：/themes/*/layout/_macro/post.swig，定位到 ，插入以下代码即可： 1&#123;% if post.top %&#125; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125; 在右上角或者左上角实现fork me on github 选择样式GitHub Ribbons, 修改图片跳转链接,将&lt;a href=&quot;https://github.com/you&quot;&gt;中的链接换为自己Github链接： 打开 themes/next/layout/_layout.swig 文件，把代码复制到&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面。 主页文章添加边框阴影效果打开 themes/*/source/css/_custom/custom.styl ,向里面加代码: 1// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 显示当前浏览进度修改themes/*/_config.yml，把 false 改为 true： 1# Back to top in sidebarb2t: true# Scroll percent label in b2t buttonscrollpercent: true 创建分类页在终端窗口下，定位到 Hexo 站点目录下，新建： 1$ cd &lt;站点目录&gt;$ hexo new page categories 加入 广告主要有两种：百度SSP和谷歌Adsense。方法类似： 注册，复制广告代码 部署到网站。 2.1. 新建 theme/*/layout/_custom/google_ad.swig，将 AdSense 上的代码粘贴进去 2.2. 头部。在 theme/*/layout/_custom/head.swig 中也粘贴一份 2.3. 每篇博客。在 theme/*/layout/post.swig 里中在希望看到的地方加上： 1&#123;% include &apos;_custom/google_ad.swig&apos; %&#125; 例如：在 &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &lt;/div&gt; 中间插入，总代码如下： 1&#123;% block content %&#125; &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &#123;&#123; post_template.render(page) &#125;&#125; &#123;% include &apos;_custom/google_ad.swig&apos; %&#125; &lt;/div&gt;&#123;% endblock %&#125; 等待审核通过。如果失败，可再次申请。 添加萌萌哒 安装插件 1npm install --save hexo-helper-live2d 复制你喜欢的模型名字： Epsilon2.1 Gantzert_Felixander haru miku ni-j nico nietzche nipsilon nito shizuku tsumiki wanko z16 hibiki koharu haruto Unitychan tororo hijiki 将以下代码添加到主题配置文件_config.yml，修改&lt;你喜欢的模型名字&gt;： 1live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-&lt;你喜欢的模型名字&gt; display: position: right width: 150 height: 300 mobile: show: true 建配置文件 4.1. 在站点目录下建文件夹live2d_models， 4.2. 再在live2d_models下建文件夹&lt;你喜欢的模型名字&gt;, 4.3. 再在&lt;你喜欢的模型名字&gt;下建json文件：&lt;你喜欢的模型名字&gt;.model.json 安装模型。在命令行（即Git Bash）运行以下命令即可： npm install –save live2d-widget-model-&lt;你喜欢的模型名字&gt; 在命令行（即Git Bash）运行以下命令， 在http://127.0.0.1:4000/查看测试结果: hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 插件配置以下插件（评论系统、数据统计与分析、内容分享服务、搜索服务）各选一个即可。 评论系统 推荐指数 优点 缺点 Valine 4 每天30000条评论，10GB的储存 作者评论无标识 来必力/livere 4 多种账号登录 评论无法导出 畅言 3 美观 必须备案域名 gitment 3 简洁 只能登陆github评论 Disqus 1 需要翻*墙 Valine1.1. 获取APP ID 和 APP Key 请先登录或注册 LeanCloud, 进入控制台后点击左下角创建应用， 进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了。 1.2. 填写APP ID 和 APP Key到主题配置文件_config.yml 1.3. 运行hexo g&amp;&amp;hexo d推送到博客。 来必力/livere2.1. 登陆 来必力 获取你的 LiveRe UID。 2.2. 填写LiveRe UID到主题配置文件_config.yml 畅言3.1.获取APP ID 和 APP Key 请先登录或注册 畅言, 点击“立即免费获取畅言”， 新建站点，点击管理，点击评论插件&gt;评论管理， 点击后台总览，然后就能看到你的APP ID和APP Key了。 3.2. 填写APP ID 和 APP Key到主题配置文件_config.yml 3.3. 运行hexo g&amp;&amp;hexo d推送到博客。 gitment4.1. 安装插件： npm i –save gitment 4.2. 申请应用 在New OAuth App为你的博客应用一个密钥: 1Application name:随便写Homepage URL:这个也可以随意写,就写你的博客地址就行Application description:描述,也可以随意写Authorization callback URL:这个必须写你的博客地址 4.3. 配置 编辑主题配置文件themes/*/_config.yml: 1# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: &#123;you github user id&#125; github_repo: 公开的git仓库,评论会作为那个项目的issue client_id: &#123;刚才申请的ClientID&#125; client_secret: &#123;刚才申请的Client Secret&#125; proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_pro Disqus编辑 主题配置文件themes/*/_config.yml， 将 disqus 下的 enable 设定为 true，同时提供您的 shortname。count 用于指定是否显示评论数量。 1disqus: enable: false shortname: count: true 数据统计与分析 推荐指数 优点 缺点 不蒜子 4 可直接将访问次数显示在您在网页上（也可不显示） 只计数 百度统计 3 收录慢 不蒜子编辑 主题配置文件 themes/*/_config.yml中的busuanzi_count的配置项即可。 当enable: true时，代表开启全局开关。 若site_uv（本站访客数）、site_pv（本站访客数）、page_pv（本文总阅读量）的值均为false时，不蒜子仅作记录而不会在页面上显示。 注意： 1不蒜子官方因七牛强制过期原有的『dn-lbstatics.qbox.me』域名（预计2018年10月初），与客服沟通数次无果，即使我提出为此付费也不行，只能更换域名到『busuanzi.ibruce.info』！ 解决办法： 找到主题调用不蒜子的swig文件。一般在”\\themes*\\layout_third-party\\analytics\\busuanzi-counter.swig” 更改域名 1把原有的：&lt;script async src=&quot;\u0001\u0001//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002&quot;&gt;&lt;/script&gt;域名改一下即可：&lt;script async src=&quot;\u0001\u0001//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0002\u0002&quot;&gt;&lt;/script&gt; 百度统计 登录 百度统计，定位到站点的代码获取页面 复制统计脚本 id，如图：​ 编辑 主题配置文件themes/*/_config.yml，修改字段 google_analytics，值设置成你的统计脚本 id。 内容分享服务 推荐指数 优点 缺点 百度分享 4 稳定 不太美观 need-more-share2 4 美观 更新不及时（比如微信分享API） 百度分享编辑 主题配置文件，添加/修改字段 baidushare，值为 true即可。 1# 百度分享服务baidushare: true need-more-share2编辑 主题配置文件，添加/修改字段 needmoreshare2，值为 true即可。 1needmoreshare2: enable: true 搜索服务 推荐指数 优点 缺点 Local Search 4 配置方便 Swiftype 2 需注册 Algolia 2 需注册 Local Search添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 1search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 1# Local searchlocal_search: enable: true 错误分析如果你使用Hexo遇到同样的问题,这里有一些常见问题的解决方案。 YAML Parsing Error1JS-YAML: incomplete explicit mapping pair; a key node is missed at line 18, column 29: last_updated: Last updated: %s 参数中包含冒号，请用加引号，如Last updated: %s 1JS-YAML: bad indentation of a mapping entry at line 18, column 31: last_updated：&quot;Last updated: %s&quot; 字段后面的冒号必须为英文冒号，如：last_updated: 字段冒号后面必须跟一个空格，如：last_updated: “Last updated: %s” EMFILE Error1Error: EMFILE, too many open files 生成大量的文件时，可能遇到EMFILE错误。 可以运行以下命令来增加允许同步I / O操作的数量。 1$ ulimit -n 10000 Process Out of Memory当hexo g时，遇到以下错误： 1FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory 如下，更改hexo-cli文件的第一行，来增大nodejs堆内存.该bug已在新版本修复。 1#!/usr/bin/env node --max_old_space_size=8192 Git Deployment Problems RPC failed 1error: RPC failed; result=22, HTTP code = 403fatal: &apos;username.github.io&apos; does not appear to be a git repository 确保你有你的电脑上设置git正确或尝试使用HTTPS存储库URL。 Error: ENOENT: no such file or directory 这个需要有一定的git的知识，因为可能是由于写错了标签,类别,或文件名，导致本地和github冲突了，Git不能自动合并这一变化所以它打破了自动分支。 解决办法： 检查文章的标签和类别,确保本地和github上是相同的。 合并分支（Commit）。 清除，重构。在站点目录下，命令行（即Git Bash）运行hexo clean和hexo g 手动将站点目录下的public文件夹复制到您的桌面 从你的master分支切换到部署在本地分支。 从桌面复制public文件夹到本地分支。 合并分支到github（Commit）。 切回master分支。 Server Problems1Error: listen EADDRINUSE 你可能使用相同的端口，同时开启了两个Hexo服务器。如果需要同时开启，可以尝试修改端口设置： 1$ hexo server -p 5000 Plugin Installation Problems1npm ERR! node-waf configure build 这个错误可能发生在试图安装一个用Cc++或另一个javascript语言编写的插件。确保您已经安装了正确的编译器在您的计算机上。 Error with DTrace (Mac OS X)1&#123; [Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125; DTrace安装可能有问题，重装: 1$ npm install hexo --no-optional 详见 #1326 Iterate Data Model on Jade or SwigHexo使用仓库的数据模型。这不是一个数组,所以你可能需要将对象转换为iterable。 1&#123;% for post in site.posts.toArray() %&#125;&#123;% endfor %&#125; Data Not Updated一些数据不能更新或新生成的文件的最后一个版本完全相同。清理缓存，再试一次： 1$ hexo clean No command is executed那个不能使用除help、init和version以外的命令行（即Git Bash）时, 有可能时站点目录下的 package.json文件，缺少hexo，如下: 1&#123; &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;3.2.2&quot; &#125;&#125; Escape ContentsHexo使用Nunjucks渲染的页面. { { } }或{ % % }将解析和可能会引起麻烦， 如果要在博文中出现，必须使用三引号： 12 Hello 1​```#### ENOSPC Error (Linux)如果运行命令`$ hexo server` 返回一个错误: Error: watch ENOSPC … 1可以通过运行`$ npm dedupe`或者以下命令行（即Git Bash）： $ echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p 1来增加测试时，你可以看见的文件数量。#### EMPERM Error (Windows Subsystem for Linux)如果在Windows Subsystem for Linux，运行命令`$ hexo server` 返回这个错误: Error: watch /path/to/hexo/theme/ EMPERM 1因为目前在Windows Subsystem for Linux中，有些内容更改时，还不能实时更新到hexo服务器。所以需要重新编译，再启动服务器： $ hexo generate$ hexo server -s 1#### Template render error有时运行命令`$ hexo generate` 返回一个错误: FATAL Something’s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) 1这意味着有些认不出来单词在你的文件，并且很可能在你的新博文,或者配置文件`_config.yml`中，比如缩进错误：错误例子： plugins:hexo-generator-feedhexo-generator-sitemap&lt;!–￼66–&gt; $ hexo new [layout] 123456789101112参数说明：- [layout]可以为以下三种：| 参数名 | 功能 | 文章路径 || :----- | :---------------------- | :------------- || post | 新建博文 | source/_posts || page | 新建页面（如404，分类） | source || draft | 草稿 | source/_drafts |草稿可通过一下命令发布： $ hexo publish [layout] ``` title注意： 不是博文标题， 是博文markdown文件的名字， 也是博文链接的后缀（如https://lifei-2019.github.io/typora/中的typora） 文章模版 创建模版 在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： $ hexo new blog “simon” 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 blog.md，并根据其内容建立文章。 修改参数 以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期 Front-matter就是博文最上方以 --- 分隔的那部分。 默认可以使用的Front-matter： 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址","updated":"2019-11-28T02:18:05.616Z","link":"","tags":[{"name":"hexo","slug":"hexo","permalink":"https://lifei-2019.github.io/tags/hexo/"}]},{"title":"浅析《海边的卡夫卡》","date":"2019-10-10T10:50:52.000Z","path":"kafuka/","text":"大约刚好一个月看完了《海边的卡夫卡》，头一次看村上的书，海边的卡夫卡由奇数章和偶数章两个故事交替展开，并在最后交叉在一起。 奇数章以第一人称平叙田村卡夫卡君在现实世界中的闯荡与心理活动。偶数章则是以第三人称讲述因一次意外丧失全部记忆、失去理解能力的中田先生，他以空白的躯壳过着简单的生活。在两条线的交汇处，田村应验了父亲的诅咒：你迟早会杀掉你的父亲，并与你的母亲交合。田村以中田的身躯杀掉了父亲，然后中田在无意识中踏上了关闭”世界之门”的旅程。之后中田的线与田村君的内心旅程是密切关联的。中田面对的是外部世界的不堪与罪恶，田村君面对的是内心中的诱惑与负罪感。田村在受过一种类似宿命论的诅咒后，在救赎中挣扎的过程，让我深深体会到人性的不堪与美好。 ​ 在田村君以及中田君的经历中，我体会到了一种宿命论的基调，就好似一切都是先定的，人为再怎么努力也无法改变。田村的父亲曾经恶毒地诅咒他：你迟早要用你的双手杀死父亲，迟早要同你母亲交合。他为了挣脱这个诅咒，才选择自我放逐，然而最终没有摆脱这个诅咒，所有的一一应验。 ​ 这一设定很显然来源于希腊悲剧《俄狄浦斯王》。俄狄浦斯是忒拜国王拉伊俄斯与王后伊俄卡斯忒的儿子。他出生前，拉伊俄斯从阿波罗神处得知他将来会弑父娶母，于是他刚出生就被抛弃于峡谷，结果他被一个老人救起，被后任国王和王后收为养子。长大后他得知这一预言，为了避免预言发生，离开了被他认为亲生的养父养母。逃亡途中与一陌生人吵架，并动怒打死一个老年人，那老人正是他的父亲。到达目的地后，他被拥戴为王，娶了前王后为妻，此即她生母，预言到此全部应验。得知真相后，他刺瞎了自己的双眼，自我放逐。 ​ 俄狄浦斯是一个正直善良的人，可是被毁灭与宿命论困囿，无论如何挣扎反抗都是徒劳，该发生的一点一点地全部发生。这让我想到以前看过的一部电影，叫《十二猴子》，男主是来自未来的一位劳改犯人，科学家们为了阻止十年前的一场毁灭人类的瘟疫，利用时光机将其送回去，希望他能找到这场瘟疫灾难的线索，并进行有效阻止。可他回到过去后却迷恋过去的生活，行动因而受影响，导致最终失败：他在阻止瘟疫携带者进入飞机那一刻被枪杀。更具讽刺意味的是，他被枪杀的现场围满了人，其中一个小孩正是幼年的男主角。 这些宿命论的情节总是在给我们传导一种悲观的论调。它们总是在说：“人在命运面前是苍白无力的，我们无论如何挣扎，都不能改变它!” ​ 那么田村卡夫卡所受的诅咒应验了吗？答案是肯定的。卡夫卡为了避免父亲的恶毒预言出走，反而导致了父亲被杀，母亲也与他进行了交合，只是方式上有些许的不同。在小说的叙述中，是中田杀害了著名的雕塑家田村浩一，也就是卡夫卡的父亲。可奇怪的是卡夫卡在父亲被杀那天昏迷于野外，醒来后他发现自己身上沾满了鲜血，而中田本人事后却滴血未沾。 ​ 这就是村上对于“物语”的运用，只要符合小说旨意，故事的理性与常识逻辑不再重要，在小说中，一切都是可能发生的，故事旨意的优先级远高于常识逻辑。 ​ 以作者的逻辑，父亲的确实是被儿子杀死的，只是方式比较特殊。那么“迟早与母亲交合”的诅咒呢？利用“物语”的解释，应该也是应验了。佐伯（他的母亲）以少女的形象出现在墙上挂有《海边的卡夫卡》的房间内，以“睡着”的姿态与卡夫卡交合，而卡夫卡君没有任何的扭转之力。 ​ 作者为什么要这样安排，把一个心智尚未健全，世界观未成熟、涉世未生的男孩儿写得如此扭曲与不堪？他的不堪与扭曲并不来自于他自身，而是来于他父亲给予的邪恶基因以及父亲对他幼年的诅咒而产生的心理阴影。他选择的逃避之路，恰恰是他的崩坏与重建的道路。故事中他对诅咒的践行，正是他自我重塑“重新发现自我”，摆脱悬于他头上的达摩克里斯之剑的过程，只有通过这一条路，才能净化自我，终结先天留下的恶。 ​ 与其他类似作品不同的是，作者将卡夫卡的“恶”，设定为天性中的“恶”，是遗传的恶基因。他天生就是一个被损毁的人，他的父亲死后，他没有感到任何的悲伤；同他母亲交合时，他也完全可以选择就此打住叫醒母亲。可以说，尽管他如此地糟糕，作者还是给与他各种帮助，灌输以良知，潜移默化得影响，他最终得到救赎。但这种救赎的发起不是别人，正是他自己。最终他认可了自己，他的良知也宽恕了他自身。起初他只是想逃避社会，逃避自己，经历了各种遭遇，他毅然决然选择了自我救赎，重新融入社会，不再自我放逐，开始担负起属于自我的责任。至此，他走向重生，脱离俄狄浦斯王自我毁灭的魔咒。至此，卡夫卡完成了崩坏与救赎的全过程。 ​ 有些时候，命运总是不可违抗的。我们对命运的逃避，往往使我们再次落入命运的圈套。有些事情是作为人类的我们无法逃避的，但这并不代表我们面对它只能引颈待宰。逃避只能更加放大我们天性中的怯懦与消极。面对不可抗拒力，我们要迎其难而上。这是人生必不可少的经历，也可以说他是对我们的考验，这些正是我们从“崩坏”走向“救赎”的节点，正是成长中的转折处。人性往往就在这一点上得以升华，就如鲤鱼跃然跳过龙门！ ​ 不能直面自身自然是可悲的，就好比《禁闭岛》中的男主，他杀害了妻子，却不能接受现实，就患上了一种臆想症。他为了逃避现实中的自我，把自己想象为大义凛然的检察官。那里的工作人员都一同配合他“演戏”，企图让他在自己的角色中找到破绽，从而恢复正常精神，然而他内心极力不想面对自己，在死循环中度过了十余年。 ​ 每个人都带有天性中的恶，当我们每个人反省自己时。或多或少都会找到那个不堪面对的“恶我”。每个人或多或少在自身的经历中放逐过那个“恶我”。换一种定义，可以称之为“阴暗人格”。也许阴暗人格无法被消除，毕竟人是善恶相融合的产物。但面对“恶”，我们必须正视它，对于以前所犯的无意识的恶，我们要承认与反思。正如同基督教中的“原罪”思想，每个人都有罪，只是有些是显性的，有些是隐性的。我们必须发挥人性中光辉的那一面，克服阴暗的一面，自我救赎，自我重塑。基督教中的“救赎”是为了获得上帝的认同，而我们的救赎，则是努力让自我的良知接受自己。对别人的肯定，首先是自我的肯定。 ​ 田村君以孤立无援的状态离开了家门，投入到波涛汹涌的成年人世界之中，那里有企图伤害他的力量。那种力量有时候就在现实之中，有时候则来自现实之外。而与此同时，又有许多人愿意拯救或结果上拯救了他的灵魂。他被冲往世界的尽头，又以自身力量返回，返回之际他已不再是他，他已进入下一阶段。 ​ 于是我们领教了世界何等凶顽，同时又得知世界也可以变得温存和美好。","updated":"2019-11-04T12:30:42.783Z","link":"","tags":[{"name":"读书","slug":"读书","permalink":"https://lifei-2019.github.io/tags/读书/"}]},{"title":"enjoy life！enjoy coding！","date":"2019-10-10T10:33:28.000Z","path":"test/","text":"衷心感谢dalao的教导","updated":"2019-11-06T00:40:26.230Z","link":"","tags":[]},{"title":"webpack-02","date":"2019-03-02T01:40:59.000Z","path":"webpack-02/","text":"在通过vs code 运行webpack进行打包时，报错webpack : 无法加载文件 D:\\nodejs\\node_global\\webpack.ps1，因为在此系统上禁止运行脚本。解决方案： 1、以管理员身份运行vs code 2、执行：get-ExecutionPolicy，显示Restricted，表示状态是禁止的 3、执行：set-ExecutionPolicy RemoteSigned 4、这时再执行get-ExecutionPolicy，就显示RemoteSigned 此时发现再进行打包就没有问题了","updated":"2020-03-06T08:57:50.228Z","link":"","tags":[{"name":"前端","slug":"前端","permalink":"https://lifei-2019.github.io/tags/前端/"},{"name":"webpack","slug":"webpack","permalink":"https://lifei-2019.github.io/tags/webpack/"}]}]